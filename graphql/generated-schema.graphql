schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

input EmailVerifyInput {
  resend: Boolean
  token: String!
}

type EmailVerifyOutput {
  result: String
}

input ForgotPasswordInput {
  email: String!
  platform: String
}

type ForgotPasswordOutput {
  error: String
  success: Boolean
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [Int!]

  """does the array contain the given value"""
  _contains: [Int!]
  _eq: [Int!]
  _gt: [Int!]
  _gte: [Int!]
  _in: [[Int!]!]
  _is_null: Boolean
  _lt: [Int!]
  _lte: [Int!]
  _neq: [Int!]
  _nin: [[Int!]!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input LoginInput {
  email: String
  password: String
}

type LoginOutput {
  access_token: String
  body: json
  error: String
  refresh_token: String
}

type RefreshTokenOutput {
  access_token: String!
  body: json
  error: String
}

input RegisterInput {
  email: String!
  firstname: String
  lastname: String
  password: String
  phone: String
  picture: String
  platform: String
  provider: String
  provider_id: String
}

type RegisterOutput {
  body: json
  data: json
  error: String
}

input ResetPasswordInput {
  new_password: String!
  reset_token: String!
}

type ResetPasswordOutput {
  error: String
  success: Boolean
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [String!]

  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _is_null: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "address_type"
"""
type address_type {
  value: String!
}

"""
aggregated selection of "address_type"
"""
type address_type_aggregate {
  aggregate: address_type_aggregate_fields
  nodes: [address_type!]!
}

"""
aggregate fields of "address_type"
"""
type address_type_aggregate_fields {
  count(columns: [address_type_select_column!], distinct: Boolean): Int!
  max: address_type_max_fields
  min: address_type_min_fields
}

"""
Boolean expression to filter rows from the table "address_type". All fields are combined with a logical 'AND'.
"""
input address_type_bool_exp {
  _and: [address_type_bool_exp!]
  _not: address_type_bool_exp
  _or: [address_type_bool_exp!]
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "address_type"
"""
enum address_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  address_type_pkey
}

enum address_type_enum {
  company
  invoice
}

"""
Boolean expression to compare columns of type "address_type_enum". All fields are combined with logical 'AND'.
"""
input address_type_enum_comparison_exp {
  _eq: address_type_enum
  _in: [address_type_enum!]
  _is_null: Boolean
  _neq: address_type_enum
  _nin: [address_type_enum!]
}

"""
input type for inserting data into table "address_type"
"""
input address_type_insert_input {
  value: String
}

"""aggregate max on columns"""
type address_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type address_type_min_fields {
  value: String
}

"""
response of any mutation on the table "address_type"
"""
type address_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [address_type!]!
}

"""
input type for inserting object relation for remote table "address_type"
"""
input address_type_obj_rel_insert_input {
  data: address_type_insert_input!

  """upsert condition"""
  on_conflict: address_type_on_conflict
}

"""
on_conflict condition type for table "address_type"
"""
input address_type_on_conflict {
  constraint: address_type_constraint!
  update_columns: [address_type_update_column!]! = []
  where: address_type_bool_exp
}

"""Ordering options when selecting data from "address_type"."""
input address_type_order_by {
  value: order_by
}

"""primary key columns input for table: address_type"""
input address_type_pk_columns_input {
  value: String!
}

"""
select columns of table "address_type"
"""
enum address_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "address_type"
"""
input address_type_set_input {
  value: String
}

"""
Streaming cursor of the table "address_type"
"""
input address_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: address_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input address_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "address_type"
"""
enum address_type_update_column {
  """column name"""
  value
}

input address_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: address_type_set_input

  """filter the rows which have to be updated"""
  where: address_type_bool_exp!
}

"""Tenant answer belong to a specific question"""
type answer {
  answer: String!
  created_at: timestamptz!
  id: bigint!

  """An object relationship"""
  question: question!
  question_id: bigint!
  updated_at: timestamptz!
}

"""
aggregated selection of "answer"
"""
type answer_aggregate {
  aggregate: answer_aggregate_fields
  nodes: [answer!]!
}

input answer_aggregate_bool_exp {
  count: answer_aggregate_bool_exp_count
}

input answer_aggregate_bool_exp_count {
  arguments: [answer_select_column!]
  distinct: Boolean
  filter: answer_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "answer"
"""
type answer_aggregate_fields {
  avg: answer_avg_fields
  count(columns: [answer_select_column!], distinct: Boolean): Int!
  max: answer_max_fields
  min: answer_min_fields
  stddev: answer_stddev_fields
  stddev_pop: answer_stddev_pop_fields
  stddev_samp: answer_stddev_samp_fields
  sum: answer_sum_fields
  var_pop: answer_var_pop_fields
  var_samp: answer_var_samp_fields
  variance: answer_variance_fields
}

"""
order by aggregate values of table "answer"
"""
input answer_aggregate_order_by {
  avg: answer_avg_order_by
  count: order_by
  max: answer_max_order_by
  min: answer_min_order_by
  stddev: answer_stddev_order_by
  stddev_pop: answer_stddev_pop_order_by
  stddev_samp: answer_stddev_samp_order_by
  sum: answer_sum_order_by
  var_pop: answer_var_pop_order_by
  var_samp: answer_var_samp_order_by
  variance: answer_variance_order_by
}

"""
input type for inserting array relation for remote table "answer"
"""
input answer_arr_rel_insert_input {
  data: [answer_insert_input!]!

  """upsert condition"""
  on_conflict: answer_on_conflict
}

"""aggregate avg on columns"""
type answer_avg_fields {
  id: Float
  question_id: Float
}

"""
order by avg() on columns of table "answer"
"""
input answer_avg_order_by {
  id: order_by
  question_id: order_by
}

"""
Boolean expression to filter rows from the table "answer". All fields are combined with a logical 'AND'.
"""
input answer_bool_exp {
  _and: [answer_bool_exp!]
  _not: answer_bool_exp
  _or: [answer_bool_exp!]
  answer: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  question: question_bool_exp
  question_id: bigint_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "answer"
"""
enum answer_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  answer_pkey

  """
  unique or primary key constraint on columns "question_id"
  """
  answer_question_id_key
}

"""
input type for incrementing numeric columns in table "answer"
"""
input answer_inc_input {
  id: bigint
  question_id: bigint
}

"""
input type for inserting data into table "answer"
"""
input answer_insert_input {
  answer: String
  created_at: timestamptz
  id: bigint
  question: question_obj_rel_insert_input
  question_id: bigint
  updated_at: timestamptz
}

"""aggregate max on columns"""
type answer_max_fields {
  answer: String
  created_at: timestamptz
  id: bigint
  question_id: bigint
  updated_at: timestamptz
}

"""
order by max() on columns of table "answer"
"""
input answer_max_order_by {
  answer: order_by
  created_at: order_by
  id: order_by
  question_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type answer_min_fields {
  answer: String
  created_at: timestamptz
  id: bigint
  question_id: bigint
  updated_at: timestamptz
}

"""
order by min() on columns of table "answer"
"""
input answer_min_order_by {
  answer: order_by
  created_at: order_by
  id: order_by
  question_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "answer"
"""
type answer_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [answer!]!
}

"""
on_conflict condition type for table "answer"
"""
input answer_on_conflict {
  constraint: answer_constraint!
  update_columns: [answer_update_column!]! = []
  where: answer_bool_exp
}

"""Ordering options when selecting data from "answer"."""
input answer_order_by {
  answer: order_by
  created_at: order_by
  id: order_by
  question: question_order_by
  question_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: answer"""
input answer_pk_columns_input {
  id: bigint!
}

"""
select columns of table "answer"
"""
enum answer_select_column {
  """column name"""
  answer

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  question_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "answer"
"""
input answer_set_input {
  answer: String
  created_at: timestamptz
  id: bigint
  question_id: bigint
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type answer_stddev_fields {
  id: Float
  question_id: Float
}

"""
order by stddev() on columns of table "answer"
"""
input answer_stddev_order_by {
  id: order_by
  question_id: order_by
}

"""aggregate stddev_pop on columns"""
type answer_stddev_pop_fields {
  id: Float
  question_id: Float
}

"""
order by stddev_pop() on columns of table "answer"
"""
input answer_stddev_pop_order_by {
  id: order_by
  question_id: order_by
}

"""aggregate stddev_samp on columns"""
type answer_stddev_samp_fields {
  id: Float
  question_id: Float
}

"""
order by stddev_samp() on columns of table "answer"
"""
input answer_stddev_samp_order_by {
  id: order_by
  question_id: order_by
}

"""
Streaming cursor of the table "answer"
"""
input answer_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: answer_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input answer_stream_cursor_value_input {
  answer: String
  created_at: timestamptz
  id: bigint
  question_id: bigint
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type answer_sum_fields {
  id: bigint
  question_id: bigint
}

"""
order by sum() on columns of table "answer"
"""
input answer_sum_order_by {
  id: order_by
  question_id: order_by
}

"""
update columns of table "answer"
"""
enum answer_update_column {
  """column name"""
  answer

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  question_id

  """column name"""
  updated_at
}

input answer_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: answer_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: answer_set_input

  """filter the rows which have to be updated"""
  where: answer_bool_exp!
}

"""aggregate var_pop on columns"""
type answer_var_pop_fields {
  id: Float
  question_id: Float
}

"""
order by var_pop() on columns of table "answer"
"""
input answer_var_pop_order_by {
  id: order_by
  question_id: order_by
}

"""aggregate var_samp on columns"""
type answer_var_samp_fields {
  id: Float
  question_id: Float
}

"""
order by var_samp() on columns of table "answer"
"""
input answer_var_samp_order_by {
  id: order_by
  question_id: order_by
}

"""aggregate variance on columns"""
type answer_variance_fields {
  id: Float
  question_id: Float
}

"""
order by variance() on columns of table "answer"
"""
input answer_variance_order_by {
  id: order_by
  question_id: order_by
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""sepet"""
type cart {
  content(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz!
  guest_id: uuid
  id: uuid!
  updated_at: timestamptz!

  """An object relationship"""
  user: user
  user_id: uuid
}

"""
aggregated selection of "cart"
"""
type cart_aggregate {
  aggregate: cart_aggregate_fields
  nodes: [cart!]!
}

input cart_aggregate_bool_exp {
  count: cart_aggregate_bool_exp_count
}

input cart_aggregate_bool_exp_count {
  arguments: [cart_select_column!]
  distinct: Boolean
  filter: cart_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "cart"
"""
type cart_aggregate_fields {
  count(columns: [cart_select_column!], distinct: Boolean): Int!
  max: cart_max_fields
  min: cart_min_fields
}

"""
order by aggregate values of table "cart"
"""
input cart_aggregate_order_by {
  count: order_by
  max: cart_max_order_by
  min: cart_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input cart_append_input {
  content: jsonb
}

"""
input type for inserting array relation for remote table "cart"
"""
input cart_arr_rel_insert_input {
  data: [cart_insert_input!]!

  """upsert condition"""
  on_conflict: cart_on_conflict
}

"""
Boolean expression to filter rows from the table "cart". All fields are combined with a logical 'AND'.
"""
input cart_bool_exp {
  _and: [cart_bool_exp!]
  _not: cart_bool_exp
  _or: [cart_bool_exp!]
  content: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  guest_id: uuid_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "cart"
"""
enum cart_constraint {
  """
  unique or primary key constraint on columns "guest_id"
  """
  cart_guest_id_key

  """
  unique or primary key constraint on columns "id"
  """
  cart_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  cart_user_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input cart_delete_at_path_input {
  content: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input cart_delete_elem_input {
  content: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input cart_delete_key_input {
  content: String
}

"""
input type for inserting data into table "cart"
"""
input cart_insert_input {
  content: jsonb
  created_at: timestamptz
  guest_id: uuid
  id: uuid
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type cart_max_fields {
  created_at: timestamptz
  guest_id: uuid
  id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "cart"
"""
input cart_max_order_by {
  created_at: order_by
  guest_id: order_by
  id: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type cart_min_fields {
  created_at: timestamptz
  guest_id: uuid
  id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "cart"
"""
input cart_min_order_by {
  created_at: order_by
  guest_id: order_by
  id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "cart"
"""
type cart_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [cart!]!
}

"""
on_conflict condition type for table "cart"
"""
input cart_on_conflict {
  constraint: cart_constraint!
  update_columns: [cart_update_column!]! = []
  where: cart_bool_exp
}

"""Ordering options when selecting data from "cart"."""
input cart_order_by {
  content: order_by
  created_at: order_by
  guest_id: order_by
  id: order_by
  updated_at: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: cart"""
input cart_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input cart_prepend_input {
  content: jsonb
}

"""
select columns of table "cart"
"""
enum cart_select_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  guest_id

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "cart"
"""
input cart_set_input {
  content: jsonb
  created_at: timestamptz
  guest_id: uuid
  id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "cart"
"""
input cart_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: cart_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input cart_stream_cursor_value_input {
  content: jsonb
  created_at: timestamptz
  guest_id: uuid
  id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "cart"
"""
enum cart_update_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  guest_id

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input cart_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: cart_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: cart_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: cart_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: cart_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: cart_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: cart_set_input

  """filter the rows which have to be updated"""
  where: cart_bool_exp!
}

"""
columns and relationships of "category"
"""
type category {
  """An array relationship"""
  companies(
    """distinct select on columns"""
    distinct_on: [company_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_category_order_by!]

    """filter the rows returned"""
    where: company_category_bool_exp
  ): [company_category!]!

  """An aggregate relationship"""
  companies_aggregate(
    """distinct select on columns"""
    distinct_on: [company_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_category_order_by!]

    """filter the rows returned"""
    where: company_category_bool_exp
  ): company_category_aggregate!
  description: String
  id: Int!
  image_url: String
  name: String!

  """An object relationship"""
  parent_category: category
  parent_category_id: Int

  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [product_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_category_order_by!]

    """filter the rows returned"""
    where: product_category_bool_exp
  ): [product_category!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [product_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_category_order_by!]

    """filter the rows returned"""
    where: product_category_bool_exp
  ): product_category_aggregate!
  slug: String

  """An array relationship"""
  sub_categories(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): [category!]!

  """An aggregate relationship"""
  sub_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): category_aggregate!

  """An array relationship"""
  tenants(
    """distinct select on columns"""
    distinct_on: [tenant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_category_order_by!]

    """filter the rows returned"""
    where: tenant_category_bool_exp
  ): [tenant_category!]!

  """An aggregate relationship"""
  tenants_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_category_order_by!]

    """filter the rows returned"""
    where: tenant_category_bool_exp
  ): tenant_category_aggregate!
}

"""
aggregated selection of "category"
"""
type category_aggregate {
  aggregate: category_aggregate_fields
  nodes: [category!]!
}

input category_aggregate_bool_exp {
  count: category_aggregate_bool_exp_count
}

input category_aggregate_bool_exp_count {
  arguments: [category_select_column!]
  distinct: Boolean
  filter: category_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "category"
"""
type category_aggregate_fields {
  avg: category_avg_fields
  count(columns: [category_select_column!], distinct: Boolean): Int!
  max: category_max_fields
  min: category_min_fields
  stddev: category_stddev_fields
  stddev_pop: category_stddev_pop_fields
  stddev_samp: category_stddev_samp_fields
  sum: category_sum_fields
  var_pop: category_var_pop_fields
  var_samp: category_var_samp_fields
  variance: category_variance_fields
}

"""
order by aggregate values of table "category"
"""
input category_aggregate_order_by {
  avg: category_avg_order_by
  count: order_by
  max: category_max_order_by
  min: category_min_order_by
  stddev: category_stddev_order_by
  stddev_pop: category_stddev_pop_order_by
  stddev_samp: category_stddev_samp_order_by
  sum: category_sum_order_by
  var_pop: category_var_pop_order_by
  var_samp: category_var_samp_order_by
  variance: category_variance_order_by
}

"""
input type for inserting array relation for remote table "category"
"""
input category_arr_rel_insert_input {
  data: [category_insert_input!]!

  """upsert condition"""
  on_conflict: category_on_conflict
}

"""aggregate avg on columns"""
type category_avg_fields {
  id: Float
  parent_category_id: Float
}

"""
order by avg() on columns of table "category"
"""
input category_avg_order_by {
  id: order_by
  parent_category_id: order_by
}

"""
Boolean expression to filter rows from the table "category". All fields are combined with a logical 'AND'.
"""
input category_bool_exp {
  _and: [category_bool_exp!]
  _not: category_bool_exp
  _or: [category_bool_exp!]
  companies: company_category_bool_exp
  companies_aggregate: company_category_aggregate_bool_exp
  description: String_comparison_exp
  id: Int_comparison_exp
  image_url: String_comparison_exp
  name: String_comparison_exp
  parent_category: category_bool_exp
  parent_category_id: Int_comparison_exp
  products: product_category_bool_exp
  products_aggregate: product_category_aggregate_bool_exp
  slug: String_comparison_exp
  sub_categories: category_bool_exp
  sub_categories_aggregate: category_aggregate_bool_exp
  tenants: tenant_category_bool_exp
  tenants_aggregate: tenant_category_aggregate_bool_exp
}

"""
unique or primary key constraints on table "category"
"""
enum category_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  category_pkey
}

"""
input type for incrementing numeric columns in table "category"
"""
input category_inc_input {
  id: Int
  parent_category_id: Int
}

"""
input type for inserting data into table "category"
"""
input category_insert_input {
  companies: company_category_arr_rel_insert_input
  description: String
  id: Int
  image_url: String
  name: String
  parent_category: category_obj_rel_insert_input
  parent_category_id: Int
  products: product_category_arr_rel_insert_input
  slug: String
  sub_categories: category_arr_rel_insert_input
  tenants: tenant_category_arr_rel_insert_input
}

"""aggregate max on columns"""
type category_max_fields {
  description: String
  id: Int
  image_url: String
  name: String
  parent_category_id: Int
  slug: String
}

"""
order by max() on columns of table "category"
"""
input category_max_order_by {
  description: order_by
  id: order_by
  image_url: order_by
  name: order_by
  parent_category_id: order_by
  slug: order_by
}

"""aggregate min on columns"""
type category_min_fields {
  description: String
  id: Int
  image_url: String
  name: String
  parent_category_id: Int
  slug: String
}

"""
order by min() on columns of table "category"
"""
input category_min_order_by {
  description: order_by
  id: order_by
  image_url: order_by
  name: order_by
  parent_category_id: order_by
  slug: order_by
}

"""
response of any mutation on the table "category"
"""
type category_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [category!]!
}

"""
input type for inserting object relation for remote table "category"
"""
input category_obj_rel_insert_input {
  data: category_insert_input!

  """upsert condition"""
  on_conflict: category_on_conflict
}

"""
on_conflict condition type for table "category"
"""
input category_on_conflict {
  constraint: category_constraint!
  update_columns: [category_update_column!]! = []
  where: category_bool_exp
}

"""Ordering options when selecting data from "category"."""
input category_order_by {
  companies_aggregate: company_category_aggregate_order_by
  description: order_by
  id: order_by
  image_url: order_by
  name: order_by
  parent_category: category_order_by
  parent_category_id: order_by
  products_aggregate: product_category_aggregate_order_by
  slug: order_by
  sub_categories_aggregate: category_aggregate_order_by
  tenants_aggregate: tenant_category_aggregate_order_by
}

"""primary key columns input for table: category"""
input category_pk_columns_input {
  id: Int!
}

"""
select columns of table "category"
"""
enum category_select_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  image_url

  """column name"""
  name

  """column name"""
  parent_category_id

  """column name"""
  slug
}

"""
input type for updating data in table "category"
"""
input category_set_input {
  description: String
  id: Int
  image_url: String
  name: String
  parent_category_id: Int
  slug: String
}

"""aggregate stddev on columns"""
type category_stddev_fields {
  id: Float
  parent_category_id: Float
}

"""
order by stddev() on columns of table "category"
"""
input category_stddev_order_by {
  id: order_by
  parent_category_id: order_by
}

"""aggregate stddev_pop on columns"""
type category_stddev_pop_fields {
  id: Float
  parent_category_id: Float
}

"""
order by stddev_pop() on columns of table "category"
"""
input category_stddev_pop_order_by {
  id: order_by
  parent_category_id: order_by
}

"""aggregate stddev_samp on columns"""
type category_stddev_samp_fields {
  id: Float
  parent_category_id: Float
}

"""
order by stddev_samp() on columns of table "category"
"""
input category_stddev_samp_order_by {
  id: order_by
  parent_category_id: order_by
}

"""
Streaming cursor of the table "category"
"""
input category_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: category_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input category_stream_cursor_value_input {
  description: String
  id: Int
  image_url: String
  name: String
  parent_category_id: Int
  slug: String
}

"""aggregate sum on columns"""
type category_sum_fields {
  id: Int
  parent_category_id: Int
}

"""
order by sum() on columns of table "category"
"""
input category_sum_order_by {
  id: order_by
  parent_category_id: order_by
}

"""
update columns of table "category"
"""
enum category_update_column {
  """column name"""
  description

  """column name"""
  id

  """column name"""
  image_url

  """column name"""
  name

  """column name"""
  parent_category_id

  """column name"""
  slug
}

input category_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: category_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: category_set_input

  """filter the rows which have to be updated"""
  where: category_bool_exp!
}

"""aggregate var_pop on columns"""
type category_var_pop_fields {
  id: Float
  parent_category_id: Float
}

"""
order by var_pop() on columns of table "category"
"""
input category_var_pop_order_by {
  id: order_by
  parent_category_id: order_by
}

"""aggregate var_samp on columns"""
type category_var_samp_fields {
  id: Float
  parent_category_id: Float
}

"""
order by var_samp() on columns of table "category"
"""
input category_var_samp_order_by {
  id: order_by
  parent_category_id: order_by
}

"""aggregate variance on columns"""
type category_variance_fields {
  id: Float
  parent_category_id: Float
}

"""
order by variance() on columns of table "category"
"""
input category_variance_order_by {
  id: order_by
  parent_category_id: order_by
}

"""
columns and relationships of "chat_thread"
"""
type chat_thread {
  chat_no: bigint!
  created_at: timestamptz
  id: uuid!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!

  """An object relationship"""
  order_tenant: order_tenant!
  order_tenant_id: bigint!

  """An object relationship"""
  tenant: user!
  tenat_id: uuid!
  updated_at: timestamptz

  """An object relationship"""
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "chat_thread"
"""
type chat_thread_aggregate {
  aggregate: chat_thread_aggregate_fields
  nodes: [chat_thread!]!
}

input chat_thread_aggregate_bool_exp {
  count: chat_thread_aggregate_bool_exp_count
}

input chat_thread_aggregate_bool_exp_count {
  arguments: [chat_thread_select_column!]
  distinct: Boolean
  filter: chat_thread_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "chat_thread"
"""
type chat_thread_aggregate_fields {
  avg: chat_thread_avg_fields
  count(columns: [chat_thread_select_column!], distinct: Boolean): Int!
  max: chat_thread_max_fields
  min: chat_thread_min_fields
  stddev: chat_thread_stddev_fields
  stddev_pop: chat_thread_stddev_pop_fields
  stddev_samp: chat_thread_stddev_samp_fields
  sum: chat_thread_sum_fields
  var_pop: chat_thread_var_pop_fields
  var_samp: chat_thread_var_samp_fields
  variance: chat_thread_variance_fields
}

"""
order by aggregate values of table "chat_thread"
"""
input chat_thread_aggregate_order_by {
  avg: chat_thread_avg_order_by
  count: order_by
  max: chat_thread_max_order_by
  min: chat_thread_min_order_by
  stddev: chat_thread_stddev_order_by
  stddev_pop: chat_thread_stddev_pop_order_by
  stddev_samp: chat_thread_stddev_samp_order_by
  sum: chat_thread_sum_order_by
  var_pop: chat_thread_var_pop_order_by
  var_samp: chat_thread_var_samp_order_by
  variance: chat_thread_variance_order_by
}

"""
input type for inserting array relation for remote table "chat_thread"
"""
input chat_thread_arr_rel_insert_input {
  data: [chat_thread_insert_input!]!

  """upsert condition"""
  on_conflict: chat_thread_on_conflict
}

"""aggregate avg on columns"""
type chat_thread_avg_fields {
  chat_no: Float
  order_tenant_id: Float
}

"""
order by avg() on columns of table "chat_thread"
"""
input chat_thread_avg_order_by {
  chat_no: order_by
  order_tenant_id: order_by
}

"""
Boolean expression to filter rows from the table "chat_thread". All fields are combined with a logical 'AND'.
"""
input chat_thread_bool_exp {
  _and: [chat_thread_bool_exp!]
  _not: chat_thread_bool_exp
  _or: [chat_thread_bool_exp!]
  chat_no: bigint_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  messages: message_bool_exp
  messages_aggregate: message_aggregate_bool_exp
  order_tenant: order_tenant_bool_exp
  order_tenant_id: bigint_comparison_exp
  tenant: user_bool_exp
  tenat_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "chat_thread"
"""
enum chat_thread_constraint {
  """
  unique or primary key constraint on columns "chat_no"
  """
  chat_thread_chat_no_key

  """
  unique or primary key constraint on columns "order_tenant_id"
  """
  chat_thread_order_tenant_id_key

  """
  unique or primary key constraint on columns "id"
  """
  chat_thread_pkey
}

"""
input type for incrementing numeric columns in table "chat_thread"
"""
input chat_thread_inc_input {
  chat_no: bigint
  order_tenant_id: bigint
}

"""
input type for inserting data into table "chat_thread"
"""
input chat_thread_insert_input {
  chat_no: bigint
  created_at: timestamptz
  id: uuid
  messages: message_arr_rel_insert_input
  order_tenant: order_tenant_obj_rel_insert_input
  order_tenant_id: bigint
  tenant: user_obj_rel_insert_input
  tenat_id: uuid
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type chat_thread_max_fields {
  chat_no: bigint
  created_at: timestamptz
  id: uuid
  order_tenant_id: bigint
  tenat_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "chat_thread"
"""
input chat_thread_max_order_by {
  chat_no: order_by
  created_at: order_by
  id: order_by
  order_tenant_id: order_by
  tenat_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type chat_thread_min_fields {
  chat_no: bigint
  created_at: timestamptz
  id: uuid
  order_tenant_id: bigint
  tenat_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "chat_thread"
"""
input chat_thread_min_order_by {
  chat_no: order_by
  created_at: order_by
  id: order_by
  order_tenant_id: order_by
  tenat_id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "chat_thread"
"""
type chat_thread_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [chat_thread!]!
}

"""
input type for inserting object relation for remote table "chat_thread"
"""
input chat_thread_obj_rel_insert_input {
  data: chat_thread_insert_input!

  """upsert condition"""
  on_conflict: chat_thread_on_conflict
}

"""
on_conflict condition type for table "chat_thread"
"""
input chat_thread_on_conflict {
  constraint: chat_thread_constraint!
  update_columns: [chat_thread_update_column!]! = []
  where: chat_thread_bool_exp
}

"""Ordering options when selecting data from "chat_thread"."""
input chat_thread_order_by {
  chat_no: order_by
  created_at: order_by
  id: order_by
  messages_aggregate: message_aggregate_order_by
  order_tenant: order_tenant_order_by
  order_tenant_id: order_by
  tenant: user_order_by
  tenat_id: order_by
  updated_at: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: chat_thread"""
input chat_thread_pk_columns_input {
  id: uuid!
}

"""
select columns of table "chat_thread"
"""
enum chat_thread_select_column {
  """column name"""
  chat_no

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  order_tenant_id

  """column name"""
  tenat_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "chat_thread"
"""
input chat_thread_set_input {
  chat_no: bigint
  created_at: timestamptz
  id: uuid
  order_tenant_id: bigint
  tenat_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate stddev on columns"""
type chat_thread_stddev_fields {
  chat_no: Float
  order_tenant_id: Float
}

"""
order by stddev() on columns of table "chat_thread"
"""
input chat_thread_stddev_order_by {
  chat_no: order_by
  order_tenant_id: order_by
}

"""aggregate stddev_pop on columns"""
type chat_thread_stddev_pop_fields {
  chat_no: Float
  order_tenant_id: Float
}

"""
order by stddev_pop() on columns of table "chat_thread"
"""
input chat_thread_stddev_pop_order_by {
  chat_no: order_by
  order_tenant_id: order_by
}

"""aggregate stddev_samp on columns"""
type chat_thread_stddev_samp_fields {
  chat_no: Float
  order_tenant_id: Float
}

"""
order by stddev_samp() on columns of table "chat_thread"
"""
input chat_thread_stddev_samp_order_by {
  chat_no: order_by
  order_tenant_id: order_by
}

"""
Streaming cursor of the table "chat_thread"
"""
input chat_thread_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: chat_thread_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input chat_thread_stream_cursor_value_input {
  chat_no: bigint
  created_at: timestamptz
  id: uuid
  order_tenant_id: bigint
  tenat_id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate sum on columns"""
type chat_thread_sum_fields {
  chat_no: bigint
  order_tenant_id: bigint
}

"""
order by sum() on columns of table "chat_thread"
"""
input chat_thread_sum_order_by {
  chat_no: order_by
  order_tenant_id: order_by
}

"""
update columns of table "chat_thread"
"""
enum chat_thread_update_column {
  """column name"""
  chat_no

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  order_tenant_id

  """column name"""
  tenat_id

  """column name"""
  updated_at

  """column name"""
  user_id
}

input chat_thread_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: chat_thread_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: chat_thread_set_input

  """filter the rows which have to be updated"""
  where: chat_thread_bool_exp!
}

"""aggregate var_pop on columns"""
type chat_thread_var_pop_fields {
  chat_no: Float
  order_tenant_id: Float
}

"""
order by var_pop() on columns of table "chat_thread"
"""
input chat_thread_var_pop_order_by {
  chat_no: order_by
  order_tenant_id: order_by
}

"""aggregate var_samp on columns"""
type chat_thread_var_samp_fields {
  chat_no: Float
  order_tenant_id: Float
}

"""
order by var_samp() on columns of table "chat_thread"
"""
input chat_thread_var_samp_order_by {
  chat_no: order_by
  order_tenant_id: order_by
}

"""aggregate variance on columns"""
type chat_thread_variance_fields {
  chat_no: Float
  order_tenant_id: Float
}

"""
order by variance() on columns of table "chat_thread"
"""
input chat_thread_variance_order_by {
  chat_no: order_by
  order_tenant_id: order_by
}

"""
columns and relationships of "city"
"""
type city {
  code: Int!

  """An array relationship"""
  districts(
    """distinct select on columns"""
    distinct_on: [district_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [district_order_by!]

    """filter the rows returned"""
    where: district_bool_exp
  ): [district!]!

  """An aggregate relationship"""
  districts_aggregate(
    """distinct select on columns"""
    distinct_on: [district_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [district_order_by!]

    """filter the rows returned"""
    where: district_bool_exp
  ): district_aggregate!
  id: Int!
  is_active: Boolean
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String!

  """An array relationship"""
  order_addresses(
    """distinct select on columns"""
    distinct_on: [order_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_address_order_by!]

    """filter the rows returned"""
    where: order_address_bool_exp
  ): [order_address!]!

  """An aggregate relationship"""
  order_addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [order_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_address_order_by!]

    """filter the rows returned"""
    where: order_address_bool_exp
  ): order_address_aggregate!
  parent_id: Int

  """An array relationship"""
  user_addresses(
    """distinct select on columns"""
    distinct_on: [user_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_address_order_by!]

    """filter the rows returned"""
    where: user_address_bool_exp
  ): [user_address!]!

  """An aggregate relationship"""
  user_addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [user_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_address_order_by!]

    """filter the rows returned"""
    where: user_address_bool_exp
  ): user_address_aggregate!
}

"""
aggregated selection of "city"
"""
type city_aggregate {
  aggregate: city_aggregate_fields
  nodes: [city!]!
}

"""
aggregate fields of "city"
"""
type city_aggregate_fields {
  avg: city_avg_fields
  count(columns: [city_select_column!], distinct: Boolean): Int!
  max: city_max_fields
  min: city_min_fields
  stddev: city_stddev_fields
  stddev_pop: city_stddev_pop_fields
  stddev_samp: city_stddev_samp_fields
  sum: city_sum_fields
  var_pop: city_var_pop_fields
  var_samp: city_var_samp_fields
  variance: city_variance_fields
}

"""aggregate avg on columns"""
type city_avg_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
Boolean expression to filter rows from the table "city". All fields are combined with a logical 'AND'.
"""
input city_bool_exp {
  _and: [city_bool_exp!]
  _not: city_bool_exp
  _or: [city_bool_exp!]
  code: Int_comparison_exp
  districts: district_bool_exp
  districts_aggregate: district_aggregate_bool_exp
  id: Int_comparison_exp
  is_active: Boolean_comparison_exp
  maxlatitude: String_comparison_exp
  maxlongitude: String_comparison_exp
  minlatitude: String_comparison_exp
  minlongitude: String_comparison_exp
  name: String_comparison_exp
  order_addresses: order_address_bool_exp
  order_addresses_aggregate: order_address_aggregate_bool_exp
  parent_id: Int_comparison_exp
  user_addresses: user_address_bool_exp
  user_addresses_aggregate: user_address_aggregate_bool_exp
}

"""
unique or primary key constraints on table "city"
"""
enum city_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  city_code_key

  """
  unique or primary key constraint on columns "name"
  """
  city_name_key

  """
  unique or primary key constraint on columns "id"
  """
  city_pkey
}

"""
input type for incrementing numeric columns in table "city"
"""
input city_inc_input {
  code: Int
  id: Int
  parent_id: Int
}

"""
input type for inserting data into table "city"
"""
input city_insert_input {
  code: Int
  districts: district_arr_rel_insert_input
  id: Int
  is_active: Boolean
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String
  order_addresses: order_address_arr_rel_insert_input
  parent_id: Int
  user_addresses: user_address_arr_rel_insert_input
}

"""aggregate max on columns"""
type city_max_fields {
  code: Int
  id: Int
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String
  parent_id: Int
}

"""aggregate min on columns"""
type city_min_fields {
  code: Int
  id: Int
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String
  parent_id: Int
}

"""
response of any mutation on the table "city"
"""
type city_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [city!]!
}

"""
input type for inserting object relation for remote table "city"
"""
input city_obj_rel_insert_input {
  data: city_insert_input!

  """upsert condition"""
  on_conflict: city_on_conflict
}

"""
on_conflict condition type for table "city"
"""
input city_on_conflict {
  constraint: city_constraint!
  update_columns: [city_update_column!]! = []
  where: city_bool_exp
}

"""Ordering options when selecting data from "city"."""
input city_order_by {
  code: order_by
  districts_aggregate: district_aggregate_order_by
  id: order_by
  is_active: order_by
  maxlatitude: order_by
  maxlongitude: order_by
  minlatitude: order_by
  minlongitude: order_by
  name: order_by
  order_addresses_aggregate: order_address_aggregate_order_by
  parent_id: order_by
  user_addresses_aggregate: user_address_aggregate_order_by
}

"""primary key columns input for table: city"""
input city_pk_columns_input {
  id: Int!
}

"""
select columns of table "city"
"""
enum city_select_column {
  """column name"""
  code

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  maxlatitude

  """column name"""
  maxlongitude

  """column name"""
  minlatitude

  """column name"""
  minlongitude

  """column name"""
  name

  """column name"""
  parent_id
}

"""
input type for updating data in table "city"
"""
input city_set_input {
  code: Int
  id: Int
  is_active: Boolean
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String
  parent_id: Int
}

"""aggregate stddev on columns"""
type city_stddev_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""aggregate stddev_pop on columns"""
type city_stddev_pop_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""aggregate stddev_samp on columns"""
type city_stddev_samp_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
Streaming cursor of the table "city"
"""
input city_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: city_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input city_stream_cursor_value_input {
  code: Int
  id: Int
  is_active: Boolean
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String
  parent_id: Int
}

"""aggregate sum on columns"""
type city_sum_fields {
  code: Int
  id: Int
  parent_id: Int
}

"""
update columns of table "city"
"""
enum city_update_column {
  """column name"""
  code

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  maxlatitude

  """column name"""
  maxlongitude

  """column name"""
  minlatitude

  """column name"""
  minlongitude

  """column name"""
  name

  """column name"""
  parent_id
}

input city_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: city_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: city_set_input

  """filter the rows which have to be updated"""
  where: city_bool_exp!
}

"""aggregate var_pop on columns"""
type city_var_pop_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""aggregate var_samp on columns"""
type city_var_samp_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""aggregate variance on columns"""
type city_variance_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
columns and relationships of "company"
"""
type company {
  address: String!

  """An array relationship"""
  categories(
    """distinct select on columns"""
    distinct_on: [company_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_category_order_by!]

    """filter the rows returned"""
    where: company_category_bool_exp
  ): [company_category!]!

  """An aggregate relationship"""
  categories_aggregate(
    """distinct select on columns"""
    distinct_on: [company_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_category_order_by!]

    """filter the rows returned"""
    where: company_category_bool_exp
  ): company_category_aggregate!
  company_type: String!
  created_at: timestamptz!
  email: String
  id: uuid!
  is_active: Boolean
  is_deleted: Boolean
  logo_url: String
  name: String!
  phone: String

  """An object relationship"""
  tenant: user!
  tenant_id: uuid!
  updated_at: timestamptz!
  vkn_no: String!
}

"""
aggregated selection of "company"
"""
type company_aggregate {
  aggregate: company_aggregate_fields
  nodes: [company!]!
}

input company_aggregate_bool_exp {
  bool_and: company_aggregate_bool_exp_bool_and
  bool_or: company_aggregate_bool_exp_bool_or
  count: company_aggregate_bool_exp_count
}

input company_aggregate_bool_exp_bool_and {
  arguments: company_select_column_company_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: company_bool_exp
  predicate: Boolean_comparison_exp!
}

input company_aggregate_bool_exp_bool_or {
  arguments: company_select_column_company_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: company_bool_exp
  predicate: Boolean_comparison_exp!
}

input company_aggregate_bool_exp_count {
  arguments: [company_select_column!]
  distinct: Boolean
  filter: company_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "company"
"""
type company_aggregate_fields {
  count(columns: [company_select_column!], distinct: Boolean): Int!
  max: company_max_fields
  min: company_min_fields
}

"""
order by aggregate values of table "company"
"""
input company_aggregate_order_by {
  count: order_by
  max: company_max_order_by
  min: company_min_order_by
}

"""
input type for inserting array relation for remote table "company"
"""
input company_arr_rel_insert_input {
  data: [company_insert_input!]!

  """upsert condition"""
  on_conflict: company_on_conflict
}

"""
Boolean expression to filter rows from the table "company". All fields are combined with a logical 'AND'.
"""
input company_bool_exp {
  _and: [company_bool_exp!]
  _not: company_bool_exp
  _or: [company_bool_exp!]
  address: String_comparison_exp
  categories: company_category_bool_exp
  categories_aggregate: company_category_aggregate_bool_exp
  company_type: String_comparison_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  is_deleted: Boolean_comparison_exp
  logo_url: String_comparison_exp
  name: String_comparison_exp
  phone: String_comparison_exp
  tenant: user_bool_exp
  tenant_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  vkn_no: String_comparison_exp
}

"""
columns and relationships of "company_category"
"""
type company_category {
  """An object relationship"""
  category: category!
  category_id: Int!

  """An object relationship"""
  company: company!
  company_id: uuid!
  id: Int!
}

"""
aggregated selection of "company_category"
"""
type company_category_aggregate {
  aggregate: company_category_aggregate_fields
  nodes: [company_category!]!
}

input company_category_aggregate_bool_exp {
  count: company_category_aggregate_bool_exp_count
}

input company_category_aggregate_bool_exp_count {
  arguments: [company_category_select_column!]
  distinct: Boolean
  filter: company_category_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "company_category"
"""
type company_category_aggregate_fields {
  avg: company_category_avg_fields
  count(columns: [company_category_select_column!], distinct: Boolean): Int!
  max: company_category_max_fields
  min: company_category_min_fields
  stddev: company_category_stddev_fields
  stddev_pop: company_category_stddev_pop_fields
  stddev_samp: company_category_stddev_samp_fields
  sum: company_category_sum_fields
  var_pop: company_category_var_pop_fields
  var_samp: company_category_var_samp_fields
  variance: company_category_variance_fields
}

"""
order by aggregate values of table "company_category"
"""
input company_category_aggregate_order_by {
  avg: company_category_avg_order_by
  count: order_by
  max: company_category_max_order_by
  min: company_category_min_order_by
  stddev: company_category_stddev_order_by
  stddev_pop: company_category_stddev_pop_order_by
  stddev_samp: company_category_stddev_samp_order_by
  sum: company_category_sum_order_by
  var_pop: company_category_var_pop_order_by
  var_samp: company_category_var_samp_order_by
  variance: company_category_variance_order_by
}

"""
input type for inserting array relation for remote table "company_category"
"""
input company_category_arr_rel_insert_input {
  data: [company_category_insert_input!]!

  """upsert condition"""
  on_conflict: company_category_on_conflict
}

"""aggregate avg on columns"""
type company_category_avg_fields {
  category_id: Float
  id: Float
}

"""
order by avg() on columns of table "company_category"
"""
input company_category_avg_order_by {
  category_id: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "company_category". All fields are combined with a logical 'AND'.
"""
input company_category_bool_exp {
  _and: [company_category_bool_exp!]
  _not: company_category_bool_exp
  _or: [company_category_bool_exp!]
  category: category_bool_exp
  category_id: Int_comparison_exp
  company: company_bool_exp
  company_id: uuid_comparison_exp
  id: Int_comparison_exp
}

"""
unique or primary key constraints on table "company_category"
"""
enum company_category_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  company_category_pkey
}

"""
input type for incrementing numeric columns in table "company_category"
"""
input company_category_inc_input {
  category_id: Int
  id: Int
}

"""
input type for inserting data into table "company_category"
"""
input company_category_insert_input {
  category: category_obj_rel_insert_input
  category_id: Int
  company: company_obj_rel_insert_input
  company_id: uuid
  id: Int
}

"""aggregate max on columns"""
type company_category_max_fields {
  category_id: Int
  company_id: uuid
  id: Int
}

"""
order by max() on columns of table "company_category"
"""
input company_category_max_order_by {
  category_id: order_by
  company_id: order_by
  id: order_by
}

"""aggregate min on columns"""
type company_category_min_fields {
  category_id: Int
  company_id: uuid
  id: Int
}

"""
order by min() on columns of table "company_category"
"""
input company_category_min_order_by {
  category_id: order_by
  company_id: order_by
  id: order_by
}

"""
response of any mutation on the table "company_category"
"""
type company_category_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [company_category!]!
}

"""
on_conflict condition type for table "company_category"
"""
input company_category_on_conflict {
  constraint: company_category_constraint!
  update_columns: [company_category_update_column!]! = []
  where: company_category_bool_exp
}

"""Ordering options when selecting data from "company_category"."""
input company_category_order_by {
  category: category_order_by
  category_id: order_by
  company: company_order_by
  company_id: order_by
  id: order_by
}

"""primary key columns input for table: company_category"""
input company_category_pk_columns_input {
  id: Int!
}

"""
select columns of table "company_category"
"""
enum company_category_select_column {
  """column name"""
  category_id

  """column name"""
  company_id

  """column name"""
  id
}

"""
input type for updating data in table "company_category"
"""
input company_category_set_input {
  category_id: Int
  company_id: uuid
  id: Int
}

"""aggregate stddev on columns"""
type company_category_stddev_fields {
  category_id: Float
  id: Float
}

"""
order by stddev() on columns of table "company_category"
"""
input company_category_stddev_order_by {
  category_id: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type company_category_stddev_pop_fields {
  category_id: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "company_category"
"""
input company_category_stddev_pop_order_by {
  category_id: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type company_category_stddev_samp_fields {
  category_id: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "company_category"
"""
input company_category_stddev_samp_order_by {
  category_id: order_by
  id: order_by
}

"""
Streaming cursor of the table "company_category"
"""
input company_category_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: company_category_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input company_category_stream_cursor_value_input {
  category_id: Int
  company_id: uuid
  id: Int
}

"""aggregate sum on columns"""
type company_category_sum_fields {
  category_id: Int
  id: Int
}

"""
order by sum() on columns of table "company_category"
"""
input company_category_sum_order_by {
  category_id: order_by
  id: order_by
}

"""
update columns of table "company_category"
"""
enum company_category_update_column {
  """column name"""
  category_id

  """column name"""
  company_id

  """column name"""
  id
}

input company_category_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: company_category_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: company_category_set_input

  """filter the rows which have to be updated"""
  where: company_category_bool_exp!
}

"""aggregate var_pop on columns"""
type company_category_var_pop_fields {
  category_id: Float
  id: Float
}

"""
order by var_pop() on columns of table "company_category"
"""
input company_category_var_pop_order_by {
  category_id: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type company_category_var_samp_fields {
  category_id: Float
  id: Float
}

"""
order by var_samp() on columns of table "company_category"
"""
input company_category_var_samp_order_by {
  category_id: order_by
  id: order_by
}

"""aggregate variance on columns"""
type company_category_variance_fields {
  category_id: Float
  id: Float
}

"""
order by variance() on columns of table "company_category"
"""
input company_category_variance_order_by {
  category_id: order_by
  id: order_by
}

"""
unique or primary key constraints on table "company"
"""
enum company_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  company_pkey
}

"""
input type for inserting data into table "company"
"""
input company_insert_input {
  address: String
  categories: company_category_arr_rel_insert_input
  company_type: String
  created_at: timestamptz
  email: String
  id: uuid
  is_active: Boolean
  is_deleted: Boolean
  logo_url: String
  name: String
  phone: String
  tenant: user_obj_rel_insert_input
  tenant_id: uuid
  updated_at: timestamptz
  vkn_no: String
}

"""aggregate max on columns"""
type company_max_fields {
  address: String
  company_type: String
  created_at: timestamptz
  email: String
  id: uuid
  logo_url: String
  name: String
  phone: String
  tenant_id: uuid
  updated_at: timestamptz
  vkn_no: String
}

"""
order by max() on columns of table "company"
"""
input company_max_order_by {
  address: order_by
  company_type: order_by
  created_at: order_by
  email: order_by
  id: order_by
  logo_url: order_by
  name: order_by
  phone: order_by
  tenant_id: order_by
  updated_at: order_by
  vkn_no: order_by
}

"""aggregate min on columns"""
type company_min_fields {
  address: String
  company_type: String
  created_at: timestamptz
  email: String
  id: uuid
  logo_url: String
  name: String
  phone: String
  tenant_id: uuid
  updated_at: timestamptz
  vkn_no: String
}

"""
order by min() on columns of table "company"
"""
input company_min_order_by {
  address: order_by
  company_type: order_by
  created_at: order_by
  email: order_by
  id: order_by
  logo_url: order_by
  name: order_by
  phone: order_by
  tenant_id: order_by
  updated_at: order_by
  vkn_no: order_by
}

"""
response of any mutation on the table "company"
"""
type company_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [company!]!
}

"""
input type for inserting object relation for remote table "company"
"""
input company_obj_rel_insert_input {
  data: company_insert_input!

  """upsert condition"""
  on_conflict: company_on_conflict
}

"""
on_conflict condition type for table "company"
"""
input company_on_conflict {
  constraint: company_constraint!
  update_columns: [company_update_column!]! = []
  where: company_bool_exp
}

"""Ordering options when selecting data from "company"."""
input company_order_by {
  address: order_by
  categories_aggregate: company_category_aggregate_order_by
  company_type: order_by
  created_at: order_by
  email: order_by
  id: order_by
  is_active: order_by
  is_deleted: order_by
  logo_url: order_by
  name: order_by
  phone: order_by
  tenant: user_order_by
  tenant_id: order_by
  updated_at: order_by
  vkn_no: order_by
}

"""primary key columns input for table: company"""
input company_pk_columns_input {
  id: uuid!
}

"""
select columns of table "company"
"""
enum company_select_column {
  """column name"""
  address

  """column name"""
  company_type

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  is_deleted

  """column name"""
  logo_url

  """column name"""
  name

  """column name"""
  phone

  """column name"""
  tenant_id

  """column name"""
  updated_at

  """column name"""
  vkn_no
}

"""
select "company_aggregate_bool_exp_bool_and_arguments_columns" columns of table "company"
"""
enum company_select_column_company_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_active

  """column name"""
  is_deleted
}

"""
select "company_aggregate_bool_exp_bool_or_arguments_columns" columns of table "company"
"""
enum company_select_column_company_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_active

  """column name"""
  is_deleted
}

"""
input type for updating data in table "company"
"""
input company_set_input {
  address: String
  company_type: String
  created_at: timestamptz
  email: String
  id: uuid
  is_active: Boolean
  is_deleted: Boolean
  logo_url: String
  name: String
  phone: String
  tenant_id: uuid
  updated_at: timestamptz
  vkn_no: String
}

"""
Streaming cursor of the table "company"
"""
input company_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: company_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input company_stream_cursor_value_input {
  address: String
  company_type: String
  created_at: timestamptz
  email: String
  id: uuid
  is_active: Boolean
  is_deleted: Boolean
  logo_url: String
  name: String
  phone: String
  tenant_id: uuid
  updated_at: timestamptz
  vkn_no: String
}

"""
columns and relationships of "company_type"
"""
type company_type {
  comment: String
  value: String!
}

"""
aggregated selection of "company_type"
"""
type company_type_aggregate {
  aggregate: company_type_aggregate_fields
  nodes: [company_type!]!
}

"""
aggregate fields of "company_type"
"""
type company_type_aggregate_fields {
  count(columns: [company_type_select_column!], distinct: Boolean): Int!
  max: company_type_max_fields
  min: company_type_min_fields
}

"""
Boolean expression to filter rows from the table "company_type". All fields are combined with a logical 'AND'.
"""
input company_type_bool_exp {
  _and: [company_type_bool_exp!]
  _not: company_type_bool_exp
  _or: [company_type_bool_exp!]
  comment: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "company_type"
"""
enum company_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  company_type_pkey
}

enum company_type_enum {
  individual
  limited
}

"""
Boolean expression to compare columns of type "company_type_enum". All fields are combined with logical 'AND'.
"""
input company_type_enum_comparison_exp {
  _eq: company_type_enum
  _in: [company_type_enum!]
  _is_null: Boolean
  _neq: company_type_enum
  _nin: [company_type_enum!]
}

"""
input type for inserting data into table "company_type"
"""
input company_type_insert_input {
  comment: String
  value: String
}

"""aggregate max on columns"""
type company_type_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type company_type_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "company_type"
"""
type company_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [company_type!]!
}

"""
input type for inserting object relation for remote table "company_type"
"""
input company_type_obj_rel_insert_input {
  data: company_type_insert_input!

  """upsert condition"""
  on_conflict: company_type_on_conflict
}

"""
on_conflict condition type for table "company_type"
"""
input company_type_on_conflict {
  constraint: company_type_constraint!
  update_columns: [company_type_update_column!]! = []
  where: company_type_bool_exp
}

"""Ordering options when selecting data from "company_type"."""
input company_type_order_by {
  comment: order_by
  value: order_by
}

"""primary key columns input for table: company_type"""
input company_type_pk_columns_input {
  value: String!
}

"""
select columns of table "company_type"
"""
enum company_type_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "company_type"
"""
input company_type_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "company_type"
"""
input company_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: company_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input company_type_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "company_type"
"""
enum company_type_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input company_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: company_type_set_input

  """filter the rows which have to be updated"""
  where: company_type_bool_exp!
}

"""
update columns of table "company"
"""
enum company_update_column {
  """column name"""
  address

  """column name"""
  company_type

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  is_deleted

  """column name"""
  logo_url

  """column name"""
  name

  """column name"""
  phone

  """column name"""
  tenant_id

  """column name"""
  updated_at

  """column name"""
  vkn_no
}

input company_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: company_set_input

  """filter the rows which have to be updated"""
  where: company_bool_exp!
}

"""
columns and relationships of "coupon"
"""
type coupon {
  amount: numeric!
  code: String!
  created_at: timestamptz
  description: String
  end_date: date
  id: uuid!
  is_public: Boolean
  left_limit: Int
  limit: Int!
  minimum_cost: numeric
  start_date: date

  """An object relationship"""
  tenant: user!
  tenant_id: uuid!
  updated_at: timestamptz

  """An array relationship"""
  user_coupons(
    """distinct select on columns"""
    distinct_on: [user_coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_coupon_order_by!]

    """filter the rows returned"""
    where: user_coupon_bool_exp
  ): [user_coupon!]!

  """An aggregate relationship"""
  user_coupons_aggregate(
    """distinct select on columns"""
    distinct_on: [user_coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_coupon_order_by!]

    """filter the rows returned"""
    where: user_coupon_bool_exp
  ): user_coupon_aggregate!
}

"""
aggregated selection of "coupon"
"""
type coupon_aggregate {
  aggregate: coupon_aggregate_fields
  nodes: [coupon!]!
}

"""
aggregate fields of "coupon"
"""
type coupon_aggregate_fields {
  avg: coupon_avg_fields
  count(columns: [coupon_select_column!], distinct: Boolean): Int!
  max: coupon_max_fields
  min: coupon_min_fields
  stddev: coupon_stddev_fields
  stddev_pop: coupon_stddev_pop_fields
  stddev_samp: coupon_stddev_samp_fields
  sum: coupon_sum_fields
  var_pop: coupon_var_pop_fields
  var_samp: coupon_var_samp_fields
  variance: coupon_variance_fields
}

"""aggregate avg on columns"""
type coupon_avg_fields {
  amount: Float
  left_limit: Float
  limit: Float
  minimum_cost: Float
}

"""
Boolean expression to filter rows from the table "coupon". All fields are combined with a logical 'AND'.
"""
input coupon_bool_exp {
  _and: [coupon_bool_exp!]
  _not: coupon_bool_exp
  _or: [coupon_bool_exp!]
  amount: numeric_comparison_exp
  code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  end_date: date_comparison_exp
  id: uuid_comparison_exp
  is_public: Boolean_comparison_exp
  left_limit: Int_comparison_exp
  limit: Int_comparison_exp
  minimum_cost: numeric_comparison_exp
  start_date: date_comparison_exp
  tenant: user_bool_exp
  tenant_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_coupons: user_coupon_bool_exp
  user_coupons_aggregate: user_coupon_aggregate_bool_exp
}

"""
unique or primary key constraints on table "coupon"
"""
enum coupon_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  coupon_code_key

  """
  unique or primary key constraint on columns "id"
  """
  coupon_pkey
}

"""
input type for incrementing numeric columns in table "coupon"
"""
input coupon_inc_input {
  amount: numeric
  left_limit: Int
  limit: Int
  minimum_cost: numeric
}

"""
input type for inserting data into table "coupon"
"""
input coupon_insert_input {
  amount: numeric
  code: String
  created_at: timestamptz
  description: String
  end_date: date
  id: uuid
  is_public: Boolean
  left_limit: Int
  limit: Int
  minimum_cost: numeric
  start_date: date
  tenant: user_obj_rel_insert_input
  tenant_id: uuid
  updated_at: timestamptz
  user_coupons: user_coupon_arr_rel_insert_input
}

"""aggregate max on columns"""
type coupon_max_fields {
  amount: numeric
  code: String
  created_at: timestamptz
  description: String
  end_date: date
  id: uuid
  left_limit: Int
  limit: Int
  minimum_cost: numeric
  start_date: date
  tenant_id: uuid
  updated_at: timestamptz
}

"""aggregate min on columns"""
type coupon_min_fields {
  amount: numeric
  code: String
  created_at: timestamptz
  description: String
  end_date: date
  id: uuid
  left_limit: Int
  limit: Int
  minimum_cost: numeric
  start_date: date
  tenant_id: uuid
  updated_at: timestamptz
}

"""
response of any mutation on the table "coupon"
"""
type coupon_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [coupon!]!
}

"""
input type for inserting object relation for remote table "coupon"
"""
input coupon_obj_rel_insert_input {
  data: coupon_insert_input!

  """upsert condition"""
  on_conflict: coupon_on_conflict
}

"""
on_conflict condition type for table "coupon"
"""
input coupon_on_conflict {
  constraint: coupon_constraint!
  update_columns: [coupon_update_column!]! = []
  where: coupon_bool_exp
}

"""Ordering options when selecting data from "coupon"."""
input coupon_order_by {
  amount: order_by
  code: order_by
  created_at: order_by
  description: order_by
  end_date: order_by
  id: order_by
  is_public: order_by
  left_limit: order_by
  limit: order_by
  minimum_cost: order_by
  start_date: order_by
  tenant: user_order_by
  tenant_id: order_by
  updated_at: order_by
  user_coupons_aggregate: user_coupon_aggregate_order_by
}

"""primary key columns input for table: coupon"""
input coupon_pk_columns_input {
  id: uuid!
}

"""
select columns of table "coupon"
"""
enum coupon_select_column {
  """column name"""
  amount

  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  is_public

  """column name"""
  left_limit

  """column name"""
  limit

  """column name"""
  minimum_cost

  """column name"""
  start_date

  """column name"""
  tenant_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "coupon"
"""
input coupon_set_input {
  amount: numeric
  code: String
  created_at: timestamptz
  description: String
  end_date: date
  id: uuid
  is_public: Boolean
  left_limit: Int
  limit: Int
  minimum_cost: numeric
  start_date: date
  tenant_id: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type coupon_stddev_fields {
  amount: Float
  left_limit: Float
  limit: Float
  minimum_cost: Float
}

"""aggregate stddev_pop on columns"""
type coupon_stddev_pop_fields {
  amount: Float
  left_limit: Float
  limit: Float
  minimum_cost: Float
}

"""aggregate stddev_samp on columns"""
type coupon_stddev_samp_fields {
  amount: Float
  left_limit: Float
  limit: Float
  minimum_cost: Float
}

"""
Streaming cursor of the table "coupon"
"""
input coupon_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: coupon_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input coupon_stream_cursor_value_input {
  amount: numeric
  code: String
  created_at: timestamptz
  description: String
  end_date: date
  id: uuid
  is_public: Boolean
  left_limit: Int
  limit: Int
  minimum_cost: numeric
  start_date: date
  tenant_id: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type coupon_sum_fields {
  amount: numeric
  left_limit: Int
  limit: Int
  minimum_cost: numeric
}

"""
update columns of table "coupon"
"""
enum coupon_update_column {
  """column name"""
  amount

  """column name"""
  code

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  is_public

  """column name"""
  left_limit

  """column name"""
  limit

  """column name"""
  minimum_cost

  """column name"""
  start_date

  """column name"""
  tenant_id

  """column name"""
  updated_at
}

input coupon_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: coupon_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: coupon_set_input

  """filter the rows which have to be updated"""
  where: coupon_bool_exp!
}

"""aggregate var_pop on columns"""
type coupon_var_pop_fields {
  amount: Float
  left_limit: Float
  limit: Float
  minimum_cost: Float
}

"""aggregate var_samp on columns"""
type coupon_var_samp_fields {
  amount: Float
  left_limit: Float
  limit: Float
  minimum_cost: Float
}

"""aggregate variance on columns"""
type coupon_variance_fields {
  amount: Float
  left_limit: Float
  limit: Float
  minimum_cost: Float
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""özel yazı yada fotograf"""
type customizable_area {
  id: Int!
  type: String!
}

"""
aggregated selection of "customizable_area"
"""
type customizable_area_aggregate {
  aggregate: customizable_area_aggregate_fields
  nodes: [customizable_area!]!
}

"""
aggregate fields of "customizable_area"
"""
type customizable_area_aggregate_fields {
  avg: customizable_area_avg_fields
  count(columns: [customizable_area_select_column!], distinct: Boolean): Int!
  max: customizable_area_max_fields
  min: customizable_area_min_fields
  stddev: customizable_area_stddev_fields
  stddev_pop: customizable_area_stddev_pop_fields
  stddev_samp: customizable_area_stddev_samp_fields
  sum: customizable_area_sum_fields
  var_pop: customizable_area_var_pop_fields
  var_samp: customizable_area_var_samp_fields
  variance: customizable_area_variance_fields
}

"""aggregate avg on columns"""
type customizable_area_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "customizable_area". All fields are combined with a logical 'AND'.
"""
input customizable_area_bool_exp {
  _and: [customizable_area_bool_exp!]
  _not: customizable_area_bool_exp
  _or: [customizable_area_bool_exp!]
  id: Int_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "customizable_area"
"""
enum customizable_area_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  customizable_area_pkey
}

"""
input type for incrementing numeric columns in table "customizable_area"
"""
input customizable_area_inc_input {
  id: Int
}

"""
input type for inserting data into table "customizable_area"
"""
input customizable_area_insert_input {
  id: Int
  type: String
}

"""aggregate max on columns"""
type customizable_area_max_fields {
  id: Int
  type: String
}

"""aggregate min on columns"""
type customizable_area_min_fields {
  id: Int
  type: String
}

"""
response of any mutation on the table "customizable_area"
"""
type customizable_area_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [customizable_area!]!
}

"""
input type for inserting object relation for remote table "customizable_area"
"""
input customizable_area_obj_rel_insert_input {
  data: customizable_area_insert_input!

  """upsert condition"""
  on_conflict: customizable_area_on_conflict
}

"""
on_conflict condition type for table "customizable_area"
"""
input customizable_area_on_conflict {
  constraint: customizable_area_constraint!
  update_columns: [customizable_area_update_column!]! = []
  where: customizable_area_bool_exp
}

"""Ordering options when selecting data from "customizable_area"."""
input customizable_area_order_by {
  id: order_by
  type: order_by
}

"""primary key columns input for table: customizable_area"""
input customizable_area_pk_columns_input {
  id: Int!
}

"""
select columns of table "customizable_area"
"""
enum customizable_area_select_column {
  """column name"""
  id

  """column name"""
  type
}

"""
input type for updating data in table "customizable_area"
"""
input customizable_area_set_input {
  id: Int
  type: String
}

"""aggregate stddev on columns"""
type customizable_area_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type customizable_area_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type customizable_area_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "customizable_area"
"""
input customizable_area_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: customizable_area_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input customizable_area_stream_cursor_value_input {
  id: Int
  type: String
}

"""aggregate sum on columns"""
type customizable_area_sum_fields {
  id: Int
}

"""
update columns of table "customizable_area"
"""
enum customizable_area_update_column {
  """column name"""
  id

  """column name"""
  type
}

input customizable_area_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: customizable_area_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: customizable_area_set_input

  """filter the rows which have to be updated"""
  where: customizable_area_bool_exp!
}

"""aggregate var_pop on columns"""
type customizable_area_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type customizable_area_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type customizable_area_variance_fields {
  id: Float
}

scalar date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
columns and relationships of "delivery_type"
"""
type delivery_type {
  comment: String

  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!
  value: String!
}

"""
aggregated selection of "delivery_type"
"""
type delivery_type_aggregate {
  aggregate: delivery_type_aggregate_fields
  nodes: [delivery_type!]!
}

"""
aggregate fields of "delivery_type"
"""
type delivery_type_aggregate_fields {
  count(columns: [delivery_type_select_column!], distinct: Boolean): Int!
  max: delivery_type_max_fields
  min: delivery_type_min_fields
}

"""
Boolean expression to filter rows from the table "delivery_type". All fields are combined with a logical 'AND'.
"""
input delivery_type_bool_exp {
  _and: [delivery_type_bool_exp!]
  _not: delivery_type_bool_exp
  _or: [delivery_type_bool_exp!]
  comment: String_comparison_exp
  products: product_bool_exp
  products_aggregate: product_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "delivery_type"
"""
enum delivery_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  delivery_type_pkey
}

enum delivery_type_enum {
  """"""
  CARGO_SHIPPING

  """Delivery in same day by service"""
  SAME_DAY

  """"""
  SAME_DAY_CARGO
}

"""
Boolean expression to compare columns of type "delivery_type_enum". All fields are combined with logical 'AND'.
"""
input delivery_type_enum_comparison_exp {
  _eq: delivery_type_enum
  _in: [delivery_type_enum!]
  _is_null: Boolean
  _neq: delivery_type_enum
  _nin: [delivery_type_enum!]
}

"""
input type for inserting data into table "delivery_type"
"""
input delivery_type_insert_input {
  comment: String
  products: product_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type delivery_type_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type delivery_type_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "delivery_type"
"""
type delivery_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [delivery_type!]!
}

"""
input type for inserting object relation for remote table "delivery_type"
"""
input delivery_type_obj_rel_insert_input {
  data: delivery_type_insert_input!

  """upsert condition"""
  on_conflict: delivery_type_on_conflict
}

"""
on_conflict condition type for table "delivery_type"
"""
input delivery_type_on_conflict {
  constraint: delivery_type_constraint!
  update_columns: [delivery_type_update_column!]! = []
  where: delivery_type_bool_exp
}

"""Ordering options when selecting data from "delivery_type"."""
input delivery_type_order_by {
  comment: order_by
  products_aggregate: product_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: delivery_type"""
input delivery_type_pk_columns_input {
  value: String!
}

"""
select columns of table "delivery_type"
"""
enum delivery_type_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "delivery_type"
"""
input delivery_type_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "delivery_type"
"""
input delivery_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: delivery_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input delivery_type_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "delivery_type"
"""
enum delivery_type_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input delivery_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: delivery_type_set_input

  """filter the rows which have to be updated"""
  where: delivery_type_bool_exp!
}

"""
columns and relationships of "district"
"""
type district {
  """An object relationship"""
  city: city!
  code: Int!
  id: Int!
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String!

  """An array relationship"""
  order_addresses(
    """distinct select on columns"""
    distinct_on: [order_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_address_order_by!]

    """filter the rows returned"""
    where: order_address_bool_exp
  ): [order_address!]!

  """An aggregate relationship"""
  order_addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [order_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_address_order_by!]

    """filter the rows returned"""
    where: order_address_bool_exp
  ): order_address_aggregate!
  parent_id: Int!

  """An array relationship"""
  quarters(
    """distinct select on columns"""
    distinct_on: [quarter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [quarter_order_by!]

    """filter the rows returned"""
    where: quarter_bool_exp
  ): [quarter!]!

  """An aggregate relationship"""
  quarters_aggregate(
    """distinct select on columns"""
    distinct_on: [quarter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [quarter_order_by!]

    """filter the rows returned"""
    where: quarter_bool_exp
  ): quarter_aggregate!

  """An array relationship"""
  user_addresses(
    """distinct select on columns"""
    distinct_on: [user_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_address_order_by!]

    """filter the rows returned"""
    where: user_address_bool_exp
  ): [user_address!]!

  """An aggregate relationship"""
  user_addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [user_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_address_order_by!]

    """filter the rows returned"""
    where: user_address_bool_exp
  ): user_address_aggregate!
}

"""
aggregated selection of "district"
"""
type district_aggregate {
  aggregate: district_aggregate_fields
  nodes: [district!]!
}

input district_aggregate_bool_exp {
  count: district_aggregate_bool_exp_count
}

input district_aggregate_bool_exp_count {
  arguments: [district_select_column!]
  distinct: Boolean
  filter: district_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "district"
"""
type district_aggregate_fields {
  avg: district_avg_fields
  count(columns: [district_select_column!], distinct: Boolean): Int!
  max: district_max_fields
  min: district_min_fields
  stddev: district_stddev_fields
  stddev_pop: district_stddev_pop_fields
  stddev_samp: district_stddev_samp_fields
  sum: district_sum_fields
  var_pop: district_var_pop_fields
  var_samp: district_var_samp_fields
  variance: district_variance_fields
}

"""
order by aggregate values of table "district"
"""
input district_aggregate_order_by {
  avg: district_avg_order_by
  count: order_by
  max: district_max_order_by
  min: district_min_order_by
  stddev: district_stddev_order_by
  stddev_pop: district_stddev_pop_order_by
  stddev_samp: district_stddev_samp_order_by
  sum: district_sum_order_by
  var_pop: district_var_pop_order_by
  var_samp: district_var_samp_order_by
  variance: district_variance_order_by
}

"""
input type for inserting array relation for remote table "district"
"""
input district_arr_rel_insert_input {
  data: [district_insert_input!]!

  """upsert condition"""
  on_conflict: district_on_conflict
}

"""aggregate avg on columns"""
type district_avg_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
order by avg() on columns of table "district"
"""
input district_avg_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

"""
Boolean expression to filter rows from the table "district". All fields are combined with a logical 'AND'.
"""
input district_bool_exp {
  _and: [district_bool_exp!]
  _not: district_bool_exp
  _or: [district_bool_exp!]
  city: city_bool_exp
  code: Int_comparison_exp
  id: Int_comparison_exp
  maxlatitude: String_comparison_exp
  maxlongitude: String_comparison_exp
  minlatitude: String_comparison_exp
  minlongitude: String_comparison_exp
  name: String_comparison_exp
  order_addresses: order_address_bool_exp
  order_addresses_aggregate: order_address_aggregate_bool_exp
  parent_id: Int_comparison_exp
  quarters: quarter_bool_exp
  quarters_aggregate: quarter_aggregate_bool_exp
  user_addresses: user_address_bool_exp
  user_addresses_aggregate: user_address_aggregate_bool_exp
}

"""
unique or primary key constraints on table "district"
"""
enum district_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  district_code_key

  """
  unique or primary key constraint on columns "id"
  """
  district_pkey
}

"""
input type for incrementing numeric columns in table "district"
"""
input district_inc_input {
  code: Int
  id: Int
  parent_id: Int
}

"""
input type for inserting data into table "district"
"""
input district_insert_input {
  city: city_obj_rel_insert_input
  code: Int
  id: Int
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String
  order_addresses: order_address_arr_rel_insert_input
  parent_id: Int
  quarters: quarter_arr_rel_insert_input
  user_addresses: user_address_arr_rel_insert_input
}

"""aggregate max on columns"""
type district_max_fields {
  code: Int
  id: Int
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String
  parent_id: Int
}

"""
order by max() on columns of table "district"
"""
input district_max_order_by {
  code: order_by
  id: order_by
  maxlatitude: order_by
  maxlongitude: order_by
  minlatitude: order_by
  minlongitude: order_by
  name: order_by
  parent_id: order_by
}

"""aggregate min on columns"""
type district_min_fields {
  code: Int
  id: Int
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String
  parent_id: Int
}

"""
order by min() on columns of table "district"
"""
input district_min_order_by {
  code: order_by
  id: order_by
  maxlatitude: order_by
  maxlongitude: order_by
  minlatitude: order_by
  minlongitude: order_by
  name: order_by
  parent_id: order_by
}

"""
response of any mutation on the table "district"
"""
type district_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [district!]!
}

"""
input type for inserting object relation for remote table "district"
"""
input district_obj_rel_insert_input {
  data: district_insert_input!

  """upsert condition"""
  on_conflict: district_on_conflict
}

"""
on_conflict condition type for table "district"
"""
input district_on_conflict {
  constraint: district_constraint!
  update_columns: [district_update_column!]! = []
  where: district_bool_exp
}

"""Ordering options when selecting data from "district"."""
input district_order_by {
  city: city_order_by
  code: order_by
  id: order_by
  maxlatitude: order_by
  maxlongitude: order_by
  minlatitude: order_by
  minlongitude: order_by
  name: order_by
  order_addresses_aggregate: order_address_aggregate_order_by
  parent_id: order_by
  quarters_aggregate: quarter_aggregate_order_by
  user_addresses_aggregate: user_address_aggregate_order_by
}

"""primary key columns input for table: district"""
input district_pk_columns_input {
  id: Int!
}

"""
select columns of table "district"
"""
enum district_select_column {
  """column name"""
  code

  """column name"""
  id

  """column name"""
  maxlatitude

  """column name"""
  maxlongitude

  """column name"""
  minlatitude

  """column name"""
  minlongitude

  """column name"""
  name

  """column name"""
  parent_id
}

"""
input type for updating data in table "district"
"""
input district_set_input {
  code: Int
  id: Int
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String
  parent_id: Int
}

"""aggregate stddev on columns"""
type district_stddev_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
order by stddev() on columns of table "district"
"""
input district_stddev_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

"""aggregate stddev_pop on columns"""
type district_stddev_pop_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
order by stddev_pop() on columns of table "district"
"""
input district_stddev_pop_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

"""aggregate stddev_samp on columns"""
type district_stddev_samp_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
order by stddev_samp() on columns of table "district"
"""
input district_stddev_samp_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

"""
Streaming cursor of the table "district"
"""
input district_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: district_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input district_stream_cursor_value_input {
  code: Int
  id: Int
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String
  parent_id: Int
}

"""aggregate sum on columns"""
type district_sum_fields {
  code: Int
  id: Int
  parent_id: Int
}

"""
order by sum() on columns of table "district"
"""
input district_sum_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

"""
update columns of table "district"
"""
enum district_update_column {
  """column name"""
  code

  """column name"""
  id

  """column name"""
  maxlatitude

  """column name"""
  maxlongitude

  """column name"""
  minlatitude

  """column name"""
  minlongitude

  """column name"""
  name

  """column name"""
  parent_id
}

input district_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: district_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: district_set_input

  """filter the rows which have to be updated"""
  where: district_bool_exp!
}

"""aggregate var_pop on columns"""
type district_var_pop_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
order by var_pop() on columns of table "district"
"""
input district_var_pop_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

"""aggregate var_samp on columns"""
type district_var_samp_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
order by var_samp() on columns of table "district"
"""
input district_var_samp_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

"""aggregate variance on columns"""
type district_variance_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
order by variance() on columns of table "district"
"""
input district_variance_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

input get_product_delivery_cities_args {
  product_id: bigint
}

scalar json

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "message"
"""
type message {
  """An object relationship"""
  chat_thread: chat_thread!
  chat_thread_id: uuid!
  created_at: timestamptz!
  id: bigint!
  is_deleted: Boolean
  is_read: Boolean
  message: String!

  """An object relationship"""
  receiver: user!
  receiver_id: uuid!

  """An object relationship"""
  sender: user!
  sender_id: uuid!
  updated_at: timestamptz!
}

"""
aggregated selection of "message"
"""
type message_aggregate {
  aggregate: message_aggregate_fields
  nodes: [message!]!
}

input message_aggregate_bool_exp {
  bool_and: message_aggregate_bool_exp_bool_and
  bool_or: message_aggregate_bool_exp_bool_or
  count: message_aggregate_bool_exp_count
}

input message_aggregate_bool_exp_bool_and {
  arguments: message_select_column_message_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: message_bool_exp
  predicate: Boolean_comparison_exp!
}

input message_aggregate_bool_exp_bool_or {
  arguments: message_select_column_message_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: message_bool_exp
  predicate: Boolean_comparison_exp!
}

input message_aggregate_bool_exp_count {
  arguments: [message_select_column!]
  distinct: Boolean
  filter: message_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "message"
"""
type message_aggregate_fields {
  avg: message_avg_fields
  count(columns: [message_select_column!], distinct: Boolean): Int!
  max: message_max_fields
  min: message_min_fields
  stddev: message_stddev_fields
  stddev_pop: message_stddev_pop_fields
  stddev_samp: message_stddev_samp_fields
  sum: message_sum_fields
  var_pop: message_var_pop_fields
  var_samp: message_var_samp_fields
  variance: message_variance_fields
}

"""
order by aggregate values of table "message"
"""
input message_aggregate_order_by {
  avg: message_avg_order_by
  count: order_by
  max: message_max_order_by
  min: message_min_order_by
  stddev: message_stddev_order_by
  stddev_pop: message_stddev_pop_order_by
  stddev_samp: message_stddev_samp_order_by
  sum: message_sum_order_by
  var_pop: message_var_pop_order_by
  var_samp: message_var_samp_order_by
  variance: message_variance_order_by
}

"""
input type for inserting array relation for remote table "message"
"""
input message_arr_rel_insert_input {
  data: [message_insert_input!]!

  """upsert condition"""
  on_conflict: message_on_conflict
}

"""aggregate avg on columns"""
type message_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "message"
"""
input message_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "message". All fields are combined with a logical 'AND'.
"""
input message_bool_exp {
  _and: [message_bool_exp!]
  _not: message_bool_exp
  _or: [message_bool_exp!]
  chat_thread: chat_thread_bool_exp
  chat_thread_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  is_deleted: Boolean_comparison_exp
  is_read: Boolean_comparison_exp
  message: String_comparison_exp
  receiver: user_bool_exp
  receiver_id: uuid_comparison_exp
  sender: user_bool_exp
  sender_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "message"
"""
enum message_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  message_pkey
}

"""
input type for incrementing numeric columns in table "message"
"""
input message_inc_input {
  id: bigint
}

"""
input type for inserting data into table "message"
"""
input message_insert_input {
  chat_thread: chat_thread_obj_rel_insert_input
  chat_thread_id: uuid
  created_at: timestamptz
  id: bigint
  is_deleted: Boolean
  is_read: Boolean
  message: String
  receiver: user_obj_rel_insert_input
  receiver_id: uuid
  sender: user_obj_rel_insert_input
  sender_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type message_max_fields {
  chat_thread_id: uuid
  created_at: timestamptz
  id: bigint
  message: String
  receiver_id: uuid
  sender_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "message"
"""
input message_max_order_by {
  chat_thread_id: order_by
  created_at: order_by
  id: order_by
  message: order_by
  receiver_id: order_by
  sender_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type message_min_fields {
  chat_thread_id: uuid
  created_at: timestamptz
  id: bigint
  message: String
  receiver_id: uuid
  sender_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "message"
"""
input message_min_order_by {
  chat_thread_id: order_by
  created_at: order_by
  id: order_by
  message: order_by
  receiver_id: order_by
  sender_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "message"
"""
type message_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [message!]!
}

"""
on_conflict condition type for table "message"
"""
input message_on_conflict {
  constraint: message_constraint!
  update_columns: [message_update_column!]! = []
  where: message_bool_exp
}

"""Ordering options when selecting data from "message"."""
input message_order_by {
  chat_thread: chat_thread_order_by
  chat_thread_id: order_by
  created_at: order_by
  id: order_by
  is_deleted: order_by
  is_read: order_by
  message: order_by
  receiver: user_order_by
  receiver_id: order_by
  sender: user_order_by
  sender_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: message"""
input message_pk_columns_input {
  id: bigint!
}

"""
select columns of table "message"
"""
enum message_select_column {
  """column name"""
  chat_thread_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_deleted

  """column name"""
  is_read

  """column name"""
  message

  """column name"""
  receiver_id

  """column name"""
  sender_id

  """column name"""
  updated_at
}

"""
select "message_aggregate_bool_exp_bool_and_arguments_columns" columns of table "message"
"""
enum message_select_column_message_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_deleted

  """column name"""
  is_read
}

"""
select "message_aggregate_bool_exp_bool_or_arguments_columns" columns of table "message"
"""
enum message_select_column_message_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_deleted

  """column name"""
  is_read
}

"""
input type for updating data in table "message"
"""
input message_set_input {
  chat_thread_id: uuid
  created_at: timestamptz
  id: bigint
  is_deleted: Boolean
  is_read: Boolean
  message: String
  receiver_id: uuid
  sender_id: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type message_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "message"
"""
input message_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type message_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "message"
"""
input message_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type message_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "message"
"""
input message_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "message"
"""
input message_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: message_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input message_stream_cursor_value_input {
  chat_thread_id: uuid
  created_at: timestamptz
  id: bigint
  is_deleted: Boolean
  is_read: Boolean
  message: String
  receiver_id: uuid
  sender_id: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type message_sum_fields {
  id: bigint
}

"""
order by sum() on columns of table "message"
"""
input message_sum_order_by {
  id: order_by
}

"""
update columns of table "message"
"""
enum message_update_column {
  """column name"""
  chat_thread_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_deleted

  """column name"""
  is_read

  """column name"""
  message

  """column name"""
  receiver_id

  """column name"""
  sender_id

  """column name"""
  updated_at
}

input message_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: message_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: message_set_input

  """filter the rows which have to be updated"""
  where: message_bool_exp!
}

"""aggregate var_pop on columns"""
type message_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "message"
"""
input message_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type message_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "message"
"""
input message_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type message_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "message"
"""
input message_variance_order_by {
  id: order_by
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "address_type"
  """
  delete_address_type(
    """filter the rows which have to be deleted"""
    where: address_type_bool_exp!
  ): address_type_mutation_response

  """
  delete single row from the table: "address_type"
  """
  delete_address_type_by_pk(value: String!): address_type

  """
  delete data from the table: "answer"
  """
  delete_answer(
    """filter the rows which have to be deleted"""
    where: answer_bool_exp!
  ): answer_mutation_response

  """
  delete single row from the table: "answer"
  """
  delete_answer_by_pk(id: bigint!): answer

  """
  delete data from the table: "cart"
  """
  delete_cart(
    """filter the rows which have to be deleted"""
    where: cart_bool_exp!
  ): cart_mutation_response

  """
  delete single row from the table: "cart"
  """
  delete_cart_by_pk(id: uuid!): cart

  """
  delete data from the table: "category"
  """
  delete_category(
    """filter the rows which have to be deleted"""
    where: category_bool_exp!
  ): category_mutation_response

  """
  delete single row from the table: "category"
  """
  delete_category_by_pk(id: Int!): category

  """
  delete data from the table: "chat_thread"
  """
  delete_chat_thread(
    """filter the rows which have to be deleted"""
    where: chat_thread_bool_exp!
  ): chat_thread_mutation_response

  """
  delete single row from the table: "chat_thread"
  """
  delete_chat_thread_by_pk(id: uuid!): chat_thread

  """
  delete data from the table: "city"
  """
  delete_city(
    """filter the rows which have to be deleted"""
    where: city_bool_exp!
  ): city_mutation_response

  """
  delete single row from the table: "city"
  """
  delete_city_by_pk(id: Int!): city

  """
  delete data from the table: "company"
  """
  delete_company(
    """filter the rows which have to be deleted"""
    where: company_bool_exp!
  ): company_mutation_response

  """
  delete single row from the table: "company"
  """
  delete_company_by_pk(id: uuid!): company

  """
  delete data from the table: "company_category"
  """
  delete_company_category(
    """filter the rows which have to be deleted"""
    where: company_category_bool_exp!
  ): company_category_mutation_response

  """
  delete single row from the table: "company_category"
  """
  delete_company_category_by_pk(id: Int!): company_category

  """
  delete data from the table: "company_type"
  """
  delete_company_type(
    """filter the rows which have to be deleted"""
    where: company_type_bool_exp!
  ): company_type_mutation_response

  """
  delete single row from the table: "company_type"
  """
  delete_company_type_by_pk(value: String!): company_type

  """
  delete data from the table: "coupon"
  """
  delete_coupon(
    """filter the rows which have to be deleted"""
    where: coupon_bool_exp!
  ): coupon_mutation_response

  """
  delete single row from the table: "coupon"
  """
  delete_coupon_by_pk(id: uuid!): coupon

  """
  delete data from the table: "customizable_area"
  """
  delete_customizable_area(
    """filter the rows which have to be deleted"""
    where: customizable_area_bool_exp!
  ): customizable_area_mutation_response

  """
  delete single row from the table: "customizable_area"
  """
  delete_customizable_area_by_pk(id: Int!): customizable_area

  """
  delete data from the table: "delivery_type"
  """
  delete_delivery_type(
    """filter the rows which have to be deleted"""
    where: delivery_type_bool_exp!
  ): delivery_type_mutation_response

  """
  delete single row from the table: "delivery_type"
  """
  delete_delivery_type_by_pk(value: String!): delivery_type

  """
  delete data from the table: "district"
  """
  delete_district(
    """filter the rows which have to be deleted"""
    where: district_bool_exp!
  ): district_mutation_response

  """
  delete single row from the table: "district"
  """
  delete_district_by_pk(id: Int!): district

  """
  delete data from the table: "message"
  """
  delete_message(
    """filter the rows which have to be deleted"""
    where: message_bool_exp!
  ): message_mutation_response

  """
  delete single row from the table: "message"
  """
  delete_message_by_pk(id: bigint!): message

  """
  delete data from the table: "order"
  """
  delete_order(
    """filter the rows which have to be deleted"""
    where: order_bool_exp!
  ): order_mutation_response

  """
  delete data from the table: "order_address"
  """
  delete_order_address(
    """filter the rows which have to be deleted"""
    where: order_address_bool_exp!
  ): order_address_mutation_response

  """
  delete single row from the table: "order_address"
  """
  delete_order_address_by_pk(id: Int!): order_address

  """
  delete single row from the table: "order"
  """
  delete_order_by_pk(id: uuid!): order

  """
  delete data from the table: "order_item"
  """
  delete_order_item(
    """filter the rows which have to be deleted"""
    where: order_item_bool_exp!
  ): order_item_mutation_response

  """
  delete single row from the table: "order_item"
  """
  delete_order_item_by_pk(id: bigint!): order_item

  """
  delete data from the table: "order_item_special_image"
  """
  delete_order_item_special_image(
    """filter the rows which have to be deleted"""
    where: order_item_special_image_bool_exp!
  ): order_item_special_image_mutation_response

  """
  delete single row from the table: "order_item_special_image"
  """
  delete_order_item_special_image_by_pk(id: bigint!): order_item_special_image

  """
  delete data from the table: "order_item_special_text"
  """
  delete_order_item_special_text(
    """filter the rows which have to be deleted"""
    where: order_item_special_text_bool_exp!
  ): order_item_special_text_mutation_response

  """
  delete single row from the table: "order_item_special_text"
  """
  delete_order_item_special_text_by_pk(id: bigint!): order_item_special_text

  """
  delete data from the table: "order_status"
  """
  delete_order_status(
    """filter the rows which have to be deleted"""
    where: order_status_bool_exp!
  ): order_status_mutation_response

  """
  delete single row from the table: "order_status"
  """
  delete_order_status_by_pk(value: String!): order_status

  """
  delete data from the table: "order_tenant"
  """
  delete_order_tenant(
    """filter the rows which have to be deleted"""
    where: order_tenant_bool_exp!
  ): order_tenant_mutation_response

  """
  delete single row from the table: "order_tenant"
  """
  delete_order_tenant_by_pk(id: bigint!): order_tenant

  """
  delete data from the table: "order_tenant_invoice"
  """
  delete_order_tenant_invoice(
    """filter the rows which have to be deleted"""
    where: order_tenant_invoice_bool_exp!
  ): order_tenant_invoice_mutation_response

  """
  delete single row from the table: "order_tenant_invoice"
  """
  delete_order_tenant_invoice_by_pk(id: uuid!): order_tenant_invoice

  """
  delete data from the table: "payment_status"
  """
  delete_payment_status(
    """filter the rows which have to be deleted"""
    where: payment_status_bool_exp!
  ): payment_status_mutation_response

  """
  delete single row from the table: "payment_status"
  """
  delete_payment_status_by_pk(value: String!): payment_status

  """
  delete data from the table: "product"
  """
  delete_product(
    """filter the rows which have to be deleted"""
    where: product_bool_exp!
  ): product_mutation_response

  """
  delete single row from the table: "product"
  """
  delete_product_by_pk(id: bigint!): product

  """
  delete data from the table: "product_category"
  """
  delete_product_category(
    """filter the rows which have to be deleted"""
    where: product_category_bool_exp!
  ): product_category_mutation_response

  """
  delete single row from the table: "product_category"
  """
  delete_product_category_by_pk(id: bigint!): product_category

  """
  delete data from the table: "product_customizable_area"
  """
  delete_product_customizable_area(
    """filter the rows which have to be deleted"""
    where: product_customizable_area_bool_exp!
  ): product_customizable_area_mutation_response

  """
  delete single row from the table: "product_customizable_area"
  """
  delete_product_customizable_area_by_pk(id: bigint!): product_customizable_area

  """
  delete data from the table: "product_delivery_city_info"
  """
  delete_product_delivery_city_info(
    """filter the rows which have to be deleted"""
    where: product_delivery_city_info_bool_exp!
  ): product_delivery_city_info_mutation_response

  """
  delete data from the table: "quarter"
  """
  delete_quarter(
    """filter the rows which have to be deleted"""
    where: quarter_bool_exp!
  ): quarter_mutation_response

  """
  delete single row from the table: "quarter"
  """
  delete_quarter_by_pk(id: Int!): quarter

  """
  delete data from the table: "question"
  """
  delete_question(
    """filter the rows which have to be deleted"""
    where: question_bool_exp!
  ): question_mutation_response

  """
  delete single row from the table: "question"
  """
  delete_question_by_pk(id: bigint!): question

  """
  delete data from the table: "review"
  """
  delete_review(
    """filter the rows which have to be deleted"""
    where: review_bool_exp!
  ): review_mutation_response

  """
  delete single row from the table: "review"
  """
  delete_review_by_pk(id: Int!): review

  """
  delete data from the table: "role"
  """
  delete_role(
    """filter the rows which have to be deleted"""
    where: role_bool_exp!
  ): role_mutation_response

  """
  delete single row from the table: "role"
  """
  delete_role_by_pk(value: String!): role

  """
  delete data from the table: "search_location_result"
  """
  delete_search_location_result(
    """filter the rows which have to be deleted"""
    where: search_location_result_bool_exp!
  ): search_location_result_mutation_response

  """
  delete data from the table: "session"
  """
  delete_session(
    """filter the rows which have to be deleted"""
    where: session_bool_exp!
  ): session_mutation_response

  """
  delete single row from the table: "session"
  """
  delete_session_by_pk(id: uuid!): session

  """
  delete data from the table: "system_banner"
  """
  delete_system_banner(
    """filter the rows which have to be deleted"""
    where: system_banner_bool_exp!
  ): system_banner_mutation_response

  """
  delete single row from the table: "system_banner"
  """
  delete_system_banner_by_pk(id: uuid!): system_banner

  """
  delete data from the table: "tenant"
  """
  delete_tenant(
    """filter the rows which have to be deleted"""
    where: tenant_bool_exp!
  ): tenant_mutation_response

  """
  delete data from the table: "tenant_address"
  """
  delete_tenant_address(
    """filter the rows which have to be deleted"""
    where: tenant_address_bool_exp!
  ): tenant_address_mutation_response

  """
  delete single row from the table: "tenant_address"
  """
  delete_tenant_address_by_pk(id: uuid!): tenant_address

  """
  delete single row from the table: "tenant"
  """
  delete_tenant_by_pk(id: uuid!): tenant

  """
  delete data from the table: "tenant_category"
  """
  delete_tenant_category(
    """filter the rows which have to be deleted"""
    where: tenant_category_bool_exp!
  ): tenant_category_mutation_response

  """
  delete single row from the table: "tenant_category"
  """
  delete_tenant_category_by_pk(id: bigint!): tenant_category

  """
  delete data from the table: "tenant_shipping_place"
  """
  delete_tenant_shipping_place(
    """filter the rows which have to be deleted"""
    where: tenant_shipping_place_bool_exp!
  ): tenant_shipping_place_mutation_response

  """
  delete single row from the table: "tenant_shipping_place"
  """
  delete_tenant_shipping_place_by_pk(id: Int!): tenant_shipping_place

  """
  delete data from the table: "ticket"
  """
  delete_ticket(
    """filter the rows which have to be deleted"""
    where: ticket_bool_exp!
  ): ticket_mutation_response

  """
  delete data from the table: "ticket_answer"
  """
  delete_ticket_answer(
    """filter the rows which have to be deleted"""
    where: ticket_answer_bool_exp!
  ): ticket_answer_mutation_response

  """
  delete single row from the table: "ticket_answer"
  """
  delete_ticket_answer_by_pk(id: uuid!): ticket_answer

  """
  delete single row from the table: "ticket"
  """
  delete_ticket_by_pk(id: bigint!): ticket

  """
  delete data from the table: "ticket_status"
  """
  delete_ticket_status(
    """filter the rows which have to be deleted"""
    where: ticket_status_bool_exp!
  ): ticket_status_mutation_response

  """
  delete single row from the table: "ticket_status"
  """
  delete_ticket_status_by_pk(value: String!): ticket_status

  """
  delete data from the table: "transaction"
  """
  delete_transaction(
    """filter the rows which have to be deleted"""
    where: transaction_bool_exp!
  ): transaction_mutation_response

  """
  delete single row from the table: "transaction"
  """
  delete_transaction_by_pk(id: uuid!): transaction

  """
  delete data from the table: "user"
  """
  delete_user(
    """filter the rows which have to be deleted"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete data from the table: "user_address"
  """
  delete_user_address(
    """filter the rows which have to be deleted"""
    where: user_address_bool_exp!
  ): user_address_mutation_response

  """
  delete single row from the table: "user_address"
  """
  delete_user_address_by_pk(id: Int!): user_address

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: uuid!): user

  """
  delete data from the table: "user_coupon"
  """
  delete_user_coupon(
    """filter the rows which have to be deleted"""
    where: user_coupon_bool_exp!
  ): user_coupon_mutation_response

  """
  delete single row from the table: "user_coupon"
  """
  delete_user_coupon_by_pk(id: uuid!): user_coupon

  """
  delete data from the table: "user_favorite"
  """
  delete_user_favorite(
    """filter the rows which have to be deleted"""
    where: user_favorite_bool_exp!
  ): user_favorite_mutation_response

  """
  delete single row from the table: "user_favorite"
  """
  delete_user_favorite_by_pk(id: bigint!): user_favorite
  email_verify(args: EmailVerifyInput!): EmailVerifyOutput

  """forgot_password"""
  forgot_password(args: ForgotPasswordInput!): ForgotPasswordOutput

  """
  insert data into the table: "address_type"
  """
  insert_address_type(
    """the rows to be inserted"""
    objects: [address_type_insert_input!]!

    """upsert condition"""
    on_conflict: address_type_on_conflict
  ): address_type_mutation_response

  """
  insert a single row into the table: "address_type"
  """
  insert_address_type_one(
    """the row to be inserted"""
    object: address_type_insert_input!

    """upsert condition"""
    on_conflict: address_type_on_conflict
  ): address_type

  """
  insert data into the table: "answer"
  """
  insert_answer(
    """the rows to be inserted"""
    objects: [answer_insert_input!]!

    """upsert condition"""
    on_conflict: answer_on_conflict
  ): answer_mutation_response

  """
  insert a single row into the table: "answer"
  """
  insert_answer_one(
    """the row to be inserted"""
    object: answer_insert_input!

    """upsert condition"""
    on_conflict: answer_on_conflict
  ): answer

  """
  insert data into the table: "cart"
  """
  insert_cart(
    """the rows to be inserted"""
    objects: [cart_insert_input!]!

    """upsert condition"""
    on_conflict: cart_on_conflict
  ): cart_mutation_response

  """
  insert a single row into the table: "cart"
  """
  insert_cart_one(
    """the row to be inserted"""
    object: cart_insert_input!

    """upsert condition"""
    on_conflict: cart_on_conflict
  ): cart

  """
  insert data into the table: "category"
  """
  insert_category(
    """the rows to be inserted"""
    objects: [category_insert_input!]!

    """upsert condition"""
    on_conflict: category_on_conflict
  ): category_mutation_response

  """
  insert a single row into the table: "category"
  """
  insert_category_one(
    """the row to be inserted"""
    object: category_insert_input!

    """upsert condition"""
    on_conflict: category_on_conflict
  ): category

  """
  insert data into the table: "chat_thread"
  """
  insert_chat_thread(
    """the rows to be inserted"""
    objects: [chat_thread_insert_input!]!

    """upsert condition"""
    on_conflict: chat_thread_on_conflict
  ): chat_thread_mutation_response

  """
  insert a single row into the table: "chat_thread"
  """
  insert_chat_thread_one(
    """the row to be inserted"""
    object: chat_thread_insert_input!

    """upsert condition"""
    on_conflict: chat_thread_on_conflict
  ): chat_thread

  """
  insert data into the table: "city"
  """
  insert_city(
    """the rows to be inserted"""
    objects: [city_insert_input!]!

    """upsert condition"""
    on_conflict: city_on_conflict
  ): city_mutation_response

  """
  insert a single row into the table: "city"
  """
  insert_city_one(
    """the row to be inserted"""
    object: city_insert_input!

    """upsert condition"""
    on_conflict: city_on_conflict
  ): city

  """
  insert data into the table: "company"
  """
  insert_company(
    """the rows to be inserted"""
    objects: [company_insert_input!]!

    """upsert condition"""
    on_conflict: company_on_conflict
  ): company_mutation_response

  """
  insert data into the table: "company_category"
  """
  insert_company_category(
    """the rows to be inserted"""
    objects: [company_category_insert_input!]!

    """upsert condition"""
    on_conflict: company_category_on_conflict
  ): company_category_mutation_response

  """
  insert a single row into the table: "company_category"
  """
  insert_company_category_one(
    """the row to be inserted"""
    object: company_category_insert_input!

    """upsert condition"""
    on_conflict: company_category_on_conflict
  ): company_category

  """
  insert a single row into the table: "company"
  """
  insert_company_one(
    """the row to be inserted"""
    object: company_insert_input!

    """upsert condition"""
    on_conflict: company_on_conflict
  ): company

  """
  insert data into the table: "company_type"
  """
  insert_company_type(
    """the rows to be inserted"""
    objects: [company_type_insert_input!]!

    """upsert condition"""
    on_conflict: company_type_on_conflict
  ): company_type_mutation_response

  """
  insert a single row into the table: "company_type"
  """
  insert_company_type_one(
    """the row to be inserted"""
    object: company_type_insert_input!

    """upsert condition"""
    on_conflict: company_type_on_conflict
  ): company_type

  """
  insert data into the table: "coupon"
  """
  insert_coupon(
    """the rows to be inserted"""
    objects: [coupon_insert_input!]!

    """upsert condition"""
    on_conflict: coupon_on_conflict
  ): coupon_mutation_response

  """
  insert a single row into the table: "coupon"
  """
  insert_coupon_one(
    """the row to be inserted"""
    object: coupon_insert_input!

    """upsert condition"""
    on_conflict: coupon_on_conflict
  ): coupon

  """
  insert data into the table: "customizable_area"
  """
  insert_customizable_area(
    """the rows to be inserted"""
    objects: [customizable_area_insert_input!]!

    """upsert condition"""
    on_conflict: customizable_area_on_conflict
  ): customizable_area_mutation_response

  """
  insert a single row into the table: "customizable_area"
  """
  insert_customizable_area_one(
    """the row to be inserted"""
    object: customizable_area_insert_input!

    """upsert condition"""
    on_conflict: customizable_area_on_conflict
  ): customizable_area

  """
  insert data into the table: "delivery_type"
  """
  insert_delivery_type(
    """the rows to be inserted"""
    objects: [delivery_type_insert_input!]!

    """upsert condition"""
    on_conflict: delivery_type_on_conflict
  ): delivery_type_mutation_response

  """
  insert a single row into the table: "delivery_type"
  """
  insert_delivery_type_one(
    """the row to be inserted"""
    object: delivery_type_insert_input!

    """upsert condition"""
    on_conflict: delivery_type_on_conflict
  ): delivery_type

  """
  insert data into the table: "district"
  """
  insert_district(
    """the rows to be inserted"""
    objects: [district_insert_input!]!

    """upsert condition"""
    on_conflict: district_on_conflict
  ): district_mutation_response

  """
  insert a single row into the table: "district"
  """
  insert_district_one(
    """the row to be inserted"""
    object: district_insert_input!

    """upsert condition"""
    on_conflict: district_on_conflict
  ): district

  """
  insert data into the table: "message"
  """
  insert_message(
    """the rows to be inserted"""
    objects: [message_insert_input!]!

    """upsert condition"""
    on_conflict: message_on_conflict
  ): message_mutation_response

  """
  insert a single row into the table: "message"
  """
  insert_message_one(
    """the row to be inserted"""
    object: message_insert_input!

    """upsert condition"""
    on_conflict: message_on_conflict
  ): message

  """
  insert data into the table: "order"
  """
  insert_order(
    """the rows to be inserted"""
    objects: [order_insert_input!]!

    """upsert condition"""
    on_conflict: order_on_conflict
  ): order_mutation_response

  """
  insert data into the table: "order_address"
  """
  insert_order_address(
    """the rows to be inserted"""
    objects: [order_address_insert_input!]!

    """upsert condition"""
    on_conflict: order_address_on_conflict
  ): order_address_mutation_response

  """
  insert a single row into the table: "order_address"
  """
  insert_order_address_one(
    """the row to be inserted"""
    object: order_address_insert_input!

    """upsert condition"""
    on_conflict: order_address_on_conflict
  ): order_address

  """
  insert data into the table: "order_item"
  """
  insert_order_item(
    """the rows to be inserted"""
    objects: [order_item_insert_input!]!

    """upsert condition"""
    on_conflict: order_item_on_conflict
  ): order_item_mutation_response

  """
  insert a single row into the table: "order_item"
  """
  insert_order_item_one(
    """the row to be inserted"""
    object: order_item_insert_input!

    """upsert condition"""
    on_conflict: order_item_on_conflict
  ): order_item

  """
  insert data into the table: "order_item_special_image"
  """
  insert_order_item_special_image(
    """the rows to be inserted"""
    objects: [order_item_special_image_insert_input!]!

    """upsert condition"""
    on_conflict: order_item_special_image_on_conflict
  ): order_item_special_image_mutation_response

  """
  insert a single row into the table: "order_item_special_image"
  """
  insert_order_item_special_image_one(
    """the row to be inserted"""
    object: order_item_special_image_insert_input!

    """upsert condition"""
    on_conflict: order_item_special_image_on_conflict
  ): order_item_special_image

  """
  insert data into the table: "order_item_special_text"
  """
  insert_order_item_special_text(
    """the rows to be inserted"""
    objects: [order_item_special_text_insert_input!]!

    """upsert condition"""
    on_conflict: order_item_special_text_on_conflict
  ): order_item_special_text_mutation_response

  """
  insert a single row into the table: "order_item_special_text"
  """
  insert_order_item_special_text_one(
    """the row to be inserted"""
    object: order_item_special_text_insert_input!

    """upsert condition"""
    on_conflict: order_item_special_text_on_conflict
  ): order_item_special_text

  """
  insert a single row into the table: "order"
  """
  insert_order_one(
    """the row to be inserted"""
    object: order_insert_input!

    """upsert condition"""
    on_conflict: order_on_conflict
  ): order

  """
  insert data into the table: "order_status"
  """
  insert_order_status(
    """the rows to be inserted"""
    objects: [order_status_insert_input!]!

    """upsert condition"""
    on_conflict: order_status_on_conflict
  ): order_status_mutation_response

  """
  insert a single row into the table: "order_status"
  """
  insert_order_status_one(
    """the row to be inserted"""
    object: order_status_insert_input!

    """upsert condition"""
    on_conflict: order_status_on_conflict
  ): order_status

  """
  insert data into the table: "order_tenant"
  """
  insert_order_tenant(
    """the rows to be inserted"""
    objects: [order_tenant_insert_input!]!

    """upsert condition"""
    on_conflict: order_tenant_on_conflict
  ): order_tenant_mutation_response

  """
  insert data into the table: "order_tenant_invoice"
  """
  insert_order_tenant_invoice(
    """the rows to be inserted"""
    objects: [order_tenant_invoice_insert_input!]!

    """upsert condition"""
    on_conflict: order_tenant_invoice_on_conflict
  ): order_tenant_invoice_mutation_response

  """
  insert a single row into the table: "order_tenant_invoice"
  """
  insert_order_tenant_invoice_one(
    """the row to be inserted"""
    object: order_tenant_invoice_insert_input!

    """upsert condition"""
    on_conflict: order_tenant_invoice_on_conflict
  ): order_tenant_invoice

  """
  insert a single row into the table: "order_tenant"
  """
  insert_order_tenant_one(
    """the row to be inserted"""
    object: order_tenant_insert_input!

    """upsert condition"""
    on_conflict: order_tenant_on_conflict
  ): order_tenant

  """
  insert data into the table: "payment_status"
  """
  insert_payment_status(
    """the rows to be inserted"""
    objects: [payment_status_insert_input!]!

    """upsert condition"""
    on_conflict: payment_status_on_conflict
  ): payment_status_mutation_response

  """
  insert a single row into the table: "payment_status"
  """
  insert_payment_status_one(
    """the row to be inserted"""
    object: payment_status_insert_input!

    """upsert condition"""
    on_conflict: payment_status_on_conflict
  ): payment_status

  """
  insert data into the table: "product"
  """
  insert_product(
    """the rows to be inserted"""
    objects: [product_insert_input!]!

    """upsert condition"""
    on_conflict: product_on_conflict
  ): product_mutation_response

  """
  insert data into the table: "product_category"
  """
  insert_product_category(
    """the rows to be inserted"""
    objects: [product_category_insert_input!]!

    """upsert condition"""
    on_conflict: product_category_on_conflict
  ): product_category_mutation_response

  """
  insert a single row into the table: "product_category"
  """
  insert_product_category_one(
    """the row to be inserted"""
    object: product_category_insert_input!

    """upsert condition"""
    on_conflict: product_category_on_conflict
  ): product_category

  """
  insert data into the table: "product_customizable_area"
  """
  insert_product_customizable_area(
    """the rows to be inserted"""
    objects: [product_customizable_area_insert_input!]!

    """upsert condition"""
    on_conflict: product_customizable_area_on_conflict
  ): product_customizable_area_mutation_response

  """
  insert a single row into the table: "product_customizable_area"
  """
  insert_product_customizable_area_one(
    """the row to be inserted"""
    object: product_customizable_area_insert_input!

    """upsert condition"""
    on_conflict: product_customizable_area_on_conflict
  ): product_customizable_area

  """
  insert data into the table: "product_delivery_city_info"
  """
  insert_product_delivery_city_info(
    """the rows to be inserted"""
    objects: [product_delivery_city_info_insert_input!]!
  ): product_delivery_city_info_mutation_response

  """
  insert a single row into the table: "product_delivery_city_info"
  """
  insert_product_delivery_city_info_one(
    """the row to be inserted"""
    object: product_delivery_city_info_insert_input!
  ): product_delivery_city_info

  """
  insert a single row into the table: "product"
  """
  insert_product_one(
    """the row to be inserted"""
    object: product_insert_input!

    """upsert condition"""
    on_conflict: product_on_conflict
  ): product

  """
  insert data into the table: "quarter"
  """
  insert_quarter(
    """the rows to be inserted"""
    objects: [quarter_insert_input!]!

    """upsert condition"""
    on_conflict: quarter_on_conflict
  ): quarter_mutation_response

  """
  insert a single row into the table: "quarter"
  """
  insert_quarter_one(
    """the row to be inserted"""
    object: quarter_insert_input!

    """upsert condition"""
    on_conflict: quarter_on_conflict
  ): quarter

  """
  insert data into the table: "question"
  """
  insert_question(
    """the rows to be inserted"""
    objects: [question_insert_input!]!

    """upsert condition"""
    on_conflict: question_on_conflict
  ): question_mutation_response

  """
  insert a single row into the table: "question"
  """
  insert_question_one(
    """the row to be inserted"""
    object: question_insert_input!

    """upsert condition"""
    on_conflict: question_on_conflict
  ): question

  """
  insert data into the table: "review"
  """
  insert_review(
    """the rows to be inserted"""
    objects: [review_insert_input!]!

    """upsert condition"""
    on_conflict: review_on_conflict
  ): review_mutation_response

  """
  insert a single row into the table: "review"
  """
  insert_review_one(
    """the row to be inserted"""
    object: review_insert_input!

    """upsert condition"""
    on_conflict: review_on_conflict
  ): review

  """
  insert data into the table: "role"
  """
  insert_role(
    """the rows to be inserted"""
    objects: [role_insert_input!]!

    """upsert condition"""
    on_conflict: role_on_conflict
  ): role_mutation_response

  """
  insert a single row into the table: "role"
  """
  insert_role_one(
    """the row to be inserted"""
    object: role_insert_input!

    """upsert condition"""
    on_conflict: role_on_conflict
  ): role

  """
  insert data into the table: "search_location_result"
  """
  insert_search_location_result(
    """the rows to be inserted"""
    objects: [search_location_result_insert_input!]!
  ): search_location_result_mutation_response

  """
  insert a single row into the table: "search_location_result"
  """
  insert_search_location_result_one(
    """the row to be inserted"""
    object: search_location_result_insert_input!
  ): search_location_result

  """
  insert data into the table: "session"
  """
  insert_session(
    """the rows to be inserted"""
    objects: [session_insert_input!]!

    """upsert condition"""
    on_conflict: session_on_conflict
  ): session_mutation_response

  """
  insert a single row into the table: "session"
  """
  insert_session_one(
    """the row to be inserted"""
    object: session_insert_input!

    """upsert condition"""
    on_conflict: session_on_conflict
  ): session

  """
  insert data into the table: "system_banner"
  """
  insert_system_banner(
    """the rows to be inserted"""
    objects: [system_banner_insert_input!]!

    """upsert condition"""
    on_conflict: system_banner_on_conflict
  ): system_banner_mutation_response

  """
  insert a single row into the table: "system_banner"
  """
  insert_system_banner_one(
    """the row to be inserted"""
    object: system_banner_insert_input!

    """upsert condition"""
    on_conflict: system_banner_on_conflict
  ): system_banner

  """
  insert data into the table: "tenant"
  """
  insert_tenant(
    """the rows to be inserted"""
    objects: [tenant_insert_input!]!

    """upsert condition"""
    on_conflict: tenant_on_conflict
  ): tenant_mutation_response

  """
  insert data into the table: "tenant_address"
  """
  insert_tenant_address(
    """the rows to be inserted"""
    objects: [tenant_address_insert_input!]!

    """upsert condition"""
    on_conflict: tenant_address_on_conflict
  ): tenant_address_mutation_response

  """
  insert a single row into the table: "tenant_address"
  """
  insert_tenant_address_one(
    """the row to be inserted"""
    object: tenant_address_insert_input!

    """upsert condition"""
    on_conflict: tenant_address_on_conflict
  ): tenant_address

  """
  insert data into the table: "tenant_category"
  """
  insert_tenant_category(
    """the rows to be inserted"""
    objects: [tenant_category_insert_input!]!

    """upsert condition"""
    on_conflict: tenant_category_on_conflict
  ): tenant_category_mutation_response

  """
  insert a single row into the table: "tenant_category"
  """
  insert_tenant_category_one(
    """the row to be inserted"""
    object: tenant_category_insert_input!

    """upsert condition"""
    on_conflict: tenant_category_on_conflict
  ): tenant_category

  """
  insert a single row into the table: "tenant"
  """
  insert_tenant_one(
    """the row to be inserted"""
    object: tenant_insert_input!

    """upsert condition"""
    on_conflict: tenant_on_conflict
  ): tenant

  """
  insert data into the table: "tenant_shipping_place"
  """
  insert_tenant_shipping_place(
    """the rows to be inserted"""
    objects: [tenant_shipping_place_insert_input!]!

    """upsert condition"""
    on_conflict: tenant_shipping_place_on_conflict
  ): tenant_shipping_place_mutation_response

  """
  insert a single row into the table: "tenant_shipping_place"
  """
  insert_tenant_shipping_place_one(
    """the row to be inserted"""
    object: tenant_shipping_place_insert_input!

    """upsert condition"""
    on_conflict: tenant_shipping_place_on_conflict
  ): tenant_shipping_place

  """
  insert data into the table: "ticket"
  """
  insert_ticket(
    """the rows to be inserted"""
    objects: [ticket_insert_input!]!

    """upsert condition"""
    on_conflict: ticket_on_conflict
  ): ticket_mutation_response

  """
  insert data into the table: "ticket_answer"
  """
  insert_ticket_answer(
    """the rows to be inserted"""
    objects: [ticket_answer_insert_input!]!

    """upsert condition"""
    on_conflict: ticket_answer_on_conflict
  ): ticket_answer_mutation_response

  """
  insert a single row into the table: "ticket_answer"
  """
  insert_ticket_answer_one(
    """the row to be inserted"""
    object: ticket_answer_insert_input!

    """upsert condition"""
    on_conflict: ticket_answer_on_conflict
  ): ticket_answer

  """
  insert a single row into the table: "ticket"
  """
  insert_ticket_one(
    """the row to be inserted"""
    object: ticket_insert_input!

    """upsert condition"""
    on_conflict: ticket_on_conflict
  ): ticket

  """
  insert data into the table: "ticket_status"
  """
  insert_ticket_status(
    """the rows to be inserted"""
    objects: [ticket_status_insert_input!]!

    """upsert condition"""
    on_conflict: ticket_status_on_conflict
  ): ticket_status_mutation_response

  """
  insert a single row into the table: "ticket_status"
  """
  insert_ticket_status_one(
    """the row to be inserted"""
    object: ticket_status_insert_input!

    """upsert condition"""
    on_conflict: ticket_status_on_conflict
  ): ticket_status

  """
  insert data into the table: "transaction"
  """
  insert_transaction(
    """the rows to be inserted"""
    objects: [transaction_insert_input!]!

    """upsert condition"""
    on_conflict: transaction_on_conflict
  ): transaction_mutation_response

  """
  insert a single row into the table: "transaction"
  """
  insert_transaction_one(
    """the row to be inserted"""
    object: transaction_insert_input!

    """upsert condition"""
    on_conflict: transaction_on_conflict
  ): transaction

  """
  insert data into the table: "user"
  """
  insert_user(
    """the rows to be inserted"""
    objects: [user_insert_input!]!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert data into the table: "user_address"
  """
  insert_user_address(
    """the rows to be inserted"""
    objects: [user_address_insert_input!]!

    """upsert condition"""
    on_conflict: user_address_on_conflict
  ): user_address_mutation_response

  """
  insert a single row into the table: "user_address"
  """
  insert_user_address_one(
    """the row to be inserted"""
    object: user_address_insert_input!

    """upsert condition"""
    on_conflict: user_address_on_conflict
  ): user_address

  """
  insert data into the table: "user_coupon"
  """
  insert_user_coupon(
    """the rows to be inserted"""
    objects: [user_coupon_insert_input!]!

    """upsert condition"""
    on_conflict: user_coupon_on_conflict
  ): user_coupon_mutation_response

  """
  insert a single row into the table: "user_coupon"
  """
  insert_user_coupon_one(
    """the row to be inserted"""
    object: user_coupon_insert_input!

    """upsert condition"""
    on_conflict: user_coupon_on_conflict
  ): user_coupon

  """
  insert data into the table: "user_favorite"
  """
  insert_user_favorite(
    """the rows to be inserted"""
    objects: [user_favorite_insert_input!]!

    """upsert condition"""
    on_conflict: user_favorite_on_conflict
  ): user_favorite_mutation_response

  """
  insert a single row into the table: "user_favorite"
  """
  insert_user_favorite_one(
    """the row to be inserted"""
    object: user_favorite_insert_input!

    """upsert condition"""
    on_conflict: user_favorite_on_conflict
  ): user_favorite

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """the row to be inserted"""
    object: user_insert_input!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user
  login(args: LoginInput!): LoginOutput
  refresh_token: RefreshTokenOutput
  register(args: RegisterInput!): RegisterOutput
  reset_password(args: ResetPasswordInput!): ResetPasswordOutput

  """
  update data of the table: "address_type"
  """
  update_address_type(
    """sets the columns of the filtered rows to the given values"""
    _set: address_type_set_input

    """filter the rows which have to be updated"""
    where: address_type_bool_exp!
  ): address_type_mutation_response

  """
  update single row of the table: "address_type"
  """
  update_address_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: address_type_set_input
    pk_columns: address_type_pk_columns_input!
  ): address_type

  """
  update multiples rows of table: "address_type"
  """
  update_address_type_many(
    """updates to execute, in order"""
    updates: [address_type_updates!]!
  ): [address_type_mutation_response]

  """
  update data of the table: "answer"
  """
  update_answer(
    """increments the numeric columns with given value of the filtered values"""
    _inc: answer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: answer_set_input

    """filter the rows which have to be updated"""
    where: answer_bool_exp!
  ): answer_mutation_response

  """
  update single row of the table: "answer"
  """
  update_answer_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: answer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: answer_set_input
    pk_columns: answer_pk_columns_input!
  ): answer

  """
  update multiples rows of table: "answer"
  """
  update_answer_many(
    """updates to execute, in order"""
    updates: [answer_updates!]!
  ): [answer_mutation_response]

  """
  update data of the table: "cart"
  """
  update_cart(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: cart_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: cart_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: cart_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: cart_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: cart_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: cart_set_input

    """filter the rows which have to be updated"""
    where: cart_bool_exp!
  ): cart_mutation_response

  """
  update single row of the table: "cart"
  """
  update_cart_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: cart_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: cart_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: cart_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: cart_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: cart_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: cart_set_input
    pk_columns: cart_pk_columns_input!
  ): cart

  """
  update multiples rows of table: "cart"
  """
  update_cart_many(
    """updates to execute, in order"""
    updates: [cart_updates!]!
  ): [cart_mutation_response]

  """
  update data of the table: "category"
  """
  update_category(
    """increments the numeric columns with given value of the filtered values"""
    _inc: category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: category_set_input

    """filter the rows which have to be updated"""
    where: category_bool_exp!
  ): category_mutation_response

  """
  update single row of the table: "category"
  """
  update_category_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: category_set_input
    pk_columns: category_pk_columns_input!
  ): category

  """
  update multiples rows of table: "category"
  """
  update_category_many(
    """updates to execute, in order"""
    updates: [category_updates!]!
  ): [category_mutation_response]

  """
  update data of the table: "chat_thread"
  """
  update_chat_thread(
    """increments the numeric columns with given value of the filtered values"""
    _inc: chat_thread_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: chat_thread_set_input

    """filter the rows which have to be updated"""
    where: chat_thread_bool_exp!
  ): chat_thread_mutation_response

  """
  update single row of the table: "chat_thread"
  """
  update_chat_thread_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: chat_thread_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: chat_thread_set_input
    pk_columns: chat_thread_pk_columns_input!
  ): chat_thread

  """
  update multiples rows of table: "chat_thread"
  """
  update_chat_thread_many(
    """updates to execute, in order"""
    updates: [chat_thread_updates!]!
  ): [chat_thread_mutation_response]

  """
  update data of the table: "city"
  """
  update_city(
    """increments the numeric columns with given value of the filtered values"""
    _inc: city_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: city_set_input

    """filter the rows which have to be updated"""
    where: city_bool_exp!
  ): city_mutation_response

  """
  update single row of the table: "city"
  """
  update_city_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: city_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: city_set_input
    pk_columns: city_pk_columns_input!
  ): city

  """
  update multiples rows of table: "city"
  """
  update_city_many(
    """updates to execute, in order"""
    updates: [city_updates!]!
  ): [city_mutation_response]

  """
  update data of the table: "company"
  """
  update_company(
    """sets the columns of the filtered rows to the given values"""
    _set: company_set_input

    """filter the rows which have to be updated"""
    where: company_bool_exp!
  ): company_mutation_response

  """
  update single row of the table: "company"
  """
  update_company_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: company_set_input
    pk_columns: company_pk_columns_input!
  ): company

  """
  update data of the table: "company_category"
  """
  update_company_category(
    """increments the numeric columns with given value of the filtered values"""
    _inc: company_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: company_category_set_input

    """filter the rows which have to be updated"""
    where: company_category_bool_exp!
  ): company_category_mutation_response

  """
  update single row of the table: "company_category"
  """
  update_company_category_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: company_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: company_category_set_input
    pk_columns: company_category_pk_columns_input!
  ): company_category

  """
  update multiples rows of table: "company_category"
  """
  update_company_category_many(
    """updates to execute, in order"""
    updates: [company_category_updates!]!
  ): [company_category_mutation_response]

  """
  update multiples rows of table: "company"
  """
  update_company_many(
    """updates to execute, in order"""
    updates: [company_updates!]!
  ): [company_mutation_response]

  """
  update data of the table: "company_type"
  """
  update_company_type(
    """sets the columns of the filtered rows to the given values"""
    _set: company_type_set_input

    """filter the rows which have to be updated"""
    where: company_type_bool_exp!
  ): company_type_mutation_response

  """
  update single row of the table: "company_type"
  """
  update_company_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: company_type_set_input
    pk_columns: company_type_pk_columns_input!
  ): company_type

  """
  update multiples rows of table: "company_type"
  """
  update_company_type_many(
    """updates to execute, in order"""
    updates: [company_type_updates!]!
  ): [company_type_mutation_response]

  """
  update data of the table: "coupon"
  """
  update_coupon(
    """increments the numeric columns with given value of the filtered values"""
    _inc: coupon_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: coupon_set_input

    """filter the rows which have to be updated"""
    where: coupon_bool_exp!
  ): coupon_mutation_response

  """
  update single row of the table: "coupon"
  """
  update_coupon_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: coupon_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: coupon_set_input
    pk_columns: coupon_pk_columns_input!
  ): coupon

  """
  update multiples rows of table: "coupon"
  """
  update_coupon_many(
    """updates to execute, in order"""
    updates: [coupon_updates!]!
  ): [coupon_mutation_response]

  """
  update data of the table: "customizable_area"
  """
  update_customizable_area(
    """increments the numeric columns with given value of the filtered values"""
    _inc: customizable_area_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customizable_area_set_input

    """filter the rows which have to be updated"""
    where: customizable_area_bool_exp!
  ): customizable_area_mutation_response

  """
  update single row of the table: "customizable_area"
  """
  update_customizable_area_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: customizable_area_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: customizable_area_set_input
    pk_columns: customizable_area_pk_columns_input!
  ): customizable_area

  """
  update multiples rows of table: "customizable_area"
  """
  update_customizable_area_many(
    """updates to execute, in order"""
    updates: [customizable_area_updates!]!
  ): [customizable_area_mutation_response]

  """
  update data of the table: "delivery_type"
  """
  update_delivery_type(
    """sets the columns of the filtered rows to the given values"""
    _set: delivery_type_set_input

    """filter the rows which have to be updated"""
    where: delivery_type_bool_exp!
  ): delivery_type_mutation_response

  """
  update single row of the table: "delivery_type"
  """
  update_delivery_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: delivery_type_set_input
    pk_columns: delivery_type_pk_columns_input!
  ): delivery_type

  """
  update multiples rows of table: "delivery_type"
  """
  update_delivery_type_many(
    """updates to execute, in order"""
    updates: [delivery_type_updates!]!
  ): [delivery_type_mutation_response]

  """
  update data of the table: "district"
  """
  update_district(
    """increments the numeric columns with given value of the filtered values"""
    _inc: district_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: district_set_input

    """filter the rows which have to be updated"""
    where: district_bool_exp!
  ): district_mutation_response

  """
  update single row of the table: "district"
  """
  update_district_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: district_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: district_set_input
    pk_columns: district_pk_columns_input!
  ): district

  """
  update multiples rows of table: "district"
  """
  update_district_many(
    """updates to execute, in order"""
    updates: [district_updates!]!
  ): [district_mutation_response]

  """
  update data of the table: "message"
  """
  update_message(
    """increments the numeric columns with given value of the filtered values"""
    _inc: message_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: message_set_input

    """filter the rows which have to be updated"""
    where: message_bool_exp!
  ): message_mutation_response

  """
  update single row of the table: "message"
  """
  update_message_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: message_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: message_set_input
    pk_columns: message_pk_columns_input!
  ): message

  """
  update multiples rows of table: "message"
  """
  update_message_many(
    """updates to execute, in order"""
    updates: [message_updates!]!
  ): [message_mutation_response]

  """
  update data of the table: "order"
  """
  update_order(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_set_input

    """filter the rows which have to be updated"""
    where: order_bool_exp!
  ): order_mutation_response

  """
  update data of the table: "order_address"
  """
  update_order_address(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_address_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_address_set_input

    """filter the rows which have to be updated"""
    where: order_address_bool_exp!
  ): order_address_mutation_response

  """
  update single row of the table: "order_address"
  """
  update_order_address_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_address_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_address_set_input
    pk_columns: order_address_pk_columns_input!
  ): order_address

  """
  update multiples rows of table: "order_address"
  """
  update_order_address_many(
    """updates to execute, in order"""
    updates: [order_address_updates!]!
  ): [order_address_mutation_response]

  """
  update single row of the table: "order"
  """
  update_order_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_set_input
    pk_columns: order_pk_columns_input!
  ): order

  """
  update data of the table: "order_item"
  """
  update_order_item(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_item_set_input

    """filter the rows which have to be updated"""
    where: order_item_bool_exp!
  ): order_item_mutation_response

  """
  update single row of the table: "order_item"
  """
  update_order_item_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_item_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_item_set_input
    pk_columns: order_item_pk_columns_input!
  ): order_item

  """
  update multiples rows of table: "order_item"
  """
  update_order_item_many(
    """updates to execute, in order"""
    updates: [order_item_updates!]!
  ): [order_item_mutation_response]

  """
  update data of the table: "order_item_special_image"
  """
  update_order_item_special_image(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_item_special_image_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_item_special_image_set_input

    """filter the rows which have to be updated"""
    where: order_item_special_image_bool_exp!
  ): order_item_special_image_mutation_response

  """
  update single row of the table: "order_item_special_image"
  """
  update_order_item_special_image_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_item_special_image_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_item_special_image_set_input
    pk_columns: order_item_special_image_pk_columns_input!
  ): order_item_special_image

  """
  update multiples rows of table: "order_item_special_image"
  """
  update_order_item_special_image_many(
    """updates to execute, in order"""
    updates: [order_item_special_image_updates!]!
  ): [order_item_special_image_mutation_response]

  """
  update data of the table: "order_item_special_text"
  """
  update_order_item_special_text(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_item_special_text_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_item_special_text_set_input

    """filter the rows which have to be updated"""
    where: order_item_special_text_bool_exp!
  ): order_item_special_text_mutation_response

  """
  update single row of the table: "order_item_special_text"
  """
  update_order_item_special_text_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_item_special_text_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_item_special_text_set_input
    pk_columns: order_item_special_text_pk_columns_input!
  ): order_item_special_text

  """
  update multiples rows of table: "order_item_special_text"
  """
  update_order_item_special_text_many(
    """updates to execute, in order"""
    updates: [order_item_special_text_updates!]!
  ): [order_item_special_text_mutation_response]

  """
  update multiples rows of table: "order"
  """
  update_order_many(
    """updates to execute, in order"""
    updates: [order_updates!]!
  ): [order_mutation_response]

  """
  update data of the table: "order_status"
  """
  update_order_status(
    """sets the columns of the filtered rows to the given values"""
    _set: order_status_set_input

    """filter the rows which have to be updated"""
    where: order_status_bool_exp!
  ): order_status_mutation_response

  """
  update single row of the table: "order_status"
  """
  update_order_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: order_status_set_input
    pk_columns: order_status_pk_columns_input!
  ): order_status

  """
  update multiples rows of table: "order_status"
  """
  update_order_status_many(
    """updates to execute, in order"""
    updates: [order_status_updates!]!
  ): [order_status_mutation_response]

  """
  update data of the table: "order_tenant"
  """
  update_order_tenant(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_tenant_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_tenant_set_input

    """filter the rows which have to be updated"""
    where: order_tenant_bool_exp!
  ): order_tenant_mutation_response

  """
  update single row of the table: "order_tenant"
  """
  update_order_tenant_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_tenant_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_tenant_set_input
    pk_columns: order_tenant_pk_columns_input!
  ): order_tenant

  """
  update data of the table: "order_tenant_invoice"
  """
  update_order_tenant_invoice(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_tenant_invoice_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_tenant_invoice_set_input

    """filter the rows which have to be updated"""
    where: order_tenant_invoice_bool_exp!
  ): order_tenant_invoice_mutation_response

  """
  update single row of the table: "order_tenant_invoice"
  """
  update_order_tenant_invoice_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: order_tenant_invoice_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: order_tenant_invoice_set_input
    pk_columns: order_tenant_invoice_pk_columns_input!
  ): order_tenant_invoice

  """
  update multiples rows of table: "order_tenant_invoice"
  """
  update_order_tenant_invoice_many(
    """updates to execute, in order"""
    updates: [order_tenant_invoice_updates!]!
  ): [order_tenant_invoice_mutation_response]

  """
  update multiples rows of table: "order_tenant"
  """
  update_order_tenant_many(
    """updates to execute, in order"""
    updates: [order_tenant_updates!]!
  ): [order_tenant_mutation_response]

  """
  update data of the table: "payment_status"
  """
  update_payment_status(
    """sets the columns of the filtered rows to the given values"""
    _set: payment_status_set_input

    """filter the rows which have to be updated"""
    where: payment_status_bool_exp!
  ): payment_status_mutation_response

  """
  update single row of the table: "payment_status"
  """
  update_payment_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: payment_status_set_input
    pk_columns: payment_status_pk_columns_input!
  ): payment_status

  """
  update multiples rows of table: "payment_status"
  """
  update_payment_status_many(
    """updates to execute, in order"""
    updates: [payment_status_updates!]!
  ): [payment_status_mutation_response]

  """
  update data of the table: "product"
  """
  update_product(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: product_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: product_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: product_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: product_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: product_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: product_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_set_input

    """filter the rows which have to be updated"""
    where: product_bool_exp!
  ): product_mutation_response

  """
  update single row of the table: "product"
  """
  update_product_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: product_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: product_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: product_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: product_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: product_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: product_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_set_input
    pk_columns: product_pk_columns_input!
  ): product

  """
  update data of the table: "product_category"
  """
  update_product_category(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_category_set_input

    """filter the rows which have to be updated"""
    where: product_category_bool_exp!
  ): product_category_mutation_response

  """
  update single row of the table: "product_category"
  """
  update_product_category_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_category_set_input
    pk_columns: product_category_pk_columns_input!
  ): product_category

  """
  update multiples rows of table: "product_category"
  """
  update_product_category_many(
    """updates to execute, in order"""
    updates: [product_category_updates!]!
  ): [product_category_mutation_response]

  """
  update data of the table: "product_customizable_area"
  """
  update_product_customizable_area(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_customizable_area_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_customizable_area_set_input

    """filter the rows which have to be updated"""
    where: product_customizable_area_bool_exp!
  ): product_customizable_area_mutation_response

  """
  update single row of the table: "product_customizable_area"
  """
  update_product_customizable_area_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_customizable_area_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_customizable_area_set_input
    pk_columns: product_customizable_area_pk_columns_input!
  ): product_customizable_area

  """
  update multiples rows of table: "product_customizable_area"
  """
  update_product_customizable_area_many(
    """updates to execute, in order"""
    updates: [product_customizable_area_updates!]!
  ): [product_customizable_area_mutation_response]

  """
  update data of the table: "product_delivery_city_info"
  """
  update_product_delivery_city_info(
    """increments the numeric columns with given value of the filtered values"""
    _inc: product_delivery_city_info_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: product_delivery_city_info_set_input

    """filter the rows which have to be updated"""
    where: product_delivery_city_info_bool_exp!
  ): product_delivery_city_info_mutation_response

  """
  update multiples rows of table: "product_delivery_city_info"
  """
  update_product_delivery_city_info_many(
    """updates to execute, in order"""
    updates: [product_delivery_city_info_updates!]!
  ): [product_delivery_city_info_mutation_response]

  """
  update multiples rows of table: "product"
  """
  update_product_many(
    """updates to execute, in order"""
    updates: [product_updates!]!
  ): [product_mutation_response]

  """
  update data of the table: "quarter"
  """
  update_quarter(
    """increments the numeric columns with given value of the filtered values"""
    _inc: quarter_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: quarter_set_input

    """filter the rows which have to be updated"""
    where: quarter_bool_exp!
  ): quarter_mutation_response

  """
  update single row of the table: "quarter"
  """
  update_quarter_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: quarter_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: quarter_set_input
    pk_columns: quarter_pk_columns_input!
  ): quarter

  """
  update multiples rows of table: "quarter"
  """
  update_quarter_many(
    """updates to execute, in order"""
    updates: [quarter_updates!]!
  ): [quarter_mutation_response]

  """
  update data of the table: "question"
  """
  update_question(
    """increments the numeric columns with given value of the filtered values"""
    _inc: question_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: question_set_input

    """filter the rows which have to be updated"""
    where: question_bool_exp!
  ): question_mutation_response

  """
  update single row of the table: "question"
  """
  update_question_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: question_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: question_set_input
    pk_columns: question_pk_columns_input!
  ): question

  """
  update multiples rows of table: "question"
  """
  update_question_many(
    """updates to execute, in order"""
    updates: [question_updates!]!
  ): [question_mutation_response]

  """
  update data of the table: "review"
  """
  update_review(
    """increments the numeric columns with given value of the filtered values"""
    _inc: review_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: review_set_input

    """filter the rows which have to be updated"""
    where: review_bool_exp!
  ): review_mutation_response

  """
  update single row of the table: "review"
  """
  update_review_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: review_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: review_set_input
    pk_columns: review_pk_columns_input!
  ): review

  """
  update multiples rows of table: "review"
  """
  update_review_many(
    """updates to execute, in order"""
    updates: [review_updates!]!
  ): [review_mutation_response]

  """
  update data of the table: "role"
  """
  update_role(
    """sets the columns of the filtered rows to the given values"""
    _set: role_set_input

    """filter the rows which have to be updated"""
    where: role_bool_exp!
  ): role_mutation_response

  """
  update single row of the table: "role"
  """
  update_role_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: role_set_input
    pk_columns: role_pk_columns_input!
  ): role

  """
  update multiples rows of table: "role"
  """
  update_role_many(
    """updates to execute, in order"""
    updates: [role_updates!]!
  ): [role_mutation_response]

  """
  update data of the table: "search_location_result"
  """
  update_search_location_result(
    """increments the numeric columns with given value of the filtered values"""
    _inc: search_location_result_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: search_location_result_set_input

    """filter the rows which have to be updated"""
    where: search_location_result_bool_exp!
  ): search_location_result_mutation_response

  """
  update multiples rows of table: "search_location_result"
  """
  update_search_location_result_many(
    """updates to execute, in order"""
    updates: [search_location_result_updates!]!
  ): [search_location_result_mutation_response]

  """
  update data of the table: "session"
  """
  update_session(
    """sets the columns of the filtered rows to the given values"""
    _set: session_set_input

    """filter the rows which have to be updated"""
    where: session_bool_exp!
  ): session_mutation_response

  """
  update single row of the table: "session"
  """
  update_session_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: session_set_input
    pk_columns: session_pk_columns_input!
  ): session

  """
  update multiples rows of table: "session"
  """
  update_session_many(
    """updates to execute, in order"""
    updates: [session_updates!]!
  ): [session_mutation_response]

  """
  update data of the table: "system_banner"
  """
  update_system_banner(
    """sets the columns of the filtered rows to the given values"""
    _set: system_banner_set_input

    """filter the rows which have to be updated"""
    where: system_banner_bool_exp!
  ): system_banner_mutation_response

  """
  update single row of the table: "system_banner"
  """
  update_system_banner_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: system_banner_set_input
    pk_columns: system_banner_pk_columns_input!
  ): system_banner

  """
  update multiples rows of table: "system_banner"
  """
  update_system_banner_many(
    """updates to execute, in order"""
    updates: [system_banner_updates!]!
  ): [system_banner_mutation_response]

  """
  update data of the table: "tenant"
  """
  update_tenant(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tenant_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tenant_set_input

    """filter the rows which have to be updated"""
    where: tenant_bool_exp!
  ): tenant_mutation_response

  """
  update data of the table: "tenant_address"
  """
  update_tenant_address(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tenant_address_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tenant_address_set_input

    """filter the rows which have to be updated"""
    where: tenant_address_bool_exp!
  ): tenant_address_mutation_response

  """
  update single row of the table: "tenant_address"
  """
  update_tenant_address_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tenant_address_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tenant_address_set_input
    pk_columns: tenant_address_pk_columns_input!
  ): tenant_address

  """
  update multiples rows of table: "tenant_address"
  """
  update_tenant_address_many(
    """updates to execute, in order"""
    updates: [tenant_address_updates!]!
  ): [tenant_address_mutation_response]

  """
  update single row of the table: "tenant"
  """
  update_tenant_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tenant_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tenant_set_input
    pk_columns: tenant_pk_columns_input!
  ): tenant

  """
  update data of the table: "tenant_category"
  """
  update_tenant_category(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tenant_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tenant_category_set_input

    """filter the rows which have to be updated"""
    where: tenant_category_bool_exp!
  ): tenant_category_mutation_response

  """
  update single row of the table: "tenant_category"
  """
  update_tenant_category_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tenant_category_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tenant_category_set_input
    pk_columns: tenant_category_pk_columns_input!
  ): tenant_category

  """
  update multiples rows of table: "tenant_category"
  """
  update_tenant_category_many(
    """updates to execute, in order"""
    updates: [tenant_category_updates!]!
  ): [tenant_category_mutation_response]

  """
  update multiples rows of table: "tenant"
  """
  update_tenant_many(
    """updates to execute, in order"""
    updates: [tenant_updates!]!
  ): [tenant_mutation_response]

  """
  update data of the table: "tenant_shipping_place"
  """
  update_tenant_shipping_place(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tenant_shipping_place_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tenant_shipping_place_set_input

    """filter the rows which have to be updated"""
    where: tenant_shipping_place_bool_exp!
  ): tenant_shipping_place_mutation_response

  """
  update single row of the table: "tenant_shipping_place"
  """
  update_tenant_shipping_place_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: tenant_shipping_place_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: tenant_shipping_place_set_input
    pk_columns: tenant_shipping_place_pk_columns_input!
  ): tenant_shipping_place

  """
  update multiples rows of table: "tenant_shipping_place"
  """
  update_tenant_shipping_place_many(
    """updates to execute, in order"""
    updates: [tenant_shipping_place_updates!]!
  ): [tenant_shipping_place_mutation_response]

  """
  update data of the table: "ticket"
  """
  update_ticket(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ticket_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ticket_set_input

    """filter the rows which have to be updated"""
    where: ticket_bool_exp!
  ): ticket_mutation_response

  """
  update data of the table: "ticket_answer"
  """
  update_ticket_answer(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ticket_answer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ticket_answer_set_input

    """filter the rows which have to be updated"""
    where: ticket_answer_bool_exp!
  ): ticket_answer_mutation_response

  """
  update single row of the table: "ticket_answer"
  """
  update_ticket_answer_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ticket_answer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ticket_answer_set_input
    pk_columns: ticket_answer_pk_columns_input!
  ): ticket_answer

  """
  update multiples rows of table: "ticket_answer"
  """
  update_ticket_answer_many(
    """updates to execute, in order"""
    updates: [ticket_answer_updates!]!
  ): [ticket_answer_mutation_response]

  """
  update single row of the table: "ticket"
  """
  update_ticket_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ticket_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ticket_set_input
    pk_columns: ticket_pk_columns_input!
  ): ticket

  """
  update multiples rows of table: "ticket"
  """
  update_ticket_many(
    """updates to execute, in order"""
    updates: [ticket_updates!]!
  ): [ticket_mutation_response]

  """
  update data of the table: "ticket_status"
  """
  update_ticket_status(
    """sets the columns of the filtered rows to the given values"""
    _set: ticket_status_set_input

    """filter the rows which have to be updated"""
    where: ticket_status_bool_exp!
  ): ticket_status_mutation_response

  """
  update single row of the table: "ticket_status"
  """
  update_ticket_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: ticket_status_set_input
    pk_columns: ticket_status_pk_columns_input!
  ): ticket_status

  """
  update multiples rows of table: "ticket_status"
  """
  update_ticket_status_many(
    """updates to execute, in order"""
    updates: [ticket_status_updates!]!
  ): [ticket_status_mutation_response]

  """
  update data of the table: "transaction"
  """
  update_transaction(
    """sets the columns of the filtered rows to the given values"""
    _set: transaction_set_input

    """filter the rows which have to be updated"""
    where: transaction_bool_exp!
  ): transaction_mutation_response

  """
  update single row of the table: "transaction"
  """
  update_transaction_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: transaction_set_input
    pk_columns: transaction_pk_columns_input!
  ): transaction

  """
  update multiples rows of table: "transaction"
  """
  update_transaction_many(
    """updates to execute, in order"""
    updates: [transaction_updates!]!
  ): [transaction_mutation_response]

  """
  update data of the table: "user"
  """
  update_user(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update data of the table: "user_address"
  """
  update_user_address(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_address_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_address_set_input

    """filter the rows which have to be updated"""
    where: user_address_bool_exp!
  ): user_address_mutation_response

  """
  update single row of the table: "user_address"
  """
  update_user_address_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_address_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_address_set_input
    pk_columns: user_address_pk_columns_input!
  ): user_address

  """
  update multiples rows of table: "user_address"
  """
  update_user_address_many(
    """updates to execute, in order"""
    updates: [user_address_updates!]!
  ): [user_address_mutation_response]

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  update data of the table: "user_coupon"
  """
  update_user_coupon(
    """sets the columns of the filtered rows to the given values"""
    _set: user_coupon_set_input

    """filter the rows which have to be updated"""
    where: user_coupon_bool_exp!
  ): user_coupon_mutation_response

  """
  update single row of the table: "user_coupon"
  """
  update_user_coupon_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_coupon_set_input
    pk_columns: user_coupon_pk_columns_input!
  ): user_coupon

  """
  update multiples rows of table: "user_coupon"
  """
  update_user_coupon_many(
    """updates to execute, in order"""
    updates: [user_coupon_updates!]!
  ): [user_coupon_mutation_response]

  """
  update data of the table: "user_favorite"
  """
  update_user_favorite(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_favorite_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_favorite_set_input

    """filter the rows which have to be updated"""
    where: user_favorite_bool_exp!
  ): user_favorite_mutation_response

  """
  update single row of the table: "user_favorite"
  """
  update_user_favorite_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_favorite_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_favorite_set_input
    pk_columns: user_favorite_pk_columns_input!
  ): user_favorite

  """
  update multiples rows of table: "user_favorite"
  """
  update_user_favorite_many(
    """updates to execute, in order"""
    updates: [user_favorite_updates!]!
  ): [user_favorite_mutation_response]

  """
  update multiples rows of table: "user"
  """
  update_user_many(
    """updates to execute, in order"""
    updates: [user_updates!]!
  ): [user_mutation_response]
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""
columns and relationships of "order"
"""
type order {
  created_at: timestamptz!
  guest_id: uuid
  id: uuid!

  """An array relationship"""
  order_addresses(
    """distinct select on columns"""
    distinct_on: [order_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_address_order_by!]

    """filter the rows returned"""
    where: order_address_bool_exp
  ): [order_address!]!

  """An aggregate relationship"""
  order_addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [order_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_address_order_by!]

    """filter the rows returned"""
    where: order_address_bool_exp
  ): order_address_aggregate!
  order_no: bigint
  paymentConversationId: String
  payment_status: payment_status_enum

  """An object relationship"""
  payment_status_relation: payment_status
  sender_mail: String
  sender_phone: String

  """An array relationship"""
  tenant_orders(
    """distinct select on columns"""
    distinct_on: [order_tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_tenant_order_by!]

    """filter the rows returned"""
    where: order_tenant_bool_exp
  ): [order_tenant!]!

  """An aggregate relationship"""
  tenant_orders_aggregate(
    """distinct select on columns"""
    distinct_on: [order_tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_tenant_order_by!]

    """filter the rows returned"""
    where: order_tenant_bool_exp
  ): order_tenant_aggregate!
  total_amount: numeric!

  """An array relationship"""
  transactions(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """An aggregate relationship"""
  transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): transaction_aggregate!
  updated_at: timestamptz!

  """An object relationship"""
  user: user

  """An array relationship"""
  user_coupons(
    """distinct select on columns"""
    distinct_on: [user_coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_coupon_order_by!]

    """filter the rows returned"""
    where: user_coupon_bool_exp
  ): [user_coupon!]!

  """An aggregate relationship"""
  user_coupons_aggregate(
    """distinct select on columns"""
    distinct_on: [user_coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_coupon_order_by!]

    """filter the rows returned"""
    where: user_coupon_bool_exp
  ): user_coupon_aggregate!
  user_id: uuid
}

"""
columns and relationships of "order_address"
"""
type order_address {
  address: String!
  address_title: String!

  """An object relationship"""
  city: city!
  city_id: Int!

  """An object relationship"""
  district: district!
  district_id: Int!
  id: Int!

  """An object relationship"""
  order: order!
  order_id: uuid!

  """An object relationship"""
  quarter: quarter!
  quarter_id: Int!
  receiver_firstname: String!
  receiver_phone: String!
  receiver_surname: String!
}

"""
aggregated selection of "order_address"
"""
type order_address_aggregate {
  aggregate: order_address_aggregate_fields
  nodes: [order_address!]!
}

input order_address_aggregate_bool_exp {
  count: order_address_aggregate_bool_exp_count
}

input order_address_aggregate_bool_exp_count {
  arguments: [order_address_select_column!]
  distinct: Boolean
  filter: order_address_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "order_address"
"""
type order_address_aggregate_fields {
  avg: order_address_avg_fields
  count(columns: [order_address_select_column!], distinct: Boolean): Int!
  max: order_address_max_fields
  min: order_address_min_fields
  stddev: order_address_stddev_fields
  stddev_pop: order_address_stddev_pop_fields
  stddev_samp: order_address_stddev_samp_fields
  sum: order_address_sum_fields
  var_pop: order_address_var_pop_fields
  var_samp: order_address_var_samp_fields
  variance: order_address_variance_fields
}

"""
order by aggregate values of table "order_address"
"""
input order_address_aggregate_order_by {
  avg: order_address_avg_order_by
  count: order_by
  max: order_address_max_order_by
  min: order_address_min_order_by
  stddev: order_address_stddev_order_by
  stddev_pop: order_address_stddev_pop_order_by
  stddev_samp: order_address_stddev_samp_order_by
  sum: order_address_sum_order_by
  var_pop: order_address_var_pop_order_by
  var_samp: order_address_var_samp_order_by
  variance: order_address_variance_order_by
}

"""
input type for inserting array relation for remote table "order_address"
"""
input order_address_arr_rel_insert_input {
  data: [order_address_insert_input!]!

  """upsert condition"""
  on_conflict: order_address_on_conflict
}

"""aggregate avg on columns"""
type order_address_avg_fields {
  city_id: Float
  district_id: Float
  id: Float
  quarter_id: Float
}

"""
order by avg() on columns of table "order_address"
"""
input order_address_avg_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""
Boolean expression to filter rows from the table "order_address". All fields are combined with a logical 'AND'.
"""
input order_address_bool_exp {
  _and: [order_address_bool_exp!]
  _not: order_address_bool_exp
  _or: [order_address_bool_exp!]
  address: String_comparison_exp
  address_title: String_comparison_exp
  city: city_bool_exp
  city_id: Int_comparison_exp
  district: district_bool_exp
  district_id: Int_comparison_exp
  id: Int_comparison_exp
  order: order_bool_exp
  order_id: uuid_comparison_exp
  quarter: quarter_bool_exp
  quarter_id: Int_comparison_exp
  receiver_firstname: String_comparison_exp
  receiver_phone: String_comparison_exp
  receiver_surname: String_comparison_exp
}

"""
unique or primary key constraints on table "order_address"
"""
enum order_address_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  order_address_pkey
}

"""
input type for incrementing numeric columns in table "order_address"
"""
input order_address_inc_input {
  city_id: Int
  district_id: Int
  id: Int
  quarter_id: Int
}

"""
input type for inserting data into table "order_address"
"""
input order_address_insert_input {
  address: String
  address_title: String
  city: city_obj_rel_insert_input
  city_id: Int
  district: district_obj_rel_insert_input
  district_id: Int
  id: Int
  order: order_obj_rel_insert_input
  order_id: uuid
  quarter: quarter_obj_rel_insert_input
  quarter_id: Int
  receiver_firstname: String
  receiver_phone: String
  receiver_surname: String
}

"""aggregate max on columns"""
type order_address_max_fields {
  address: String
  address_title: String
  city_id: Int
  district_id: Int
  id: Int
  order_id: uuid
  quarter_id: Int
  receiver_firstname: String
  receiver_phone: String
  receiver_surname: String
}

"""
order by max() on columns of table "order_address"
"""
input order_address_max_order_by {
  address: order_by
  address_title: order_by
  city_id: order_by
  district_id: order_by
  id: order_by
  order_id: order_by
  quarter_id: order_by
  receiver_firstname: order_by
  receiver_phone: order_by
  receiver_surname: order_by
}

"""aggregate min on columns"""
type order_address_min_fields {
  address: String
  address_title: String
  city_id: Int
  district_id: Int
  id: Int
  order_id: uuid
  quarter_id: Int
  receiver_firstname: String
  receiver_phone: String
  receiver_surname: String
}

"""
order by min() on columns of table "order_address"
"""
input order_address_min_order_by {
  address: order_by
  address_title: order_by
  city_id: order_by
  district_id: order_by
  id: order_by
  order_id: order_by
  quarter_id: order_by
  receiver_firstname: order_by
  receiver_phone: order_by
  receiver_surname: order_by
}

"""
response of any mutation on the table "order_address"
"""
type order_address_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [order_address!]!
}

"""
on_conflict condition type for table "order_address"
"""
input order_address_on_conflict {
  constraint: order_address_constraint!
  update_columns: [order_address_update_column!]! = []
  where: order_address_bool_exp
}

"""Ordering options when selecting data from "order_address"."""
input order_address_order_by {
  address: order_by
  address_title: order_by
  city: city_order_by
  city_id: order_by
  district: district_order_by
  district_id: order_by
  id: order_by
  order: order_order_by
  order_id: order_by
  quarter: quarter_order_by
  quarter_id: order_by
  receiver_firstname: order_by
  receiver_phone: order_by
  receiver_surname: order_by
}

"""primary key columns input for table: order_address"""
input order_address_pk_columns_input {
  id: Int!
}

"""
select columns of table "order_address"
"""
enum order_address_select_column {
  """column name"""
  address

  """column name"""
  address_title

  """column name"""
  city_id

  """column name"""
  district_id

  """column name"""
  id

  """column name"""
  order_id

  """column name"""
  quarter_id

  """column name"""
  receiver_firstname

  """column name"""
  receiver_phone

  """column name"""
  receiver_surname
}

"""
input type for updating data in table "order_address"
"""
input order_address_set_input {
  address: String
  address_title: String
  city_id: Int
  district_id: Int
  id: Int
  order_id: uuid
  quarter_id: Int
  receiver_firstname: String
  receiver_phone: String
  receiver_surname: String
}

"""aggregate stddev on columns"""
type order_address_stddev_fields {
  city_id: Float
  district_id: Float
  id: Float
  quarter_id: Float
}

"""
order by stddev() on columns of table "order_address"
"""
input order_address_stddev_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""aggregate stddev_pop on columns"""
type order_address_stddev_pop_fields {
  city_id: Float
  district_id: Float
  id: Float
  quarter_id: Float
}

"""
order by stddev_pop() on columns of table "order_address"
"""
input order_address_stddev_pop_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""aggregate stddev_samp on columns"""
type order_address_stddev_samp_fields {
  city_id: Float
  district_id: Float
  id: Float
  quarter_id: Float
}

"""
order by stddev_samp() on columns of table "order_address"
"""
input order_address_stddev_samp_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""
Streaming cursor of the table "order_address"
"""
input order_address_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: order_address_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input order_address_stream_cursor_value_input {
  address: String
  address_title: String
  city_id: Int
  district_id: Int
  id: Int
  order_id: uuid
  quarter_id: Int
  receiver_firstname: String
  receiver_phone: String
  receiver_surname: String
}

"""aggregate sum on columns"""
type order_address_sum_fields {
  city_id: Int
  district_id: Int
  id: Int
  quarter_id: Int
}

"""
order by sum() on columns of table "order_address"
"""
input order_address_sum_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""
update columns of table "order_address"
"""
enum order_address_update_column {
  """column name"""
  address

  """column name"""
  address_title

  """column name"""
  city_id

  """column name"""
  district_id

  """column name"""
  id

  """column name"""
  order_id

  """column name"""
  quarter_id

  """column name"""
  receiver_firstname

  """column name"""
  receiver_phone

  """column name"""
  receiver_surname
}

input order_address_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: order_address_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: order_address_set_input

  """filter the rows which have to be updated"""
  where: order_address_bool_exp!
}

"""aggregate var_pop on columns"""
type order_address_var_pop_fields {
  city_id: Float
  district_id: Float
  id: Float
  quarter_id: Float
}

"""
order by var_pop() on columns of table "order_address"
"""
input order_address_var_pop_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""aggregate var_samp on columns"""
type order_address_var_samp_fields {
  city_id: Float
  district_id: Float
  id: Float
  quarter_id: Float
}

"""
order by var_samp() on columns of table "order_address"
"""
input order_address_var_samp_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""aggregate variance on columns"""
type order_address_variance_fields {
  city_id: Float
  district_id: Float
  id: Float
  quarter_id: Float
}

"""
order by variance() on columns of table "order_address"
"""
input order_address_variance_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""
aggregated selection of "order"
"""
type order_aggregate {
  aggregate: order_aggregate_fields
  nodes: [order!]!
}

input order_aggregate_bool_exp {
  count: order_aggregate_bool_exp_count
}

input order_aggregate_bool_exp_count {
  arguments: [order_select_column!]
  distinct: Boolean
  filter: order_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "order"
"""
type order_aggregate_fields {
  avg: order_avg_fields
  count(columns: [order_select_column!], distinct: Boolean): Int!
  max: order_max_fields
  min: order_min_fields
  stddev: order_stddev_fields
  stddev_pop: order_stddev_pop_fields
  stddev_samp: order_stddev_samp_fields
  sum: order_sum_fields
  var_pop: order_var_pop_fields
  var_samp: order_var_samp_fields
  variance: order_variance_fields
}

"""
order by aggregate values of table "order"
"""
input order_aggregate_order_by {
  avg: order_avg_order_by
  count: order_by
  max: order_max_order_by
  min: order_min_order_by
  stddev: order_stddev_order_by
  stddev_pop: order_stddev_pop_order_by
  stddev_samp: order_stddev_samp_order_by
  sum: order_sum_order_by
  var_pop: order_var_pop_order_by
  var_samp: order_var_samp_order_by
  variance: order_variance_order_by
}

"""
input type for inserting array relation for remote table "order"
"""
input order_arr_rel_insert_input {
  data: [order_insert_input!]!

  """upsert condition"""
  on_conflict: order_on_conflict
}

"""aggregate avg on columns"""
type order_avg_fields {
  order_no: Float
  total_amount: Float
}

"""
order by avg() on columns of table "order"
"""
input order_avg_order_by {
  order_no: order_by
  total_amount: order_by
}

"""
Boolean expression to filter rows from the table "order". All fields are combined with a logical 'AND'.
"""
input order_bool_exp {
  _and: [order_bool_exp!]
  _not: order_bool_exp
  _or: [order_bool_exp!]
  created_at: timestamptz_comparison_exp
  guest_id: uuid_comparison_exp
  id: uuid_comparison_exp
  order_addresses: order_address_bool_exp
  order_addresses_aggregate: order_address_aggregate_bool_exp
  order_no: bigint_comparison_exp
  paymentConversationId: String_comparison_exp
  payment_status: payment_status_enum_comparison_exp
  payment_status_relation: payment_status_bool_exp
  sender_mail: String_comparison_exp
  sender_phone: String_comparison_exp
  tenant_orders: order_tenant_bool_exp
  tenant_orders_aggregate: order_tenant_aggregate_bool_exp
  total_amount: numeric_comparison_exp
  transactions: transaction_bool_exp
  transactions_aggregate: transaction_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_coupons: user_coupon_bool_exp
  user_coupons_aggregate: user_coupon_aggregate_bool_exp
  user_id: uuid_comparison_exp
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
unique or primary key constraints on table "order"
"""
enum order_constraint {
  """
  unique or primary key constraint on columns "order_no"
  """
  order_order_no_key

  """
  unique or primary key constraint on columns "paymentConversationId"
  """
  order_paymentConversationId_key

  """
  unique or primary key constraint on columns "id"
  """
  order_pkey
}

"""
input type for incrementing numeric columns in table "order"
"""
input order_inc_input {
  order_no: bigint
  total_amount: numeric
}

"""
input type for inserting data into table "order"
"""
input order_insert_input {
  created_at: timestamptz
  guest_id: uuid
  id: uuid
  order_addresses: order_address_arr_rel_insert_input
  order_no: bigint
  paymentConversationId: String
  payment_status: payment_status_enum
  payment_status_relation: payment_status_obj_rel_insert_input
  sender_mail: String
  sender_phone: String
  tenant_orders: order_tenant_arr_rel_insert_input
  total_amount: numeric
  transactions: transaction_arr_rel_insert_input
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_coupons: user_coupon_arr_rel_insert_input
  user_id: uuid
}

"""
columns and relationships of "order_item"
"""
type order_item {
  amount: numeric
  approve_note: String
  card_note: String
  commissioned_amount: numeric
  created_at: timestamptz
  delivery_date: timestamp
  delivery_time: String
  id: bigint!
  image_approve_expiry: timestamptz
  image_approve_token: String
  images_to_approve: [String!]
  is_images_approved: Boolean

  """
  A computed field, executes function "generate_order_item_no"
  """
  order_item_no: String

  """An array relationship"""
  order_item_special_images(
    """distinct select on columns"""
    distinct_on: [order_item_special_image_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_special_image_order_by!]

    """filter the rows returned"""
    where: order_item_special_image_bool_exp
  ): [order_item_special_image!]!

  """An aggregate relationship"""
  order_item_special_images_aggregate(
    """distinct select on columns"""
    distinct_on: [order_item_special_image_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_special_image_order_by!]

    """filter the rows returned"""
    where: order_item_special_image_bool_exp
  ): order_item_special_image_aggregate!

  """An array relationship"""
  order_item_special_texts(
    """distinct select on columns"""
    distinct_on: [order_item_special_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_special_text_order_by!]

    """filter the rows returned"""
    where: order_item_special_text_bool_exp
  ): [order_item_special_text!]!

  """An aggregate relationship"""
  order_item_special_texts_aggregate(
    """distinct select on columns"""
    distinct_on: [order_item_special_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_special_text_order_by!]

    """filter the rows returned"""
    where: order_item_special_text_bool_exp
  ): order_item_special_text_aggregate!

  """An object relationship"""
  order_tenant: order_tenant
  order_tenant_id: bigint

  """An object relationship"""
  product: product!
  product_id: bigint!
  quantity: Int!
  sell_price: numeric
  status: order_status_enum
  tenant_amount: numeric
  updated_at: timestamptz

  """An object relationship"""
  user: user
  user_id: uuid
}

"""
aggregated selection of "order_item"
"""
type order_item_aggregate {
  aggregate: order_item_aggregate_fields
  nodes: [order_item!]!
}

input order_item_aggregate_bool_exp {
  bool_and: order_item_aggregate_bool_exp_bool_and
  bool_or: order_item_aggregate_bool_exp_bool_or
  count: order_item_aggregate_bool_exp_count
}

input order_item_aggregate_bool_exp_bool_and {
  arguments: order_item_select_column_order_item_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: order_item_bool_exp
  predicate: Boolean_comparison_exp!
}

input order_item_aggregate_bool_exp_bool_or {
  arguments: order_item_select_column_order_item_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: order_item_bool_exp
  predicate: Boolean_comparison_exp!
}

input order_item_aggregate_bool_exp_count {
  arguments: [order_item_select_column!]
  distinct: Boolean
  filter: order_item_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "order_item"
"""
type order_item_aggregate_fields {
  avg: order_item_avg_fields
  count(columns: [order_item_select_column!], distinct: Boolean): Int!
  max: order_item_max_fields
  min: order_item_min_fields
  stddev: order_item_stddev_fields
  stddev_pop: order_item_stddev_pop_fields
  stddev_samp: order_item_stddev_samp_fields
  sum: order_item_sum_fields
  var_pop: order_item_var_pop_fields
  var_samp: order_item_var_samp_fields
  variance: order_item_variance_fields
}

"""
order by aggregate values of table "order_item"
"""
input order_item_aggregate_order_by {
  avg: order_item_avg_order_by
  count: order_by
  max: order_item_max_order_by
  min: order_item_min_order_by
  stddev: order_item_stddev_order_by
  stddev_pop: order_item_stddev_pop_order_by
  stddev_samp: order_item_stddev_samp_order_by
  sum: order_item_sum_order_by
  var_pop: order_item_var_pop_order_by
  var_samp: order_item_var_samp_order_by
  variance: order_item_variance_order_by
}

"""
input type for inserting array relation for remote table "order_item"
"""
input order_item_arr_rel_insert_input {
  data: [order_item_insert_input!]!

  """upsert condition"""
  on_conflict: order_item_on_conflict
}

"""aggregate avg on columns"""
type order_item_avg_fields {
  amount: Float
  commissioned_amount: Float
  id: Float
  order_tenant_id: Float
  product_id: Float
  quantity: Float
  sell_price: Float
  tenant_amount: Float
}

"""
order by avg() on columns of table "order_item"
"""
input order_item_avg_order_by {
  amount: order_by
  commissioned_amount: order_by
  id: order_by
  order_tenant_id: order_by
  product_id: order_by
  quantity: order_by
  sell_price: order_by
  tenant_amount: order_by
}

"""
Boolean expression to filter rows from the table "order_item". All fields are combined with a logical 'AND'.
"""
input order_item_bool_exp {
  _and: [order_item_bool_exp!]
  _not: order_item_bool_exp
  _or: [order_item_bool_exp!]
  amount: numeric_comparison_exp
  approve_note: String_comparison_exp
  card_note: String_comparison_exp
  commissioned_amount: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  delivery_date: timestamp_comparison_exp
  delivery_time: String_comparison_exp
  id: bigint_comparison_exp
  image_approve_expiry: timestamptz_comparison_exp
  image_approve_token: String_comparison_exp
  images_to_approve: String_array_comparison_exp
  is_images_approved: Boolean_comparison_exp
  order_item_no: String_comparison_exp
  order_item_special_images: order_item_special_image_bool_exp
  order_item_special_images_aggregate: order_item_special_image_aggregate_bool_exp
  order_item_special_texts: order_item_special_text_bool_exp
  order_item_special_texts_aggregate: order_item_special_text_aggregate_bool_exp
  order_tenant: order_tenant_bool_exp
  order_tenant_id: bigint_comparison_exp
  product: product_bool_exp
  product_id: bigint_comparison_exp
  quantity: Int_comparison_exp
  sell_price: numeric_comparison_exp
  status: order_status_enum_comparison_exp
  tenant_amount: numeric_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "order_item"
"""
enum order_item_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  order_item_pkey
}

"""
input type for incrementing numeric columns in table "order_item"
"""
input order_item_inc_input {
  amount: numeric
  commissioned_amount: numeric
  id: bigint
  order_tenant_id: bigint
  product_id: bigint
  quantity: Int
  sell_price: numeric
  tenant_amount: numeric
}

"""
input type for inserting data into table "order_item"
"""
input order_item_insert_input {
  amount: numeric
  approve_note: String
  card_note: String
  commissioned_amount: numeric
  created_at: timestamptz
  delivery_date: timestamp
  delivery_time: String
  id: bigint
  image_approve_expiry: timestamptz
  image_approve_token: String
  images_to_approve: [String!]
  is_images_approved: Boolean
  order_item_special_images: order_item_special_image_arr_rel_insert_input
  order_item_special_texts: order_item_special_text_arr_rel_insert_input
  order_tenant: order_tenant_obj_rel_insert_input
  order_tenant_id: bigint
  product: product_obj_rel_insert_input
  product_id: bigint
  quantity: Int
  sell_price: numeric
  status: order_status_enum
  tenant_amount: numeric
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type order_item_max_fields {
  amount: numeric
  approve_note: String
  card_note: String
  commissioned_amount: numeric
  created_at: timestamptz
  delivery_date: timestamp
  delivery_time: String
  id: bigint
  image_approve_expiry: timestamptz
  image_approve_token: String
  images_to_approve: [String!]

  """
  A computed field, executes function "generate_order_item_no"
  """
  order_item_no: String
  order_tenant_id: bigint
  product_id: bigint
  quantity: Int
  sell_price: numeric
  tenant_amount: numeric
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "order_item"
"""
input order_item_max_order_by {
  amount: order_by
  approve_note: order_by
  card_note: order_by
  commissioned_amount: order_by
  created_at: order_by
  delivery_date: order_by
  delivery_time: order_by
  id: order_by
  image_approve_expiry: order_by
  image_approve_token: order_by
  images_to_approve: order_by
  order_tenant_id: order_by
  product_id: order_by
  quantity: order_by
  sell_price: order_by
  tenant_amount: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type order_item_min_fields {
  amount: numeric
  approve_note: String
  card_note: String
  commissioned_amount: numeric
  created_at: timestamptz
  delivery_date: timestamp
  delivery_time: String
  id: bigint
  image_approve_expiry: timestamptz
  image_approve_token: String
  images_to_approve: [String!]

  """
  A computed field, executes function "generate_order_item_no"
  """
  order_item_no: String
  order_tenant_id: bigint
  product_id: bigint
  quantity: Int
  sell_price: numeric
  tenant_amount: numeric
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "order_item"
"""
input order_item_min_order_by {
  amount: order_by
  approve_note: order_by
  card_note: order_by
  commissioned_amount: order_by
  created_at: order_by
  delivery_date: order_by
  delivery_time: order_by
  id: order_by
  image_approve_expiry: order_by
  image_approve_token: order_by
  images_to_approve: order_by
  order_tenant_id: order_by
  product_id: order_by
  quantity: order_by
  sell_price: order_by
  tenant_amount: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "order_item"
"""
type order_item_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [order_item!]!
}

"""
on_conflict condition type for table "order_item"
"""
input order_item_on_conflict {
  constraint: order_item_constraint!
  update_columns: [order_item_update_column!]! = []
  where: order_item_bool_exp
}

"""Ordering options when selecting data from "order_item"."""
input order_item_order_by {
  amount: order_by
  approve_note: order_by
  card_note: order_by
  commissioned_amount: order_by
  created_at: order_by
  delivery_date: order_by
  delivery_time: order_by
  id: order_by
  image_approve_expiry: order_by
  image_approve_token: order_by
  images_to_approve: order_by
  is_images_approved: order_by
  order_item_no: order_by
  order_item_special_images_aggregate: order_item_special_image_aggregate_order_by
  order_item_special_texts_aggregate: order_item_special_text_aggregate_order_by
  order_tenant: order_tenant_order_by
  order_tenant_id: order_by
  product: product_order_by
  product_id: order_by
  quantity: order_by
  sell_price: order_by
  status: order_by
  tenant_amount: order_by
  updated_at: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: order_item"""
input order_item_pk_columns_input {
  id: bigint!
}

"""
select columns of table "order_item"
"""
enum order_item_select_column {
  """column name"""
  amount

  """column name"""
  approve_note

  """column name"""
  card_note

  """column name"""
  commissioned_amount

  """column name"""
  created_at

  """column name"""
  delivery_date

  """column name"""
  delivery_time

  """column name"""
  id

  """column name"""
  image_approve_expiry

  """column name"""
  image_approve_token

  """column name"""
  images_to_approve

  """column name"""
  is_images_approved

  """column name"""
  order_tenant_id

  """column name"""
  product_id

  """column name"""
  quantity

  """column name"""
  sell_price

  """column name"""
  status

  """column name"""
  tenant_amount

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
select "order_item_aggregate_bool_exp_bool_and_arguments_columns" columns of table "order_item"
"""
enum order_item_select_column_order_item_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_images_approved
}

"""
select "order_item_aggregate_bool_exp_bool_or_arguments_columns" columns of table "order_item"
"""
enum order_item_select_column_order_item_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_images_approved
}

"""
input type for updating data in table "order_item"
"""
input order_item_set_input {
  amount: numeric
  approve_note: String
  card_note: String
  commissioned_amount: numeric
  created_at: timestamptz
  delivery_date: timestamp
  delivery_time: String
  id: bigint
  image_approve_expiry: timestamptz
  image_approve_token: String
  images_to_approve: [String!]
  is_images_approved: Boolean
  order_tenant_id: bigint
  product_id: bigint
  quantity: Int
  sell_price: numeric
  status: order_status_enum
  tenant_amount: numeric
  updated_at: timestamptz
  user_id: uuid
}

"""
columns and relationships of "order_item_special_image"
"""
type order_item_special_image {
  id: bigint!
  image_url: String!
  order_item_id: bigint!
  quantity_index: Int
}

"""
aggregated selection of "order_item_special_image"
"""
type order_item_special_image_aggregate {
  aggregate: order_item_special_image_aggregate_fields
  nodes: [order_item_special_image!]!
}

input order_item_special_image_aggregate_bool_exp {
  count: order_item_special_image_aggregate_bool_exp_count
}

input order_item_special_image_aggregate_bool_exp_count {
  arguments: [order_item_special_image_select_column!]
  distinct: Boolean
  filter: order_item_special_image_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "order_item_special_image"
"""
type order_item_special_image_aggregate_fields {
  avg: order_item_special_image_avg_fields
  count(columns: [order_item_special_image_select_column!], distinct: Boolean): Int!
  max: order_item_special_image_max_fields
  min: order_item_special_image_min_fields
  stddev: order_item_special_image_stddev_fields
  stddev_pop: order_item_special_image_stddev_pop_fields
  stddev_samp: order_item_special_image_stddev_samp_fields
  sum: order_item_special_image_sum_fields
  var_pop: order_item_special_image_var_pop_fields
  var_samp: order_item_special_image_var_samp_fields
  variance: order_item_special_image_variance_fields
}

"""
order by aggregate values of table "order_item_special_image"
"""
input order_item_special_image_aggregate_order_by {
  avg: order_item_special_image_avg_order_by
  count: order_by
  max: order_item_special_image_max_order_by
  min: order_item_special_image_min_order_by
  stddev: order_item_special_image_stddev_order_by
  stddev_pop: order_item_special_image_stddev_pop_order_by
  stddev_samp: order_item_special_image_stddev_samp_order_by
  sum: order_item_special_image_sum_order_by
  var_pop: order_item_special_image_var_pop_order_by
  var_samp: order_item_special_image_var_samp_order_by
  variance: order_item_special_image_variance_order_by
}

"""
input type for inserting array relation for remote table "order_item_special_image"
"""
input order_item_special_image_arr_rel_insert_input {
  data: [order_item_special_image_insert_input!]!

  """upsert condition"""
  on_conflict: order_item_special_image_on_conflict
}

"""aggregate avg on columns"""
type order_item_special_image_avg_fields {
  id: Float
  order_item_id: Float
  quantity_index: Float
}

"""
order by avg() on columns of table "order_item_special_image"
"""
input order_item_special_image_avg_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""
Boolean expression to filter rows from the table "order_item_special_image". All fields are combined with a logical 'AND'.
"""
input order_item_special_image_bool_exp {
  _and: [order_item_special_image_bool_exp!]
  _not: order_item_special_image_bool_exp
  _or: [order_item_special_image_bool_exp!]
  id: bigint_comparison_exp
  image_url: String_comparison_exp
  order_item_id: bigint_comparison_exp
  quantity_index: Int_comparison_exp
}

"""
unique or primary key constraints on table "order_item_special_image"
"""
enum order_item_special_image_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  order_item_special_image_pkey
}

"""
input type for incrementing numeric columns in table "order_item_special_image"
"""
input order_item_special_image_inc_input {
  id: bigint
  order_item_id: bigint
  quantity_index: Int
}

"""
input type for inserting data into table "order_item_special_image"
"""
input order_item_special_image_insert_input {
  id: bigint
  image_url: String
  order_item_id: bigint
  quantity_index: Int
}

"""aggregate max on columns"""
type order_item_special_image_max_fields {
  id: bigint
  image_url: String
  order_item_id: bigint
  quantity_index: Int
}

"""
order by max() on columns of table "order_item_special_image"
"""
input order_item_special_image_max_order_by {
  id: order_by
  image_url: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""aggregate min on columns"""
type order_item_special_image_min_fields {
  id: bigint
  image_url: String
  order_item_id: bigint
  quantity_index: Int
}

"""
order by min() on columns of table "order_item_special_image"
"""
input order_item_special_image_min_order_by {
  id: order_by
  image_url: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""
response of any mutation on the table "order_item_special_image"
"""
type order_item_special_image_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [order_item_special_image!]!
}

"""
on_conflict condition type for table "order_item_special_image"
"""
input order_item_special_image_on_conflict {
  constraint: order_item_special_image_constraint!
  update_columns: [order_item_special_image_update_column!]! = []
  where: order_item_special_image_bool_exp
}

"""Ordering options when selecting data from "order_item_special_image"."""
input order_item_special_image_order_by {
  id: order_by
  image_url: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""primary key columns input for table: order_item_special_image"""
input order_item_special_image_pk_columns_input {
  id: bigint!
}

"""
select columns of table "order_item_special_image"
"""
enum order_item_special_image_select_column {
  """column name"""
  id

  """column name"""
  image_url

  """column name"""
  order_item_id

  """column name"""
  quantity_index
}

"""
input type for updating data in table "order_item_special_image"
"""
input order_item_special_image_set_input {
  id: bigint
  image_url: String
  order_item_id: bigint
  quantity_index: Int
}

"""aggregate stddev on columns"""
type order_item_special_image_stddev_fields {
  id: Float
  order_item_id: Float
  quantity_index: Float
}

"""
order by stddev() on columns of table "order_item_special_image"
"""
input order_item_special_image_stddev_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""aggregate stddev_pop on columns"""
type order_item_special_image_stddev_pop_fields {
  id: Float
  order_item_id: Float
  quantity_index: Float
}

"""
order by stddev_pop() on columns of table "order_item_special_image"
"""
input order_item_special_image_stddev_pop_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""aggregate stddev_samp on columns"""
type order_item_special_image_stddev_samp_fields {
  id: Float
  order_item_id: Float
  quantity_index: Float
}

"""
order by stddev_samp() on columns of table "order_item_special_image"
"""
input order_item_special_image_stddev_samp_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""
Streaming cursor of the table "order_item_special_image"
"""
input order_item_special_image_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: order_item_special_image_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input order_item_special_image_stream_cursor_value_input {
  id: bigint
  image_url: String
  order_item_id: bigint
  quantity_index: Int
}

"""aggregate sum on columns"""
type order_item_special_image_sum_fields {
  id: bigint
  order_item_id: bigint
  quantity_index: Int
}

"""
order by sum() on columns of table "order_item_special_image"
"""
input order_item_special_image_sum_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""
update columns of table "order_item_special_image"
"""
enum order_item_special_image_update_column {
  """column name"""
  id

  """column name"""
  image_url

  """column name"""
  order_item_id

  """column name"""
  quantity_index
}

input order_item_special_image_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: order_item_special_image_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: order_item_special_image_set_input

  """filter the rows which have to be updated"""
  where: order_item_special_image_bool_exp!
}

"""aggregate var_pop on columns"""
type order_item_special_image_var_pop_fields {
  id: Float
  order_item_id: Float
  quantity_index: Float
}

"""
order by var_pop() on columns of table "order_item_special_image"
"""
input order_item_special_image_var_pop_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""aggregate var_samp on columns"""
type order_item_special_image_var_samp_fields {
  id: Float
  order_item_id: Float
  quantity_index: Float
}

"""
order by var_samp() on columns of table "order_item_special_image"
"""
input order_item_special_image_var_samp_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""aggregate variance on columns"""
type order_item_special_image_variance_fields {
  id: Float
  order_item_id: Float
  quantity_index: Float
}

"""
order by variance() on columns of table "order_item_special_image"
"""
input order_item_special_image_variance_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""
columns and relationships of "order_item_special_text"
"""
type order_item_special_text {
  content: String!
  id: bigint!
  order_item_id: bigint!
  quantity_index: Int
}

"""
aggregated selection of "order_item_special_text"
"""
type order_item_special_text_aggregate {
  aggregate: order_item_special_text_aggregate_fields
  nodes: [order_item_special_text!]!
}

input order_item_special_text_aggregate_bool_exp {
  count: order_item_special_text_aggregate_bool_exp_count
}

input order_item_special_text_aggregate_bool_exp_count {
  arguments: [order_item_special_text_select_column!]
  distinct: Boolean
  filter: order_item_special_text_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "order_item_special_text"
"""
type order_item_special_text_aggregate_fields {
  avg: order_item_special_text_avg_fields
  count(columns: [order_item_special_text_select_column!], distinct: Boolean): Int!
  max: order_item_special_text_max_fields
  min: order_item_special_text_min_fields
  stddev: order_item_special_text_stddev_fields
  stddev_pop: order_item_special_text_stddev_pop_fields
  stddev_samp: order_item_special_text_stddev_samp_fields
  sum: order_item_special_text_sum_fields
  var_pop: order_item_special_text_var_pop_fields
  var_samp: order_item_special_text_var_samp_fields
  variance: order_item_special_text_variance_fields
}

"""
order by aggregate values of table "order_item_special_text"
"""
input order_item_special_text_aggregate_order_by {
  avg: order_item_special_text_avg_order_by
  count: order_by
  max: order_item_special_text_max_order_by
  min: order_item_special_text_min_order_by
  stddev: order_item_special_text_stddev_order_by
  stddev_pop: order_item_special_text_stddev_pop_order_by
  stddev_samp: order_item_special_text_stddev_samp_order_by
  sum: order_item_special_text_sum_order_by
  var_pop: order_item_special_text_var_pop_order_by
  var_samp: order_item_special_text_var_samp_order_by
  variance: order_item_special_text_variance_order_by
}

"""
input type for inserting array relation for remote table "order_item_special_text"
"""
input order_item_special_text_arr_rel_insert_input {
  data: [order_item_special_text_insert_input!]!

  """upsert condition"""
  on_conflict: order_item_special_text_on_conflict
}

"""aggregate avg on columns"""
type order_item_special_text_avg_fields {
  id: Float
  order_item_id: Float
  quantity_index: Float
}

"""
order by avg() on columns of table "order_item_special_text"
"""
input order_item_special_text_avg_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""
Boolean expression to filter rows from the table "order_item_special_text". All fields are combined with a logical 'AND'.
"""
input order_item_special_text_bool_exp {
  _and: [order_item_special_text_bool_exp!]
  _not: order_item_special_text_bool_exp
  _or: [order_item_special_text_bool_exp!]
  content: String_comparison_exp
  id: bigint_comparison_exp
  order_item_id: bigint_comparison_exp
  quantity_index: Int_comparison_exp
}

"""
unique or primary key constraints on table "order_item_special_text"
"""
enum order_item_special_text_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  order_item_special_text_pkey
}

"""
input type for incrementing numeric columns in table "order_item_special_text"
"""
input order_item_special_text_inc_input {
  id: bigint
  order_item_id: bigint
  quantity_index: Int
}

"""
input type for inserting data into table "order_item_special_text"
"""
input order_item_special_text_insert_input {
  content: String
  id: bigint
  order_item_id: bigint
  quantity_index: Int
}

"""aggregate max on columns"""
type order_item_special_text_max_fields {
  content: String
  id: bigint
  order_item_id: bigint
  quantity_index: Int
}

"""
order by max() on columns of table "order_item_special_text"
"""
input order_item_special_text_max_order_by {
  content: order_by
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""aggregate min on columns"""
type order_item_special_text_min_fields {
  content: String
  id: bigint
  order_item_id: bigint
  quantity_index: Int
}

"""
order by min() on columns of table "order_item_special_text"
"""
input order_item_special_text_min_order_by {
  content: order_by
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""
response of any mutation on the table "order_item_special_text"
"""
type order_item_special_text_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [order_item_special_text!]!
}

"""
on_conflict condition type for table "order_item_special_text"
"""
input order_item_special_text_on_conflict {
  constraint: order_item_special_text_constraint!
  update_columns: [order_item_special_text_update_column!]! = []
  where: order_item_special_text_bool_exp
}

"""Ordering options when selecting data from "order_item_special_text"."""
input order_item_special_text_order_by {
  content: order_by
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""primary key columns input for table: order_item_special_text"""
input order_item_special_text_pk_columns_input {
  id: bigint!
}

"""
select columns of table "order_item_special_text"
"""
enum order_item_special_text_select_column {
  """column name"""
  content

  """column name"""
  id

  """column name"""
  order_item_id

  """column name"""
  quantity_index
}

"""
input type for updating data in table "order_item_special_text"
"""
input order_item_special_text_set_input {
  content: String
  id: bigint
  order_item_id: bigint
  quantity_index: Int
}

"""aggregate stddev on columns"""
type order_item_special_text_stddev_fields {
  id: Float
  order_item_id: Float
  quantity_index: Float
}

"""
order by stddev() on columns of table "order_item_special_text"
"""
input order_item_special_text_stddev_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""aggregate stddev_pop on columns"""
type order_item_special_text_stddev_pop_fields {
  id: Float
  order_item_id: Float
  quantity_index: Float
}

"""
order by stddev_pop() on columns of table "order_item_special_text"
"""
input order_item_special_text_stddev_pop_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""aggregate stddev_samp on columns"""
type order_item_special_text_stddev_samp_fields {
  id: Float
  order_item_id: Float
  quantity_index: Float
}

"""
order by stddev_samp() on columns of table "order_item_special_text"
"""
input order_item_special_text_stddev_samp_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""
Streaming cursor of the table "order_item_special_text"
"""
input order_item_special_text_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: order_item_special_text_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input order_item_special_text_stream_cursor_value_input {
  content: String
  id: bigint
  order_item_id: bigint
  quantity_index: Int
}

"""aggregate sum on columns"""
type order_item_special_text_sum_fields {
  id: bigint
  order_item_id: bigint
  quantity_index: Int
}

"""
order by sum() on columns of table "order_item_special_text"
"""
input order_item_special_text_sum_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""
update columns of table "order_item_special_text"
"""
enum order_item_special_text_update_column {
  """column name"""
  content

  """column name"""
  id

  """column name"""
  order_item_id

  """column name"""
  quantity_index
}

input order_item_special_text_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: order_item_special_text_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: order_item_special_text_set_input

  """filter the rows which have to be updated"""
  where: order_item_special_text_bool_exp!
}

"""aggregate var_pop on columns"""
type order_item_special_text_var_pop_fields {
  id: Float
  order_item_id: Float
  quantity_index: Float
}

"""
order by var_pop() on columns of table "order_item_special_text"
"""
input order_item_special_text_var_pop_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""aggregate var_samp on columns"""
type order_item_special_text_var_samp_fields {
  id: Float
  order_item_id: Float
  quantity_index: Float
}

"""
order by var_samp() on columns of table "order_item_special_text"
"""
input order_item_special_text_var_samp_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""aggregate variance on columns"""
type order_item_special_text_variance_fields {
  id: Float
  order_item_id: Float
  quantity_index: Float
}

"""
order by variance() on columns of table "order_item_special_text"
"""
input order_item_special_text_variance_order_by {
  id: order_by
  order_item_id: order_by
  quantity_index: order_by
}

"""aggregate stddev on columns"""
type order_item_stddev_fields {
  amount: Float
  commissioned_amount: Float
  id: Float
  order_tenant_id: Float
  product_id: Float
  quantity: Float
  sell_price: Float
  tenant_amount: Float
}

"""
order by stddev() on columns of table "order_item"
"""
input order_item_stddev_order_by {
  amount: order_by
  commissioned_amount: order_by
  id: order_by
  order_tenant_id: order_by
  product_id: order_by
  quantity: order_by
  sell_price: order_by
  tenant_amount: order_by
}

"""aggregate stddev_pop on columns"""
type order_item_stddev_pop_fields {
  amount: Float
  commissioned_amount: Float
  id: Float
  order_tenant_id: Float
  product_id: Float
  quantity: Float
  sell_price: Float
  tenant_amount: Float
}

"""
order by stddev_pop() on columns of table "order_item"
"""
input order_item_stddev_pop_order_by {
  amount: order_by
  commissioned_amount: order_by
  id: order_by
  order_tenant_id: order_by
  product_id: order_by
  quantity: order_by
  sell_price: order_by
  tenant_amount: order_by
}

"""aggregate stddev_samp on columns"""
type order_item_stddev_samp_fields {
  amount: Float
  commissioned_amount: Float
  id: Float
  order_tenant_id: Float
  product_id: Float
  quantity: Float
  sell_price: Float
  tenant_amount: Float
}

"""
order by stddev_samp() on columns of table "order_item"
"""
input order_item_stddev_samp_order_by {
  amount: order_by
  commissioned_amount: order_by
  id: order_by
  order_tenant_id: order_by
  product_id: order_by
  quantity: order_by
  sell_price: order_by
  tenant_amount: order_by
}

"""
Streaming cursor of the table "order_item"
"""
input order_item_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: order_item_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input order_item_stream_cursor_value_input {
  amount: numeric
  approve_note: String
  card_note: String
  commissioned_amount: numeric
  created_at: timestamptz
  delivery_date: timestamp
  delivery_time: String
  id: bigint
  image_approve_expiry: timestamptz
  image_approve_token: String
  images_to_approve: [String!]
  is_images_approved: Boolean
  order_tenant_id: bigint
  product_id: bigint
  quantity: Int
  sell_price: numeric
  status: order_status_enum
  tenant_amount: numeric
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate sum on columns"""
type order_item_sum_fields {
  amount: numeric
  commissioned_amount: numeric
  id: bigint
  order_tenant_id: bigint
  product_id: bigint
  quantity: Int
  sell_price: numeric
  tenant_amount: numeric
}

"""
order by sum() on columns of table "order_item"
"""
input order_item_sum_order_by {
  amount: order_by
  commissioned_amount: order_by
  id: order_by
  order_tenant_id: order_by
  product_id: order_by
  quantity: order_by
  sell_price: order_by
  tenant_amount: order_by
}

"""
update columns of table "order_item"
"""
enum order_item_update_column {
  """column name"""
  amount

  """column name"""
  approve_note

  """column name"""
  card_note

  """column name"""
  commissioned_amount

  """column name"""
  created_at

  """column name"""
  delivery_date

  """column name"""
  delivery_time

  """column name"""
  id

  """column name"""
  image_approve_expiry

  """column name"""
  image_approve_token

  """column name"""
  images_to_approve

  """column name"""
  is_images_approved

  """column name"""
  order_tenant_id

  """column name"""
  product_id

  """column name"""
  quantity

  """column name"""
  sell_price

  """column name"""
  status

  """column name"""
  tenant_amount

  """column name"""
  updated_at

  """column name"""
  user_id
}

input order_item_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: order_item_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: order_item_set_input

  """filter the rows which have to be updated"""
  where: order_item_bool_exp!
}

"""aggregate var_pop on columns"""
type order_item_var_pop_fields {
  amount: Float
  commissioned_amount: Float
  id: Float
  order_tenant_id: Float
  product_id: Float
  quantity: Float
  sell_price: Float
  tenant_amount: Float
}

"""
order by var_pop() on columns of table "order_item"
"""
input order_item_var_pop_order_by {
  amount: order_by
  commissioned_amount: order_by
  id: order_by
  order_tenant_id: order_by
  product_id: order_by
  quantity: order_by
  sell_price: order_by
  tenant_amount: order_by
}

"""aggregate var_samp on columns"""
type order_item_var_samp_fields {
  amount: Float
  commissioned_amount: Float
  id: Float
  order_tenant_id: Float
  product_id: Float
  quantity: Float
  sell_price: Float
  tenant_amount: Float
}

"""
order by var_samp() on columns of table "order_item"
"""
input order_item_var_samp_order_by {
  amount: order_by
  commissioned_amount: order_by
  id: order_by
  order_tenant_id: order_by
  product_id: order_by
  quantity: order_by
  sell_price: order_by
  tenant_amount: order_by
}

"""aggregate variance on columns"""
type order_item_variance_fields {
  amount: Float
  commissioned_amount: Float
  id: Float
  order_tenant_id: Float
  product_id: Float
  quantity: Float
  sell_price: Float
  tenant_amount: Float
}

"""
order by variance() on columns of table "order_item"
"""
input order_item_variance_order_by {
  amount: order_by
  commissioned_amount: order_by
  id: order_by
  order_tenant_id: order_by
  product_id: order_by
  quantity: order_by
  sell_price: order_by
  tenant_amount: order_by
}

"""aggregate max on columns"""
type order_max_fields {
  created_at: timestamptz
  guest_id: uuid
  id: uuid
  order_no: bigint
  paymentConversationId: String
  sender_mail: String
  sender_phone: String
  total_amount: numeric
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "order"
"""
input order_max_order_by {
  created_at: order_by
  guest_id: order_by
  id: order_by
  order_no: order_by
  paymentConversationId: order_by
  sender_mail: order_by
  sender_phone: order_by
  total_amount: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type order_min_fields {
  created_at: timestamptz
  guest_id: uuid
  id: uuid
  order_no: bigint
  paymentConversationId: String
  sender_mail: String
  sender_phone: String
  total_amount: numeric
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "order"
"""
input order_min_order_by {
  created_at: order_by
  guest_id: order_by
  id: order_by
  order_no: order_by
  paymentConversationId: order_by
  sender_mail: order_by
  sender_phone: order_by
  total_amount: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "order"
"""
type order_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [order!]!
}

"""
input type for inserting object relation for remote table "order"
"""
input order_obj_rel_insert_input {
  data: order_insert_input!

  """upsert condition"""
  on_conflict: order_on_conflict
}

"""
on_conflict condition type for table "order"
"""
input order_on_conflict {
  constraint: order_constraint!
  update_columns: [order_update_column!]! = []
  where: order_bool_exp
}

"""Ordering options when selecting data from "order"."""
input order_order_by {
  created_at: order_by
  guest_id: order_by
  id: order_by
  order_addresses_aggregate: order_address_aggregate_order_by
  order_no: order_by
  paymentConversationId: order_by
  payment_status: order_by
  payment_status_relation: payment_status_order_by
  sender_mail: order_by
  sender_phone: order_by
  tenant_orders_aggregate: order_tenant_aggregate_order_by
  total_amount: order_by
  transactions_aggregate: transaction_aggregate_order_by
  updated_at: order_by
  user: user_order_by
  user_coupons_aggregate: user_coupon_aggregate_order_by
  user_id: order_by
}

"""primary key columns input for table: order"""
input order_pk_columns_input {
  id: uuid!
}

"""
select columns of table "order"
"""
enum order_select_column {
  """column name"""
  created_at

  """column name"""
  guest_id

  """column name"""
  id

  """column name"""
  order_no

  """column name"""
  paymentConversationId

  """column name"""
  payment_status

  """column name"""
  sender_mail

  """column name"""
  sender_phone

  """column name"""
  total_amount

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "order"
"""
input order_set_input {
  created_at: timestamptz
  guest_id: uuid
  id: uuid
  order_no: bigint
  paymentConversationId: String
  payment_status: payment_status_enum
  sender_mail: String
  sender_phone: String
  total_amount: numeric
  updated_at: timestamptz
  user_id: uuid
}

"""
columns and relationships of "order_status"
"""
type order_status {
  comment: String

  """An array relationship"""
  order_tenants(
    """distinct select on columns"""
    distinct_on: [order_tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_tenant_order_by!]

    """filter the rows returned"""
    where: order_tenant_bool_exp
  ): [order_tenant!]!

  """An aggregate relationship"""
  order_tenants_aggregate(
    """distinct select on columns"""
    distinct_on: [order_tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_tenant_order_by!]

    """filter the rows returned"""
    where: order_tenant_bool_exp
  ): order_tenant_aggregate!
  value: String!
}

"""
aggregated selection of "order_status"
"""
type order_status_aggregate {
  aggregate: order_status_aggregate_fields
  nodes: [order_status!]!
}

"""
aggregate fields of "order_status"
"""
type order_status_aggregate_fields {
  count(columns: [order_status_select_column!], distinct: Boolean): Int!
  max: order_status_max_fields
  min: order_status_min_fields
}

"""
Boolean expression to filter rows from the table "order_status". All fields are combined with a logical 'AND'.
"""
input order_status_bool_exp {
  _and: [order_status_bool_exp!]
  _not: order_status_bool_exp
  _or: [order_status_bool_exp!]
  comment: String_comparison_exp
  order_tenants: order_tenant_bool_exp
  order_tenants_aggregate: order_tenant_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "order_status"
"""
enum order_status_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  order_status_pkey
}

enum order_status_enum {
  """
  Siparişin herhangi bir nedenden dolayı (stokta kalmaması, ödeme sorunları, müşteri talebi gibi) müşteri tarafından veya sistem tarafından iptal edilmesi.
  """
  Canceled

  """
  Sipariş başarıyla işlendi, teslim edildi ve tamamlanmış olarak kabul edildi.
  """
  Completed

  """Sipariş verildi ancak daha fazla işlem veya onay bekleniyor."""
  Created

  """Sipariş müşteriye başarıyla teslim edildi."""
  Delivered

  """
  Ödemenin başarısız olması veya envanterin kullanılamaması gibi sorunlar nedeniyle sipariş işleme koyulamadı.
  """
  Failed
  Paid

  """Sipariş sevkiyata hazırlanıyor."""
  Processing

  """Siparişin ödemesi müşteriye iade edilmiştir."""
  Refunded

  """Sipariş kargoya verildi veya teslimat servisine teslim edildi."""
  Shipped
}

"""
Boolean expression to compare columns of type "order_status_enum". All fields are combined with logical 'AND'.
"""
input order_status_enum_comparison_exp {
  _eq: order_status_enum
  _in: [order_status_enum!]
  _is_null: Boolean
  _neq: order_status_enum
  _nin: [order_status_enum!]
}

"""
input type for inserting data into table "order_status"
"""
input order_status_insert_input {
  comment: String
  order_tenants: order_tenant_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type order_status_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type order_status_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "order_status"
"""
type order_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [order_status!]!
}

"""
input type for inserting object relation for remote table "order_status"
"""
input order_status_obj_rel_insert_input {
  data: order_status_insert_input!

  """upsert condition"""
  on_conflict: order_status_on_conflict
}

"""
on_conflict condition type for table "order_status"
"""
input order_status_on_conflict {
  constraint: order_status_constraint!
  update_columns: [order_status_update_column!]! = []
  where: order_status_bool_exp
}

"""Ordering options when selecting data from "order_status"."""
input order_status_order_by {
  comment: order_by
  order_tenants_aggregate: order_tenant_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: order_status"""
input order_status_pk_columns_input {
  value: String!
}

"""
select columns of table "order_status"
"""
enum order_status_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "order_status"
"""
input order_status_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "order_status"
"""
input order_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: order_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input order_status_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "order_status"
"""
enum order_status_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input order_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: order_status_set_input

  """filter the rows which have to be updated"""
  where: order_status_bool_exp!
}

"""aggregate stddev on columns"""
type order_stddev_fields {
  order_no: Float
  total_amount: Float
}

"""
order by stddev() on columns of table "order"
"""
input order_stddev_order_by {
  order_no: order_by
  total_amount: order_by
}

"""aggregate stddev_pop on columns"""
type order_stddev_pop_fields {
  order_no: Float
  total_amount: Float
}

"""
order by stddev_pop() on columns of table "order"
"""
input order_stddev_pop_order_by {
  order_no: order_by
  total_amount: order_by
}

"""aggregate stddev_samp on columns"""
type order_stddev_samp_fields {
  order_no: Float
  total_amount: Float
}

"""
order by stddev_samp() on columns of table "order"
"""
input order_stddev_samp_order_by {
  order_no: order_by
  total_amount: order_by
}

"""
Streaming cursor of the table "order"
"""
input order_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: order_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input order_stream_cursor_value_input {
  created_at: timestamptz
  guest_id: uuid
  id: uuid
  order_no: bigint
  paymentConversationId: String
  payment_status: payment_status_enum
  sender_mail: String
  sender_phone: String
  total_amount: numeric
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate sum on columns"""
type order_sum_fields {
  order_no: bigint
  total_amount: numeric
}

"""
order by sum() on columns of table "order"
"""
input order_sum_order_by {
  order_no: order_by
  total_amount: order_by
}

"""
columns and relationships of "order_tenant"
"""
type order_tenant {
  """An array relationship"""
  chat_threads(
    """distinct select on columns"""
    distinct_on: [chat_thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_thread_order_by!]

    """filter the rows returned"""
    where: chat_thread_bool_exp
  ): [chat_thread!]!

  """An aggregate relationship"""
  chat_threads_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_thread_order_by!]

    """filter the rows returned"""
    where: chat_thread_bool_exp
  ): chat_thread_aggregate!
  created_at: timestamptz!
  id: bigint!

  """An object relationship"""
  order: order!
  order_id: uuid!

  """An array relationship"""
  order_items(
    """distinct select on columns"""
    distinct_on: [order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_order_by!]

    """filter the rows returned"""
    where: order_item_bool_exp
  ): [order_item!]!

  """An aggregate relationship"""
  order_items_aggregate(
    """distinct select on columns"""
    distinct_on: [order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_order_by!]

    """filter the rows returned"""
    where: order_item_bool_exp
  ): order_item_aggregate!

  """An object relationship"""
  order_status: order_status

  """An array relationship"""
  order_tenant_invoices(
    """distinct select on columns"""
    distinct_on: [order_tenant_invoice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_tenant_invoice_order_by!]

    """filter the rows returned"""
    where: order_tenant_invoice_bool_exp
  ): [order_tenant_invoice!]!

  """An aggregate relationship"""
  order_tenant_invoices_aggregate(
    """distinct select on columns"""
    distinct_on: [order_tenant_invoice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_tenant_invoice_order_by!]

    """filter the rows returned"""
    where: order_tenant_invoice_bool_exp
  ): order_tenant_invoice_aggregate!
  order_tenant_no: bigint!
  status: order_status_enum

  """An object relationship"""
  tenant: user!
  tenant_id: uuid!
  updated_at: timestamptz!
}

"""
aggregated selection of "order_tenant"
"""
type order_tenant_aggregate {
  aggregate: order_tenant_aggregate_fields
  nodes: [order_tenant!]!
}

input order_tenant_aggregate_bool_exp {
  count: order_tenant_aggregate_bool_exp_count
}

input order_tenant_aggregate_bool_exp_count {
  arguments: [order_tenant_select_column!]
  distinct: Boolean
  filter: order_tenant_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "order_tenant"
"""
type order_tenant_aggregate_fields {
  avg: order_tenant_avg_fields
  count(columns: [order_tenant_select_column!], distinct: Boolean): Int!
  max: order_tenant_max_fields
  min: order_tenant_min_fields
  stddev: order_tenant_stddev_fields
  stddev_pop: order_tenant_stddev_pop_fields
  stddev_samp: order_tenant_stddev_samp_fields
  sum: order_tenant_sum_fields
  var_pop: order_tenant_var_pop_fields
  var_samp: order_tenant_var_samp_fields
  variance: order_tenant_variance_fields
}

"""
order by aggregate values of table "order_tenant"
"""
input order_tenant_aggregate_order_by {
  avg: order_tenant_avg_order_by
  count: order_by
  max: order_tenant_max_order_by
  min: order_tenant_min_order_by
  stddev: order_tenant_stddev_order_by
  stddev_pop: order_tenant_stddev_pop_order_by
  stddev_samp: order_tenant_stddev_samp_order_by
  sum: order_tenant_sum_order_by
  var_pop: order_tenant_var_pop_order_by
  var_samp: order_tenant_var_samp_order_by
  variance: order_tenant_variance_order_by
}

"""
input type for inserting array relation for remote table "order_tenant"
"""
input order_tenant_arr_rel_insert_input {
  data: [order_tenant_insert_input!]!

  """upsert condition"""
  on_conflict: order_tenant_on_conflict
}

"""aggregate avg on columns"""
type order_tenant_avg_fields {
  id: Float
  order_tenant_no: Float
}

"""
order by avg() on columns of table "order_tenant"
"""
input order_tenant_avg_order_by {
  id: order_by
  order_tenant_no: order_by
}

"""
Boolean expression to filter rows from the table "order_tenant". All fields are combined with a logical 'AND'.
"""
input order_tenant_bool_exp {
  _and: [order_tenant_bool_exp!]
  _not: order_tenant_bool_exp
  _or: [order_tenant_bool_exp!]
  chat_threads: chat_thread_bool_exp
  chat_threads_aggregate: chat_thread_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  order: order_bool_exp
  order_id: uuid_comparison_exp
  order_items: order_item_bool_exp
  order_items_aggregate: order_item_aggregate_bool_exp
  order_status: order_status_bool_exp
  order_tenant_invoices: order_tenant_invoice_bool_exp
  order_tenant_invoices_aggregate: order_tenant_invoice_aggregate_bool_exp
  order_tenant_no: bigint_comparison_exp
  status: order_status_enum_comparison_exp
  tenant: user_bool_exp
  tenant_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "order_tenant"
"""
enum order_tenant_constraint {
  """
  unique or primary key constraint on columns "order_tenant_no"
  """
  order_tenant_order_tenant_no_key

  """
  unique or primary key constraint on columns "id"
  """
  order_tenant_pkey
}

"""
input type for incrementing numeric columns in table "order_tenant"
"""
input order_tenant_inc_input {
  id: bigint
  order_tenant_no: bigint
}

"""
input type for inserting data into table "order_tenant"
"""
input order_tenant_insert_input {
  chat_threads: chat_thread_arr_rel_insert_input
  created_at: timestamptz
  id: bigint
  order: order_obj_rel_insert_input
  order_id: uuid
  order_items: order_item_arr_rel_insert_input
  order_status: order_status_obj_rel_insert_input
  order_tenant_invoices: order_tenant_invoice_arr_rel_insert_input
  order_tenant_no: bigint
  status: order_status_enum
  tenant: user_obj_rel_insert_input
  tenant_id: uuid
  updated_at: timestamptz
}

"""
columns and relationships of "order_tenant_invoice"
"""
type order_tenant_invoice {
  created_at: timestamptz!
  id: uuid!

  """An object relationship"""
  order_tenant: order_tenant!
  order_tenant_id: bigint!
  pdf_url: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "order_tenant_invoice"
"""
type order_tenant_invoice_aggregate {
  aggregate: order_tenant_invoice_aggregate_fields
  nodes: [order_tenant_invoice!]!
}

input order_tenant_invoice_aggregate_bool_exp {
  count: order_tenant_invoice_aggregate_bool_exp_count
}

input order_tenant_invoice_aggregate_bool_exp_count {
  arguments: [order_tenant_invoice_select_column!]
  distinct: Boolean
  filter: order_tenant_invoice_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "order_tenant_invoice"
"""
type order_tenant_invoice_aggregate_fields {
  avg: order_tenant_invoice_avg_fields
  count(columns: [order_tenant_invoice_select_column!], distinct: Boolean): Int!
  max: order_tenant_invoice_max_fields
  min: order_tenant_invoice_min_fields
  stddev: order_tenant_invoice_stddev_fields
  stddev_pop: order_tenant_invoice_stddev_pop_fields
  stddev_samp: order_tenant_invoice_stddev_samp_fields
  sum: order_tenant_invoice_sum_fields
  var_pop: order_tenant_invoice_var_pop_fields
  var_samp: order_tenant_invoice_var_samp_fields
  variance: order_tenant_invoice_variance_fields
}

"""
order by aggregate values of table "order_tenant_invoice"
"""
input order_tenant_invoice_aggregate_order_by {
  avg: order_tenant_invoice_avg_order_by
  count: order_by
  max: order_tenant_invoice_max_order_by
  min: order_tenant_invoice_min_order_by
  stddev: order_tenant_invoice_stddev_order_by
  stddev_pop: order_tenant_invoice_stddev_pop_order_by
  stddev_samp: order_tenant_invoice_stddev_samp_order_by
  sum: order_tenant_invoice_sum_order_by
  var_pop: order_tenant_invoice_var_pop_order_by
  var_samp: order_tenant_invoice_var_samp_order_by
  variance: order_tenant_invoice_variance_order_by
}

"""
input type for inserting array relation for remote table "order_tenant_invoice"
"""
input order_tenant_invoice_arr_rel_insert_input {
  data: [order_tenant_invoice_insert_input!]!

  """upsert condition"""
  on_conflict: order_tenant_invoice_on_conflict
}

"""aggregate avg on columns"""
type order_tenant_invoice_avg_fields {
  order_tenant_id: Float
}

"""
order by avg() on columns of table "order_tenant_invoice"
"""
input order_tenant_invoice_avg_order_by {
  order_tenant_id: order_by
}

"""
Boolean expression to filter rows from the table "order_tenant_invoice". All fields are combined with a logical 'AND'.
"""
input order_tenant_invoice_bool_exp {
  _and: [order_tenant_invoice_bool_exp!]
  _not: order_tenant_invoice_bool_exp
  _or: [order_tenant_invoice_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  order_tenant: order_tenant_bool_exp
  order_tenant_id: bigint_comparison_exp
  pdf_url: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "order_tenant_invoice"
"""
enum order_tenant_invoice_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  order_tenant_invoice_id_key

  """
  unique or primary key constraint on columns "order_tenant_id"
  """
  order_tenant_invoice_order_tenant_id_key

  """
  unique or primary key constraint on columns "id"
  """
  order_tenant_invoice_pkey
}

"""
input type for incrementing numeric columns in table "order_tenant_invoice"
"""
input order_tenant_invoice_inc_input {
  order_tenant_id: bigint
}

"""
input type for inserting data into table "order_tenant_invoice"
"""
input order_tenant_invoice_insert_input {
  created_at: timestamptz
  id: uuid
  order_tenant: order_tenant_obj_rel_insert_input
  order_tenant_id: bigint
  pdf_url: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type order_tenant_invoice_max_fields {
  created_at: timestamptz
  id: uuid
  order_tenant_id: bigint
  pdf_url: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "order_tenant_invoice"
"""
input order_tenant_invoice_max_order_by {
  created_at: order_by
  id: order_by
  order_tenant_id: order_by
  pdf_url: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type order_tenant_invoice_min_fields {
  created_at: timestamptz
  id: uuid
  order_tenant_id: bigint
  pdf_url: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "order_tenant_invoice"
"""
input order_tenant_invoice_min_order_by {
  created_at: order_by
  id: order_by
  order_tenant_id: order_by
  pdf_url: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "order_tenant_invoice"
"""
type order_tenant_invoice_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [order_tenant_invoice!]!
}

"""
on_conflict condition type for table "order_tenant_invoice"
"""
input order_tenant_invoice_on_conflict {
  constraint: order_tenant_invoice_constraint!
  update_columns: [order_tenant_invoice_update_column!]! = []
  where: order_tenant_invoice_bool_exp
}

"""Ordering options when selecting data from "order_tenant_invoice"."""
input order_tenant_invoice_order_by {
  created_at: order_by
  id: order_by
  order_tenant: order_tenant_order_by
  order_tenant_id: order_by
  pdf_url: order_by
  updated_at: order_by
}

"""primary key columns input for table: order_tenant_invoice"""
input order_tenant_invoice_pk_columns_input {
  id: uuid!
}

"""
select columns of table "order_tenant_invoice"
"""
enum order_tenant_invoice_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  order_tenant_id

  """column name"""
  pdf_url

  """column name"""
  updated_at
}

"""
input type for updating data in table "order_tenant_invoice"
"""
input order_tenant_invoice_set_input {
  created_at: timestamptz
  id: uuid
  order_tenant_id: bigint
  pdf_url: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type order_tenant_invoice_stddev_fields {
  order_tenant_id: Float
}

"""
order by stddev() on columns of table "order_tenant_invoice"
"""
input order_tenant_invoice_stddev_order_by {
  order_tenant_id: order_by
}

"""aggregate stddev_pop on columns"""
type order_tenant_invoice_stddev_pop_fields {
  order_tenant_id: Float
}

"""
order by stddev_pop() on columns of table "order_tenant_invoice"
"""
input order_tenant_invoice_stddev_pop_order_by {
  order_tenant_id: order_by
}

"""aggregate stddev_samp on columns"""
type order_tenant_invoice_stddev_samp_fields {
  order_tenant_id: Float
}

"""
order by stddev_samp() on columns of table "order_tenant_invoice"
"""
input order_tenant_invoice_stddev_samp_order_by {
  order_tenant_id: order_by
}

"""
Streaming cursor of the table "order_tenant_invoice"
"""
input order_tenant_invoice_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: order_tenant_invoice_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input order_tenant_invoice_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  order_tenant_id: bigint
  pdf_url: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type order_tenant_invoice_sum_fields {
  order_tenant_id: bigint
}

"""
order by sum() on columns of table "order_tenant_invoice"
"""
input order_tenant_invoice_sum_order_by {
  order_tenant_id: order_by
}

"""
update columns of table "order_tenant_invoice"
"""
enum order_tenant_invoice_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  order_tenant_id

  """column name"""
  pdf_url

  """column name"""
  updated_at
}

input order_tenant_invoice_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: order_tenant_invoice_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: order_tenant_invoice_set_input

  """filter the rows which have to be updated"""
  where: order_tenant_invoice_bool_exp!
}

"""aggregate var_pop on columns"""
type order_tenant_invoice_var_pop_fields {
  order_tenant_id: Float
}

"""
order by var_pop() on columns of table "order_tenant_invoice"
"""
input order_tenant_invoice_var_pop_order_by {
  order_tenant_id: order_by
}

"""aggregate var_samp on columns"""
type order_tenant_invoice_var_samp_fields {
  order_tenant_id: Float
}

"""
order by var_samp() on columns of table "order_tenant_invoice"
"""
input order_tenant_invoice_var_samp_order_by {
  order_tenant_id: order_by
}

"""aggregate variance on columns"""
type order_tenant_invoice_variance_fields {
  order_tenant_id: Float
}

"""
order by variance() on columns of table "order_tenant_invoice"
"""
input order_tenant_invoice_variance_order_by {
  order_tenant_id: order_by
}

"""aggregate max on columns"""
type order_tenant_max_fields {
  created_at: timestamptz
  id: bigint
  order_id: uuid
  order_tenant_no: bigint
  tenant_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "order_tenant"
"""
input order_tenant_max_order_by {
  created_at: order_by
  id: order_by
  order_id: order_by
  order_tenant_no: order_by
  tenant_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type order_tenant_min_fields {
  created_at: timestamptz
  id: bigint
  order_id: uuid
  order_tenant_no: bigint
  tenant_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "order_tenant"
"""
input order_tenant_min_order_by {
  created_at: order_by
  id: order_by
  order_id: order_by
  order_tenant_no: order_by
  tenant_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "order_tenant"
"""
type order_tenant_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [order_tenant!]!
}

"""
input type for inserting object relation for remote table "order_tenant"
"""
input order_tenant_obj_rel_insert_input {
  data: order_tenant_insert_input!

  """upsert condition"""
  on_conflict: order_tenant_on_conflict
}

"""
on_conflict condition type for table "order_tenant"
"""
input order_tenant_on_conflict {
  constraint: order_tenant_constraint!
  update_columns: [order_tenant_update_column!]! = []
  where: order_tenant_bool_exp
}

"""Ordering options when selecting data from "order_tenant"."""
input order_tenant_order_by {
  chat_threads_aggregate: chat_thread_aggregate_order_by
  created_at: order_by
  id: order_by
  order: order_order_by
  order_id: order_by
  order_items_aggregate: order_item_aggregate_order_by
  order_status: order_status_order_by
  order_tenant_invoices_aggregate: order_tenant_invoice_aggregate_order_by
  order_tenant_no: order_by
  status: order_by
  tenant: user_order_by
  tenant_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: order_tenant"""
input order_tenant_pk_columns_input {
  id: bigint!
}

"""
select columns of table "order_tenant"
"""
enum order_tenant_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  order_id

  """column name"""
  order_tenant_no

  """column name"""
  status

  """column name"""
  tenant_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "order_tenant"
"""
input order_tenant_set_input {
  created_at: timestamptz
  id: bigint
  order_id: uuid
  order_tenant_no: bigint
  status: order_status_enum
  tenant_id: uuid
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type order_tenant_stddev_fields {
  id: Float
  order_tenant_no: Float
}

"""
order by stddev() on columns of table "order_tenant"
"""
input order_tenant_stddev_order_by {
  id: order_by
  order_tenant_no: order_by
}

"""aggregate stddev_pop on columns"""
type order_tenant_stddev_pop_fields {
  id: Float
  order_tenant_no: Float
}

"""
order by stddev_pop() on columns of table "order_tenant"
"""
input order_tenant_stddev_pop_order_by {
  id: order_by
  order_tenant_no: order_by
}

"""aggregate stddev_samp on columns"""
type order_tenant_stddev_samp_fields {
  id: Float
  order_tenant_no: Float
}

"""
order by stddev_samp() on columns of table "order_tenant"
"""
input order_tenant_stddev_samp_order_by {
  id: order_by
  order_tenant_no: order_by
}

"""
Streaming cursor of the table "order_tenant"
"""
input order_tenant_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: order_tenant_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input order_tenant_stream_cursor_value_input {
  created_at: timestamptz
  id: bigint
  order_id: uuid
  order_tenant_no: bigint
  status: order_status_enum
  tenant_id: uuid
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type order_tenant_sum_fields {
  id: bigint
  order_tenant_no: bigint
}

"""
order by sum() on columns of table "order_tenant"
"""
input order_tenant_sum_order_by {
  id: order_by
  order_tenant_no: order_by
}

"""
update columns of table "order_tenant"
"""
enum order_tenant_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  order_id

  """column name"""
  order_tenant_no

  """column name"""
  status

  """column name"""
  tenant_id

  """column name"""
  updated_at
}

input order_tenant_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: order_tenant_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: order_tenant_set_input

  """filter the rows which have to be updated"""
  where: order_tenant_bool_exp!
}

"""aggregate var_pop on columns"""
type order_tenant_var_pop_fields {
  id: Float
  order_tenant_no: Float
}

"""
order by var_pop() on columns of table "order_tenant"
"""
input order_tenant_var_pop_order_by {
  id: order_by
  order_tenant_no: order_by
}

"""aggregate var_samp on columns"""
type order_tenant_var_samp_fields {
  id: Float
  order_tenant_no: Float
}

"""
order by var_samp() on columns of table "order_tenant"
"""
input order_tenant_var_samp_order_by {
  id: order_by
  order_tenant_no: order_by
}

"""aggregate variance on columns"""
type order_tenant_variance_fields {
  id: Float
  order_tenant_no: Float
}

"""
order by variance() on columns of table "order_tenant"
"""
input order_tenant_variance_order_by {
  id: order_by
  order_tenant_no: order_by
}

"""
update columns of table "order"
"""
enum order_update_column {
  """column name"""
  created_at

  """column name"""
  guest_id

  """column name"""
  id

  """column name"""
  order_no

  """column name"""
  paymentConversationId

  """column name"""
  payment_status

  """column name"""
  sender_mail

  """column name"""
  sender_phone

  """column name"""
  total_amount

  """column name"""
  updated_at

  """column name"""
  user_id
}

input order_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: order_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: order_set_input

  """filter the rows which have to be updated"""
  where: order_bool_exp!
}

"""aggregate var_pop on columns"""
type order_var_pop_fields {
  order_no: Float
  total_amount: Float
}

"""
order by var_pop() on columns of table "order"
"""
input order_var_pop_order_by {
  order_no: order_by
  total_amount: order_by
}

"""aggregate var_samp on columns"""
type order_var_samp_fields {
  order_no: Float
  total_amount: Float
}

"""
order by var_samp() on columns of table "order"
"""
input order_var_samp_order_by {
  order_no: order_by
  total_amount: order_by
}

"""aggregate variance on columns"""
type order_variance_fields {
  order_no: Float
  total_amount: Float
}

"""
order by variance() on columns of table "order"
"""
input order_variance_order_by {
  order_no: order_by
  total_amount: order_by
}

"""
columns and relationships of "payment_status"
"""
type payment_status {
  comment: String
  value: String!
}

"""
aggregated selection of "payment_status"
"""
type payment_status_aggregate {
  aggregate: payment_status_aggregate_fields
  nodes: [payment_status!]!
}

"""
aggregate fields of "payment_status"
"""
type payment_status_aggregate_fields {
  count(columns: [payment_status_select_column!], distinct: Boolean): Int!
  max: payment_status_max_fields
  min: payment_status_min_fields
}

"""
Boolean expression to filter rows from the table "payment_status". All fields are combined with a logical 'AND'.
"""
input payment_status_bool_exp {
  _and: [payment_status_bool_exp!]
  _not: payment_status_bool_exp
  _or: [payment_status_bool_exp!]
  comment: String_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "payment_status"
"""
enum payment_status_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  payment_status_pkey
}

enum payment_status_enum {
  FAIL
  PAID
}

"""
Boolean expression to compare columns of type "payment_status_enum". All fields are combined with logical 'AND'.
"""
input payment_status_enum_comparison_exp {
  _eq: payment_status_enum
  _in: [payment_status_enum!]
  _is_null: Boolean
  _neq: payment_status_enum
  _nin: [payment_status_enum!]
}

"""
input type for inserting data into table "payment_status"
"""
input payment_status_insert_input {
  comment: String
  value: String
}

"""aggregate max on columns"""
type payment_status_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type payment_status_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "payment_status"
"""
type payment_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [payment_status!]!
}

"""
input type for inserting object relation for remote table "payment_status"
"""
input payment_status_obj_rel_insert_input {
  data: payment_status_insert_input!

  """upsert condition"""
  on_conflict: payment_status_on_conflict
}

"""
on_conflict condition type for table "payment_status"
"""
input payment_status_on_conflict {
  constraint: payment_status_constraint!
  update_columns: [payment_status_update_column!]! = []
  where: payment_status_bool_exp
}

"""Ordering options when selecting data from "payment_status"."""
input payment_status_order_by {
  comment: order_by
  value: order_by
}

"""primary key columns input for table: payment_status"""
input payment_status_pk_columns_input {
  value: String!
}

"""
select columns of table "payment_status"
"""
enum payment_status_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "payment_status"
"""
input payment_status_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "payment_status"
"""
input payment_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: payment_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input payment_status_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "payment_status"
"""
enum payment_status_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input payment_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: payment_status_set_input

  """filter the rows which have to be updated"""
  where: payment_status_bool_exp!
}

"""
columns and relationships of "product"
"""
type product {
  category_id: Int
  delivery_end_time: timestamptz
  delivery_start_time: timestamptz
  delivery_time_ranges(
    """JSON select path"""
    path: String
  ): jsonb
  delivery_type: delivery_type_enum

  """An object relationship"""
  delivery_type_rel: delivery_type
  description: String
  discount_price: numeric
  id: bigint!
  image_url: [String!]
  is_active: Boolean
  is_service_free: Boolean
  name: String!

  """An array relationship"""
  order_items(
    """distinct select on columns"""
    distinct_on: [order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_order_by!]

    """filter the rows returned"""
    where: order_item_bool_exp
  ): [order_item!]!

  """An aggregate relationship"""
  order_items_aggregate(
    """distinct select on columns"""
    distinct_on: [order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_order_by!]

    """filter the rows returned"""
    where: order_item_bool_exp
  ): order_item_aggregate!
  price: numeric!

  """An array relationship"""
  product_categories(
    """distinct select on columns"""
    distinct_on: [product_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_category_order_by!]

    """filter the rows returned"""
    where: product_category_bool_exp
  ): [product_category!]!

  """An aggregate relationship"""
  product_categories_aggregate(
    """distinct select on columns"""
    distinct_on: [product_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_category_order_by!]

    """filter the rows returned"""
    where: product_category_bool_exp
  ): product_category_aggregate!

  """An array relationship"""
  product_customizable_areas(
    """distinct select on columns"""
    distinct_on: [product_customizable_area_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_customizable_area_order_by!]

    """filter the rows returned"""
    where: product_customizable_area_bool_exp
  ): [product_customizable_area!]!

  """An aggregate relationship"""
  product_customizable_areas_aggregate(
    """distinct select on columns"""
    distinct_on: [product_customizable_area_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_customizable_area_order_by!]

    """filter the rows returned"""
    where: product_customizable_area_bool_exp
  ): product_customizable_area_aggregate!
  product_no: String!
  properties(
    """JSON select path"""
    path: String
  ): jsonb
  quantity: Int

  """An array relationship"""
  questions(
    """distinct select on columns"""
    distinct_on: [question_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [question_order_by!]

    """filter the rows returned"""
    where: question_bool_exp
  ): [question!]!

  """An aggregate relationship"""
  questions_aggregate(
    """distinct select on columns"""
    distinct_on: [question_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [question_order_by!]

    """filter the rows returned"""
    where: question_bool_exp
  ): question_aggregate!

  """An array relationship"""
  reviews(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """An aggregate relationship"""
  reviews_aggregate(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): review_aggregate!

  """
  A computed field, executes function "get_average_score_of_product"
  """
  score: numeric

  """
  A computed field, executes function "generate_slug"
  """
  slug: String
  stock: Int
  stock_track: Boolean
  supplier_product_code: String

  """An object relationship"""
  tenant: user!
  tenant_id: uuid!

  """An array relationship"""
  user_favorites(
    """distinct select on columns"""
    distinct_on: [user_favorite_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_favorite_order_by!]

    """filter the rows returned"""
    where: user_favorite_bool_exp
  ): [user_favorite!]!

  """An aggregate relationship"""
  user_favorites_aggregate(
    """distinct select on columns"""
    distinct_on: [user_favorite_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_favorite_order_by!]

    """filter the rows returned"""
    where: user_favorite_bool_exp
  ): user_favorite_aggregate!
}

"""
aggregated selection of "product"
"""
type product_aggregate {
  aggregate: product_aggregate_fields
  nodes: [product!]!
}

input product_aggregate_bool_exp {
  bool_and: product_aggregate_bool_exp_bool_and
  bool_or: product_aggregate_bool_exp_bool_or
  count: product_aggregate_bool_exp_count
}

input product_aggregate_bool_exp_bool_and {
  arguments: product_select_column_product_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: product_bool_exp
  predicate: Boolean_comparison_exp!
}

input product_aggregate_bool_exp_bool_or {
  arguments: product_select_column_product_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: product_bool_exp
  predicate: Boolean_comparison_exp!
}

input product_aggregate_bool_exp_count {
  arguments: [product_select_column!]
  distinct: Boolean
  filter: product_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product"
"""
type product_aggregate_fields {
  avg: product_avg_fields
  count(columns: [product_select_column!], distinct: Boolean): Int!
  max: product_max_fields
  min: product_min_fields
  stddev: product_stddev_fields
  stddev_pop: product_stddev_pop_fields
  stddev_samp: product_stddev_samp_fields
  sum: product_sum_fields
  var_pop: product_var_pop_fields
  var_samp: product_var_samp_fields
  variance: product_variance_fields
}

"""
order by aggregate values of table "product"
"""
input product_aggregate_order_by {
  avg: product_avg_order_by
  count: order_by
  max: product_max_order_by
  min: product_min_order_by
  stddev: product_stddev_order_by
  stddev_pop: product_stddev_pop_order_by
  stddev_samp: product_stddev_samp_order_by
  sum: product_sum_order_by
  var_pop: product_var_pop_order_by
  var_samp: product_var_samp_order_by
  variance: product_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input product_append_input {
  delivery_time_ranges: jsonb
  properties: jsonb
}

"""
input type for inserting array relation for remote table "product"
"""
input product_arr_rel_insert_input {
  data: [product_insert_input!]!

  """upsert condition"""
  on_conflict: product_on_conflict
}

"""aggregate avg on columns"""
type product_avg_fields {
  category_id: Float
  discount_price: Float
  id: Float
  price: Float
  quantity: Float

  """
  A computed field, executes function "get_average_score_of_product"
  """
  score: numeric
  stock: Float
}

"""
order by avg() on columns of table "product"
"""
input product_avg_order_by {
  category_id: order_by
  discount_price: order_by
  id: order_by
  price: order_by
  quantity: order_by
  stock: order_by
}

"""
Boolean expression to filter rows from the table "product". All fields are combined with a logical 'AND'.
"""
input product_bool_exp {
  _and: [product_bool_exp!]
  _not: product_bool_exp
  _or: [product_bool_exp!]
  category_id: Int_comparison_exp
  delivery_end_time: timestamptz_comparison_exp
  delivery_start_time: timestamptz_comparison_exp
  delivery_time_ranges: jsonb_comparison_exp
  delivery_type: delivery_type_enum_comparison_exp
  delivery_type_rel: delivery_type_bool_exp
  description: String_comparison_exp
  discount_price: numeric_comparison_exp
  id: bigint_comparison_exp
  image_url: String_array_comparison_exp
  is_active: Boolean_comparison_exp
  is_service_free: Boolean_comparison_exp
  name: String_comparison_exp
  order_items: order_item_bool_exp
  order_items_aggregate: order_item_aggregate_bool_exp
  price: numeric_comparison_exp
  product_categories: product_category_bool_exp
  product_categories_aggregate: product_category_aggregate_bool_exp
  product_customizable_areas: product_customizable_area_bool_exp
  product_customizable_areas_aggregate: product_customizable_area_aggregate_bool_exp
  product_no: String_comparison_exp
  properties: jsonb_comparison_exp
  quantity: Int_comparison_exp
  questions: question_bool_exp
  questions_aggregate: question_aggregate_bool_exp
  reviews: review_bool_exp
  reviews_aggregate: review_aggregate_bool_exp
  score: numeric_comparison_exp
  slug: String_comparison_exp
  stock: Int_comparison_exp
  stock_track: Boolean_comparison_exp
  supplier_product_code: String_comparison_exp
  tenant: user_bool_exp
  tenant_id: uuid_comparison_exp
  user_favorites: user_favorite_bool_exp
  user_favorites_aggregate: user_favorite_aggregate_bool_exp
}

"""
columns and relationships of "product_category"
"""
type product_category {
  """An object relationship"""
  category: category!
  category_id: Int!
  id: bigint!
  is_active: Boolean

  """An object relationship"""
  product: product!
  product_id: bigint!
}

"""
aggregated selection of "product_category"
"""
type product_category_aggregate {
  aggregate: product_category_aggregate_fields
  nodes: [product_category!]!
}

input product_category_aggregate_bool_exp {
  bool_and: product_category_aggregate_bool_exp_bool_and
  bool_or: product_category_aggregate_bool_exp_bool_or
  count: product_category_aggregate_bool_exp_count
}

input product_category_aggregate_bool_exp_bool_and {
  arguments: product_category_select_column_product_category_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: product_category_bool_exp
  predicate: Boolean_comparison_exp!
}

input product_category_aggregate_bool_exp_bool_or {
  arguments: product_category_select_column_product_category_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: product_category_bool_exp
  predicate: Boolean_comparison_exp!
}

input product_category_aggregate_bool_exp_count {
  arguments: [product_category_select_column!]
  distinct: Boolean
  filter: product_category_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product_category"
"""
type product_category_aggregate_fields {
  avg: product_category_avg_fields
  count(columns: [product_category_select_column!], distinct: Boolean): Int!
  max: product_category_max_fields
  min: product_category_min_fields
  stddev: product_category_stddev_fields
  stddev_pop: product_category_stddev_pop_fields
  stddev_samp: product_category_stddev_samp_fields
  sum: product_category_sum_fields
  var_pop: product_category_var_pop_fields
  var_samp: product_category_var_samp_fields
  variance: product_category_variance_fields
}

"""
order by aggregate values of table "product_category"
"""
input product_category_aggregate_order_by {
  avg: product_category_avg_order_by
  count: order_by
  max: product_category_max_order_by
  min: product_category_min_order_by
  stddev: product_category_stddev_order_by
  stddev_pop: product_category_stddev_pop_order_by
  stddev_samp: product_category_stddev_samp_order_by
  sum: product_category_sum_order_by
  var_pop: product_category_var_pop_order_by
  var_samp: product_category_var_samp_order_by
  variance: product_category_variance_order_by
}

"""
input type for inserting array relation for remote table "product_category"
"""
input product_category_arr_rel_insert_input {
  data: [product_category_insert_input!]!

  """upsert condition"""
  on_conflict: product_category_on_conflict
}

"""aggregate avg on columns"""
type product_category_avg_fields {
  category_id: Float
  id: Float
  product_id: Float
}

"""
order by avg() on columns of table "product_category"
"""
input product_category_avg_order_by {
  category_id: order_by
  id: order_by
  product_id: order_by
}

"""
Boolean expression to filter rows from the table "product_category". All fields are combined with a logical 'AND'.
"""
input product_category_bool_exp {
  _and: [product_category_bool_exp!]
  _not: product_category_bool_exp
  _or: [product_category_bool_exp!]
  category: category_bool_exp
  category_id: Int_comparison_exp
  id: bigint_comparison_exp
  is_active: Boolean_comparison_exp
  product: product_bool_exp
  product_id: bigint_comparison_exp
}

"""
unique or primary key constraints on table "product_category"
"""
enum product_category_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_category_pkey

  """
  unique or primary key constraint on columns "product_id", "category_id"
  """
  product_category_product_id_category_id_key
}

"""
input type for incrementing numeric columns in table "product_category"
"""
input product_category_inc_input {
  category_id: Int
  id: bigint
  product_id: bigint
}

"""
input type for inserting data into table "product_category"
"""
input product_category_insert_input {
  category: category_obj_rel_insert_input
  category_id: Int
  id: bigint
  is_active: Boolean
  product: product_obj_rel_insert_input
  product_id: bigint
}

"""aggregate max on columns"""
type product_category_max_fields {
  category_id: Int
  id: bigint
  product_id: bigint
}

"""
order by max() on columns of table "product_category"
"""
input product_category_max_order_by {
  category_id: order_by
  id: order_by
  product_id: order_by
}

"""aggregate min on columns"""
type product_category_min_fields {
  category_id: Int
  id: bigint
  product_id: bigint
}

"""
order by min() on columns of table "product_category"
"""
input product_category_min_order_by {
  category_id: order_by
  id: order_by
  product_id: order_by
}

"""
response of any mutation on the table "product_category"
"""
type product_category_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_category!]!
}

"""
on_conflict condition type for table "product_category"
"""
input product_category_on_conflict {
  constraint: product_category_constraint!
  update_columns: [product_category_update_column!]! = []
  where: product_category_bool_exp
}

"""Ordering options when selecting data from "product_category"."""
input product_category_order_by {
  category: category_order_by
  category_id: order_by
  id: order_by
  is_active: order_by
  product: product_order_by
  product_id: order_by
}

"""primary key columns input for table: product_category"""
input product_category_pk_columns_input {
  id: bigint!
}

"""
select columns of table "product_category"
"""
enum product_category_select_column {
  """column name"""
  category_id

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  product_id
}

"""
select "product_category_aggregate_bool_exp_bool_and_arguments_columns" columns of table "product_category"
"""
enum product_category_select_column_product_category_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_active
}

"""
select "product_category_aggregate_bool_exp_bool_or_arguments_columns" columns of table "product_category"
"""
enum product_category_select_column_product_category_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_active
}

"""
input type for updating data in table "product_category"
"""
input product_category_set_input {
  category_id: Int
  id: bigint
  is_active: Boolean
  product_id: bigint
}

"""aggregate stddev on columns"""
type product_category_stddev_fields {
  category_id: Float
  id: Float
  product_id: Float
}

"""
order by stddev() on columns of table "product_category"
"""
input product_category_stddev_order_by {
  category_id: order_by
  id: order_by
  product_id: order_by
}

"""aggregate stddev_pop on columns"""
type product_category_stddev_pop_fields {
  category_id: Float
  id: Float
  product_id: Float
}

"""
order by stddev_pop() on columns of table "product_category"
"""
input product_category_stddev_pop_order_by {
  category_id: order_by
  id: order_by
  product_id: order_by
}

"""aggregate stddev_samp on columns"""
type product_category_stddev_samp_fields {
  category_id: Float
  id: Float
  product_id: Float
}

"""
order by stddev_samp() on columns of table "product_category"
"""
input product_category_stddev_samp_order_by {
  category_id: order_by
  id: order_by
  product_id: order_by
}

"""
Streaming cursor of the table "product_category"
"""
input product_category_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_category_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_category_stream_cursor_value_input {
  category_id: Int
  id: bigint
  is_active: Boolean
  product_id: bigint
}

"""aggregate sum on columns"""
type product_category_sum_fields {
  category_id: Int
  id: bigint
  product_id: bigint
}

"""
order by sum() on columns of table "product_category"
"""
input product_category_sum_order_by {
  category_id: order_by
  id: order_by
  product_id: order_by
}

"""
update columns of table "product_category"
"""
enum product_category_update_column {
  """column name"""
  category_id

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  product_id
}

input product_category_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: product_category_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_category_set_input

  """filter the rows which have to be updated"""
  where: product_category_bool_exp!
}

"""aggregate var_pop on columns"""
type product_category_var_pop_fields {
  category_id: Float
  id: Float
  product_id: Float
}

"""
order by var_pop() on columns of table "product_category"
"""
input product_category_var_pop_order_by {
  category_id: order_by
  id: order_by
  product_id: order_by
}

"""aggregate var_samp on columns"""
type product_category_var_samp_fields {
  category_id: Float
  id: Float
  product_id: Float
}

"""
order by var_samp() on columns of table "product_category"
"""
input product_category_var_samp_order_by {
  category_id: order_by
  id: order_by
  product_id: order_by
}

"""aggregate variance on columns"""
type product_category_variance_fields {
  category_id: Float
  id: Float
  product_id: Float
}

"""
order by variance() on columns of table "product_category"
"""
input product_category_variance_order_by {
  category_id: order_by
  id: order_by
  product_id: order_by
}

"""
unique or primary key constraints on table "product"
"""
enum product_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_pkey

  """
  unique or primary key constraint on columns "product_no"
  """
  product_product_no_key
}

"""
columns and relationships of "product_customizable_area"
"""
type product_customizable_area {
  count: Int!

  """An object relationship"""
  customizable_area: customizable_area!
  customizable_area_id: Int!
  id: bigint!
  max_character: Int

  """An object relationship"""
  product: product!
  product_id: Int!
}

"""
aggregated selection of "product_customizable_area"
"""
type product_customizable_area_aggregate {
  aggregate: product_customizable_area_aggregate_fields
  nodes: [product_customizable_area!]!
}

input product_customizable_area_aggregate_bool_exp {
  count: product_customizable_area_aggregate_bool_exp_count
}

input product_customizable_area_aggregate_bool_exp_count {
  arguments: [product_customizable_area_select_column!]
  distinct: Boolean
  filter: product_customizable_area_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "product_customizable_area"
"""
type product_customizable_area_aggregate_fields {
  avg: product_customizable_area_avg_fields
  count(columns: [product_customizable_area_select_column!], distinct: Boolean): Int!
  max: product_customizable_area_max_fields
  min: product_customizable_area_min_fields
  stddev: product_customizable_area_stddev_fields
  stddev_pop: product_customizable_area_stddev_pop_fields
  stddev_samp: product_customizable_area_stddev_samp_fields
  sum: product_customizable_area_sum_fields
  var_pop: product_customizable_area_var_pop_fields
  var_samp: product_customizable_area_var_samp_fields
  variance: product_customizable_area_variance_fields
}

"""
order by aggregate values of table "product_customizable_area"
"""
input product_customizable_area_aggregate_order_by {
  avg: product_customizable_area_avg_order_by
  count: order_by
  max: product_customizable_area_max_order_by
  min: product_customizable_area_min_order_by
  stddev: product_customizable_area_stddev_order_by
  stddev_pop: product_customizable_area_stddev_pop_order_by
  stddev_samp: product_customizable_area_stddev_samp_order_by
  sum: product_customizable_area_sum_order_by
  var_pop: product_customizable_area_var_pop_order_by
  var_samp: product_customizable_area_var_samp_order_by
  variance: product_customizable_area_variance_order_by
}

"""
input type for inserting array relation for remote table "product_customizable_area"
"""
input product_customizable_area_arr_rel_insert_input {
  data: [product_customizable_area_insert_input!]!

  """upsert condition"""
  on_conflict: product_customizable_area_on_conflict
}

"""aggregate avg on columns"""
type product_customizable_area_avg_fields {
  count: Float
  customizable_area_id: Float
  id: Float
  max_character: Float
  product_id: Float
}

"""
order by avg() on columns of table "product_customizable_area"
"""
input product_customizable_area_avg_order_by {
  count: order_by
  customizable_area_id: order_by
  id: order_by
  max_character: order_by
  product_id: order_by
}

"""
Boolean expression to filter rows from the table "product_customizable_area". All fields are combined with a logical 'AND'.
"""
input product_customizable_area_bool_exp {
  _and: [product_customizable_area_bool_exp!]
  _not: product_customizable_area_bool_exp
  _or: [product_customizable_area_bool_exp!]
  count: Int_comparison_exp
  customizable_area: customizable_area_bool_exp
  customizable_area_id: Int_comparison_exp
  id: bigint_comparison_exp
  max_character: Int_comparison_exp
  product: product_bool_exp
  product_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "product_customizable_area"
"""
enum product_customizable_area_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  product_customizable_area_pkey
}

"""
input type for incrementing numeric columns in table "product_customizable_area"
"""
input product_customizable_area_inc_input {
  count: Int
  customizable_area_id: Int
  id: bigint
  max_character: Int
  product_id: Int
}

"""
input type for inserting data into table "product_customizable_area"
"""
input product_customizable_area_insert_input {
  count: Int
  customizable_area: customizable_area_obj_rel_insert_input
  customizable_area_id: Int
  id: bigint
  max_character: Int
  product: product_obj_rel_insert_input
  product_id: Int
}

"""aggregate max on columns"""
type product_customizable_area_max_fields {
  count: Int
  customizable_area_id: Int
  id: bigint
  max_character: Int
  product_id: Int
}

"""
order by max() on columns of table "product_customizable_area"
"""
input product_customizable_area_max_order_by {
  count: order_by
  customizable_area_id: order_by
  id: order_by
  max_character: order_by
  product_id: order_by
}

"""aggregate min on columns"""
type product_customizable_area_min_fields {
  count: Int
  customizable_area_id: Int
  id: bigint
  max_character: Int
  product_id: Int
}

"""
order by min() on columns of table "product_customizable_area"
"""
input product_customizable_area_min_order_by {
  count: order_by
  customizable_area_id: order_by
  id: order_by
  max_character: order_by
  product_id: order_by
}

"""
response of any mutation on the table "product_customizable_area"
"""
type product_customizable_area_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_customizable_area!]!
}

"""
on_conflict condition type for table "product_customizable_area"
"""
input product_customizable_area_on_conflict {
  constraint: product_customizable_area_constraint!
  update_columns: [product_customizable_area_update_column!]! = []
  where: product_customizable_area_bool_exp
}

"""Ordering options when selecting data from "product_customizable_area"."""
input product_customizable_area_order_by {
  count: order_by
  customizable_area: customizable_area_order_by
  customizable_area_id: order_by
  id: order_by
  max_character: order_by
  product: product_order_by
  product_id: order_by
}

"""primary key columns input for table: product_customizable_area"""
input product_customizable_area_pk_columns_input {
  id: bigint!
}

"""
select columns of table "product_customizable_area"
"""
enum product_customizable_area_select_column {
  """column name"""
  count

  """column name"""
  customizable_area_id

  """column name"""
  id

  """column name"""
  max_character

  """column name"""
  product_id
}

"""
input type for updating data in table "product_customizable_area"
"""
input product_customizable_area_set_input {
  count: Int
  customizable_area_id: Int
  id: bigint
  max_character: Int
  product_id: Int
}

"""aggregate stddev on columns"""
type product_customizable_area_stddev_fields {
  count: Float
  customizable_area_id: Float
  id: Float
  max_character: Float
  product_id: Float
}

"""
order by stddev() on columns of table "product_customizable_area"
"""
input product_customizable_area_stddev_order_by {
  count: order_by
  customizable_area_id: order_by
  id: order_by
  max_character: order_by
  product_id: order_by
}

"""aggregate stddev_pop on columns"""
type product_customizable_area_stddev_pop_fields {
  count: Float
  customizable_area_id: Float
  id: Float
  max_character: Float
  product_id: Float
}

"""
order by stddev_pop() on columns of table "product_customizable_area"
"""
input product_customizable_area_stddev_pop_order_by {
  count: order_by
  customizable_area_id: order_by
  id: order_by
  max_character: order_by
  product_id: order_by
}

"""aggregate stddev_samp on columns"""
type product_customizable_area_stddev_samp_fields {
  count: Float
  customizable_area_id: Float
  id: Float
  max_character: Float
  product_id: Float
}

"""
order by stddev_samp() on columns of table "product_customizable_area"
"""
input product_customizable_area_stddev_samp_order_by {
  count: order_by
  customizable_area_id: order_by
  id: order_by
  max_character: order_by
  product_id: order_by
}

"""
Streaming cursor of the table "product_customizable_area"
"""
input product_customizable_area_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_customizable_area_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_customizable_area_stream_cursor_value_input {
  count: Int
  customizable_area_id: Int
  id: bigint
  max_character: Int
  product_id: Int
}

"""aggregate sum on columns"""
type product_customizable_area_sum_fields {
  count: Int
  customizable_area_id: Int
  id: bigint
  max_character: Int
  product_id: Int
}

"""
order by sum() on columns of table "product_customizable_area"
"""
input product_customizable_area_sum_order_by {
  count: order_by
  customizable_area_id: order_by
  id: order_by
  max_character: order_by
  product_id: order_by
}

"""
update columns of table "product_customizable_area"
"""
enum product_customizable_area_update_column {
  """column name"""
  count

  """column name"""
  customizable_area_id

  """column name"""
  id

  """column name"""
  max_character

  """column name"""
  product_id
}

input product_customizable_area_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: product_customizable_area_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_customizable_area_set_input

  """filter the rows which have to be updated"""
  where: product_customizable_area_bool_exp!
}

"""aggregate var_pop on columns"""
type product_customizable_area_var_pop_fields {
  count: Float
  customizable_area_id: Float
  id: Float
  max_character: Float
  product_id: Float
}

"""
order by var_pop() on columns of table "product_customizable_area"
"""
input product_customizable_area_var_pop_order_by {
  count: order_by
  customizable_area_id: order_by
  id: order_by
  max_character: order_by
  product_id: order_by
}

"""aggregate var_samp on columns"""
type product_customizable_area_var_samp_fields {
  count: Float
  customizable_area_id: Float
  id: Float
  max_character: Float
  product_id: Float
}

"""
order by var_samp() on columns of table "product_customizable_area"
"""
input product_customizable_area_var_samp_order_by {
  count: order_by
  customizable_area_id: order_by
  id: order_by
  max_character: order_by
  product_id: order_by
}

"""aggregate variance on columns"""
type product_customizable_area_variance_fields {
  count: Float
  customizable_area_id: Float
  id: Float
  max_character: Float
  product_id: Float
}

"""
order by variance() on columns of table "product_customizable_area"
"""
input product_customizable_area_variance_order_by {
  count: order_by
  customizable_area_id: order_by
  id: order_by
  max_character: order_by
  product_id: order_by
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input product_delete_at_path_input {
  delivery_time_ranges: [String!]
  properties: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input product_delete_elem_input {
  delivery_time_ranges: Int
  properties: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input product_delete_key_input {
  delivery_time_ranges: String
  properties: String
}

"""
columns and relationships of "product_delivery_city_info"
"""
type product_delivery_city_info {
  city_code: Int
  city_name: String
  id: Int
}

type product_delivery_city_info_aggregate {
  aggregate: product_delivery_city_info_aggregate_fields
  nodes: [product_delivery_city_info!]!
}

"""
aggregate fields of "product_delivery_city_info"
"""
type product_delivery_city_info_aggregate_fields {
  avg: product_delivery_city_info_avg_fields
  count(columns: [product_delivery_city_info_select_column!], distinct: Boolean): Int!
  max: product_delivery_city_info_max_fields
  min: product_delivery_city_info_min_fields
  stddev: product_delivery_city_info_stddev_fields
  stddev_pop: product_delivery_city_info_stddev_pop_fields
  stddev_samp: product_delivery_city_info_stddev_samp_fields
  sum: product_delivery_city_info_sum_fields
  var_pop: product_delivery_city_info_var_pop_fields
  var_samp: product_delivery_city_info_var_samp_fields
  variance: product_delivery_city_info_variance_fields
}

"""aggregate avg on columns"""
type product_delivery_city_info_avg_fields {
  city_code: Float
  id: Float
}

"""
Boolean expression to filter rows from the table "product_delivery_city_info". All fields are combined with a logical 'AND'.
"""
input product_delivery_city_info_bool_exp {
  _and: [product_delivery_city_info_bool_exp!]
  _not: product_delivery_city_info_bool_exp
  _or: [product_delivery_city_info_bool_exp!]
  city_code: Int_comparison_exp
  city_name: String_comparison_exp
  id: Int_comparison_exp
}

"""
input type for incrementing numeric columns in table "product_delivery_city_info"
"""
input product_delivery_city_info_inc_input {
  city_code: Int
  id: Int
}

"""
input type for inserting data into table "product_delivery_city_info"
"""
input product_delivery_city_info_insert_input {
  city_code: Int
  city_name: String
  id: Int
}

"""aggregate max on columns"""
type product_delivery_city_info_max_fields {
  city_code: Int
  city_name: String
  id: Int
}

"""aggregate min on columns"""
type product_delivery_city_info_min_fields {
  city_code: Int
  city_name: String
  id: Int
}

"""
response of any mutation on the table "product_delivery_city_info"
"""
type product_delivery_city_info_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product_delivery_city_info!]!
}

"""
Ordering options when selecting data from "product_delivery_city_info".
"""
input product_delivery_city_info_order_by {
  city_code: order_by
  city_name: order_by
  id: order_by
}

"""
select columns of table "product_delivery_city_info"
"""
enum product_delivery_city_info_select_column {
  """column name"""
  city_code

  """column name"""
  city_name

  """column name"""
  id
}

"""
input type for updating data in table "product_delivery_city_info"
"""
input product_delivery_city_info_set_input {
  city_code: Int
  city_name: String
  id: Int
}

"""aggregate stddev on columns"""
type product_delivery_city_info_stddev_fields {
  city_code: Float
  id: Float
}

"""aggregate stddev_pop on columns"""
type product_delivery_city_info_stddev_pop_fields {
  city_code: Float
  id: Float
}

"""aggregate stddev_samp on columns"""
type product_delivery_city_info_stddev_samp_fields {
  city_code: Float
  id: Float
}

"""
Streaming cursor of the table "product_delivery_city_info"
"""
input product_delivery_city_info_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_delivery_city_info_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_delivery_city_info_stream_cursor_value_input {
  city_code: Int
  city_name: String
  id: Int
}

"""aggregate sum on columns"""
type product_delivery_city_info_sum_fields {
  city_code: Int
  id: Int
}

input product_delivery_city_info_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: product_delivery_city_info_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_delivery_city_info_set_input

  """filter the rows which have to be updated"""
  where: product_delivery_city_info_bool_exp!
}

"""aggregate var_pop on columns"""
type product_delivery_city_info_var_pop_fields {
  city_code: Float
  id: Float
}

"""aggregate var_samp on columns"""
type product_delivery_city_info_var_samp_fields {
  city_code: Float
  id: Float
}

"""aggregate variance on columns"""
type product_delivery_city_info_variance_fields {
  city_code: Float
  id: Float
}

"""
input type for incrementing numeric columns in table "product"
"""
input product_inc_input {
  category_id: Int
  discount_price: numeric
  id: bigint
  price: numeric
  quantity: Int
  stock: Int
}

"""
input type for inserting data into table "product"
"""
input product_insert_input {
  category_id: Int
  delivery_end_time: timestamptz
  delivery_start_time: timestamptz
  delivery_time_ranges: jsonb
  delivery_type: delivery_type_enum
  delivery_type_rel: delivery_type_obj_rel_insert_input
  description: String
  discount_price: numeric
  id: bigint
  image_url: [String!]
  is_active: Boolean
  is_service_free: Boolean
  name: String
  order_items: order_item_arr_rel_insert_input
  price: numeric
  product_categories: product_category_arr_rel_insert_input
  product_customizable_areas: product_customizable_area_arr_rel_insert_input
  product_no: String
  properties: jsonb
  quantity: Int
  questions: question_arr_rel_insert_input
  reviews: review_arr_rel_insert_input
  stock: Int
  stock_track: Boolean
  supplier_product_code: String
  tenant: user_obj_rel_insert_input
  tenant_id: uuid
  user_favorites: user_favorite_arr_rel_insert_input
}

"""aggregate max on columns"""
type product_max_fields {
  category_id: Int
  delivery_end_time: timestamptz
  delivery_start_time: timestamptz
  description: String
  discount_price: numeric
  id: bigint
  image_url: [String!]
  name: String
  price: numeric
  product_no: String
  quantity: Int

  """
  A computed field, executes function "get_average_score_of_product"
  """
  score: numeric

  """
  A computed field, executes function "generate_slug"
  """
  slug: String
  stock: Int
  supplier_product_code: String
  tenant_id: uuid
}

"""
order by max() on columns of table "product"
"""
input product_max_order_by {
  category_id: order_by
  delivery_end_time: order_by
  delivery_start_time: order_by
  description: order_by
  discount_price: order_by
  id: order_by
  image_url: order_by
  name: order_by
  price: order_by
  product_no: order_by
  quantity: order_by
  stock: order_by
  supplier_product_code: order_by
  tenant_id: order_by
}

"""aggregate min on columns"""
type product_min_fields {
  category_id: Int
  delivery_end_time: timestamptz
  delivery_start_time: timestamptz
  description: String
  discount_price: numeric
  id: bigint
  image_url: [String!]
  name: String
  price: numeric
  product_no: String
  quantity: Int

  """
  A computed field, executes function "get_average_score_of_product"
  """
  score: numeric

  """
  A computed field, executes function "generate_slug"
  """
  slug: String
  stock: Int
  supplier_product_code: String
  tenant_id: uuid
}

"""
order by min() on columns of table "product"
"""
input product_min_order_by {
  category_id: order_by
  delivery_end_time: order_by
  delivery_start_time: order_by
  description: order_by
  discount_price: order_by
  id: order_by
  image_url: order_by
  name: order_by
  price: order_by
  product_no: order_by
  quantity: order_by
  stock: order_by
  supplier_product_code: order_by
  tenant_id: order_by
}

"""
response of any mutation on the table "product"
"""
type product_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [product!]!
}

"""
input type for inserting object relation for remote table "product"
"""
input product_obj_rel_insert_input {
  data: product_insert_input!

  """upsert condition"""
  on_conflict: product_on_conflict
}

"""
on_conflict condition type for table "product"
"""
input product_on_conflict {
  constraint: product_constraint!
  update_columns: [product_update_column!]! = []
  where: product_bool_exp
}

"""Ordering options when selecting data from "product"."""
input product_order_by {
  category_id: order_by
  delivery_end_time: order_by
  delivery_start_time: order_by
  delivery_time_ranges: order_by
  delivery_type: order_by
  delivery_type_rel: delivery_type_order_by
  description: order_by
  discount_price: order_by
  id: order_by
  image_url: order_by
  is_active: order_by
  is_service_free: order_by
  name: order_by
  order_items_aggregate: order_item_aggregate_order_by
  price: order_by
  product_categories_aggregate: product_category_aggregate_order_by
  product_customizable_areas_aggregate: product_customizable_area_aggregate_order_by
  product_no: order_by
  properties: order_by
  quantity: order_by
  questions_aggregate: question_aggregate_order_by
  reviews_aggregate: review_aggregate_order_by
  score: order_by
  slug: order_by
  stock: order_by
  stock_track: order_by
  supplier_product_code: order_by
  tenant: user_order_by
  tenant_id: order_by
  user_favorites_aggregate: user_favorite_aggregate_order_by
}

"""primary key columns input for table: product"""
input product_pk_columns_input {
  id: bigint!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input product_prepend_input {
  delivery_time_ranges: jsonb
  properties: jsonb
}

"""
select columns of table "product"
"""
enum product_select_column {
  """column name"""
  category_id

  """column name"""
  delivery_end_time

  """column name"""
  delivery_start_time

  """column name"""
  delivery_time_ranges

  """column name"""
  delivery_type

  """column name"""
  description

  """column name"""
  discount_price

  """column name"""
  id

  """column name"""
  image_url

  """column name"""
  is_active

  """column name"""
  is_service_free

  """column name"""
  name

  """column name"""
  price

  """column name"""
  product_no

  """column name"""
  properties

  """column name"""
  quantity

  """column name"""
  stock

  """column name"""
  stock_track

  """column name"""
  supplier_product_code

  """column name"""
  tenant_id
}

"""
select "product_aggregate_bool_exp_bool_and_arguments_columns" columns of table "product"
"""
enum product_select_column_product_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_active

  """column name"""
  is_service_free

  """column name"""
  stock_track
}

"""
select "product_aggregate_bool_exp_bool_or_arguments_columns" columns of table "product"
"""
enum product_select_column_product_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_active

  """column name"""
  is_service_free

  """column name"""
  stock_track
}

"""
input type for updating data in table "product"
"""
input product_set_input {
  category_id: Int
  delivery_end_time: timestamptz
  delivery_start_time: timestamptz
  delivery_time_ranges: jsonb
  delivery_type: delivery_type_enum
  description: String
  discount_price: numeric
  id: bigint
  image_url: [String!]
  is_active: Boolean
  is_service_free: Boolean
  name: String
  price: numeric
  product_no: String
  properties: jsonb
  quantity: Int
  stock: Int
  stock_track: Boolean
  supplier_product_code: String
  tenant_id: uuid
}

"""aggregate stddev on columns"""
type product_stddev_fields {
  category_id: Float
  discount_price: Float
  id: Float
  price: Float
  quantity: Float

  """
  A computed field, executes function "get_average_score_of_product"
  """
  score: numeric
  stock: Float
}

"""
order by stddev() on columns of table "product"
"""
input product_stddev_order_by {
  category_id: order_by
  discount_price: order_by
  id: order_by
  price: order_by
  quantity: order_by
  stock: order_by
}

"""aggregate stddev_pop on columns"""
type product_stddev_pop_fields {
  category_id: Float
  discount_price: Float
  id: Float
  price: Float
  quantity: Float

  """
  A computed field, executes function "get_average_score_of_product"
  """
  score: numeric
  stock: Float
}

"""
order by stddev_pop() on columns of table "product"
"""
input product_stddev_pop_order_by {
  category_id: order_by
  discount_price: order_by
  id: order_by
  price: order_by
  quantity: order_by
  stock: order_by
}

"""aggregate stddev_samp on columns"""
type product_stddev_samp_fields {
  category_id: Float
  discount_price: Float
  id: Float
  price: Float
  quantity: Float

  """
  A computed field, executes function "get_average_score_of_product"
  """
  score: numeric
  stock: Float
}

"""
order by stddev_samp() on columns of table "product"
"""
input product_stddev_samp_order_by {
  category_id: order_by
  discount_price: order_by
  id: order_by
  price: order_by
  quantity: order_by
  stock: order_by
}

"""
Streaming cursor of the table "product"
"""
input product_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: product_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input product_stream_cursor_value_input {
  category_id: Int
  delivery_end_time: timestamptz
  delivery_start_time: timestamptz
  delivery_time_ranges: jsonb
  delivery_type: delivery_type_enum
  description: String
  discount_price: numeric
  id: bigint
  image_url: [String!]
  is_active: Boolean
  is_service_free: Boolean
  name: String
  price: numeric
  product_no: String
  properties: jsonb
  quantity: Int
  stock: Int
  stock_track: Boolean
  supplier_product_code: String
  tenant_id: uuid
}

"""aggregate sum on columns"""
type product_sum_fields {
  category_id: Int
  discount_price: numeric
  id: bigint
  price: numeric
  quantity: Int

  """
  A computed field, executes function "get_average_score_of_product"
  """
  score: numeric
  stock: Int
}

"""
order by sum() on columns of table "product"
"""
input product_sum_order_by {
  category_id: order_by
  discount_price: order_by
  id: order_by
  price: order_by
  quantity: order_by
  stock: order_by
}

"""
update columns of table "product"
"""
enum product_update_column {
  """column name"""
  category_id

  """column name"""
  delivery_end_time

  """column name"""
  delivery_start_time

  """column name"""
  delivery_time_ranges

  """column name"""
  delivery_type

  """column name"""
  description

  """column name"""
  discount_price

  """column name"""
  id

  """column name"""
  image_url

  """column name"""
  is_active

  """column name"""
  is_service_free

  """column name"""
  name

  """column name"""
  price

  """column name"""
  product_no

  """column name"""
  properties

  """column name"""
  quantity

  """column name"""
  stock

  """column name"""
  stock_track

  """column name"""
  supplier_product_code

  """column name"""
  tenant_id
}

input product_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: product_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: product_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: product_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: product_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: product_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: product_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: product_set_input

  """filter the rows which have to be updated"""
  where: product_bool_exp!
}

"""aggregate var_pop on columns"""
type product_var_pop_fields {
  category_id: Float
  discount_price: Float
  id: Float
  price: Float
  quantity: Float

  """
  A computed field, executes function "get_average_score_of_product"
  """
  score: numeric
  stock: Float
}

"""
order by var_pop() on columns of table "product"
"""
input product_var_pop_order_by {
  category_id: order_by
  discount_price: order_by
  id: order_by
  price: order_by
  quantity: order_by
  stock: order_by
}

"""aggregate var_samp on columns"""
type product_var_samp_fields {
  category_id: Float
  discount_price: Float
  id: Float
  price: Float
  quantity: Float

  """
  A computed field, executes function "get_average_score_of_product"
  """
  score: numeric
  stock: Float
}

"""
order by var_samp() on columns of table "product"
"""
input product_var_samp_order_by {
  category_id: order_by
  discount_price: order_by
  id: order_by
  price: order_by
  quantity: order_by
  stock: order_by
}

"""aggregate variance on columns"""
type product_variance_fields {
  category_id: Float
  discount_price: Float
  id: Float
  price: Float
  quantity: Float

  """
  A computed field, executes function "get_average_score_of_product"
  """
  score: numeric
  stock: Float
}

"""
order by variance() on columns of table "product"
"""
input product_variance_order_by {
  category_id: order_by
  discount_price: order_by
  id: order_by
  price: order_by
  quantity: order_by
  stock: order_by
}

"""
columns and relationships of "quarter"
"""
type quarter {
  code: Int!

  """An object relationship"""
  district: district!
  id: Int!
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String!
  parent_id: Int!
}

"""
aggregated selection of "quarter"
"""
type quarter_aggregate {
  aggregate: quarter_aggregate_fields
  nodes: [quarter!]!
}

input quarter_aggregate_bool_exp {
  count: quarter_aggregate_bool_exp_count
}

input quarter_aggregate_bool_exp_count {
  arguments: [quarter_select_column!]
  distinct: Boolean
  filter: quarter_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "quarter"
"""
type quarter_aggregate_fields {
  avg: quarter_avg_fields
  count(columns: [quarter_select_column!], distinct: Boolean): Int!
  max: quarter_max_fields
  min: quarter_min_fields
  stddev: quarter_stddev_fields
  stddev_pop: quarter_stddev_pop_fields
  stddev_samp: quarter_stddev_samp_fields
  sum: quarter_sum_fields
  var_pop: quarter_var_pop_fields
  var_samp: quarter_var_samp_fields
  variance: quarter_variance_fields
}

"""
order by aggregate values of table "quarter"
"""
input quarter_aggregate_order_by {
  avg: quarter_avg_order_by
  count: order_by
  max: quarter_max_order_by
  min: quarter_min_order_by
  stddev: quarter_stddev_order_by
  stddev_pop: quarter_stddev_pop_order_by
  stddev_samp: quarter_stddev_samp_order_by
  sum: quarter_sum_order_by
  var_pop: quarter_var_pop_order_by
  var_samp: quarter_var_samp_order_by
  variance: quarter_variance_order_by
}

"""
input type for inserting array relation for remote table "quarter"
"""
input quarter_arr_rel_insert_input {
  data: [quarter_insert_input!]!

  """upsert condition"""
  on_conflict: quarter_on_conflict
}

"""aggregate avg on columns"""
type quarter_avg_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
order by avg() on columns of table "quarter"
"""
input quarter_avg_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

"""
Boolean expression to filter rows from the table "quarter". All fields are combined with a logical 'AND'.
"""
input quarter_bool_exp {
  _and: [quarter_bool_exp!]
  _not: quarter_bool_exp
  _or: [quarter_bool_exp!]
  code: Int_comparison_exp
  district: district_bool_exp
  id: Int_comparison_exp
  maxlatitude: String_comparison_exp
  maxlongitude: String_comparison_exp
  minlatitude: String_comparison_exp
  minlongitude: String_comparison_exp
  name: String_comparison_exp
  parent_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "quarter"
"""
enum quarter_constraint {
  """
  unique or primary key constraint on columns "code"
  """
  quarter_code_key

  """
  unique or primary key constraint on columns "id"
  """
  quarter_pkey
}

"""
input type for incrementing numeric columns in table "quarter"
"""
input quarter_inc_input {
  code: Int
  id: Int
  parent_id: Int
}

"""
input type for inserting data into table "quarter"
"""
input quarter_insert_input {
  code: Int
  district: district_obj_rel_insert_input
  id: Int
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String
  parent_id: Int
}

"""aggregate max on columns"""
type quarter_max_fields {
  code: Int
  id: Int
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String
  parent_id: Int
}

"""
order by max() on columns of table "quarter"
"""
input quarter_max_order_by {
  code: order_by
  id: order_by
  maxlatitude: order_by
  maxlongitude: order_by
  minlatitude: order_by
  minlongitude: order_by
  name: order_by
  parent_id: order_by
}

"""aggregate min on columns"""
type quarter_min_fields {
  code: Int
  id: Int
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String
  parent_id: Int
}

"""
order by min() on columns of table "quarter"
"""
input quarter_min_order_by {
  code: order_by
  id: order_by
  maxlatitude: order_by
  maxlongitude: order_by
  minlatitude: order_by
  minlongitude: order_by
  name: order_by
  parent_id: order_by
}

"""
response of any mutation on the table "quarter"
"""
type quarter_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [quarter!]!
}

"""
input type for inserting object relation for remote table "quarter"
"""
input quarter_obj_rel_insert_input {
  data: quarter_insert_input!

  """upsert condition"""
  on_conflict: quarter_on_conflict
}

"""
on_conflict condition type for table "quarter"
"""
input quarter_on_conflict {
  constraint: quarter_constraint!
  update_columns: [quarter_update_column!]! = []
  where: quarter_bool_exp
}

"""Ordering options when selecting data from "quarter"."""
input quarter_order_by {
  code: order_by
  district: district_order_by
  id: order_by
  maxlatitude: order_by
  maxlongitude: order_by
  minlatitude: order_by
  minlongitude: order_by
  name: order_by
  parent_id: order_by
}

"""primary key columns input for table: quarter"""
input quarter_pk_columns_input {
  id: Int!
}

"""
select columns of table "quarter"
"""
enum quarter_select_column {
  """column name"""
  code

  """column name"""
  id

  """column name"""
  maxlatitude

  """column name"""
  maxlongitude

  """column name"""
  minlatitude

  """column name"""
  minlongitude

  """column name"""
  name

  """column name"""
  parent_id
}

"""
input type for updating data in table "quarter"
"""
input quarter_set_input {
  code: Int
  id: Int
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String
  parent_id: Int
}

"""aggregate stddev on columns"""
type quarter_stddev_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
order by stddev() on columns of table "quarter"
"""
input quarter_stddev_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

"""aggregate stddev_pop on columns"""
type quarter_stddev_pop_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
order by stddev_pop() on columns of table "quarter"
"""
input quarter_stddev_pop_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

"""aggregate stddev_samp on columns"""
type quarter_stddev_samp_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
order by stddev_samp() on columns of table "quarter"
"""
input quarter_stddev_samp_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

"""
Streaming cursor of the table "quarter"
"""
input quarter_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: quarter_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input quarter_stream_cursor_value_input {
  code: Int
  id: Int
  maxlatitude: String
  maxlongitude: String
  minlatitude: String
  minlongitude: String
  name: String
  parent_id: Int
}

"""aggregate sum on columns"""
type quarter_sum_fields {
  code: Int
  id: Int
  parent_id: Int
}

"""
order by sum() on columns of table "quarter"
"""
input quarter_sum_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

"""
update columns of table "quarter"
"""
enum quarter_update_column {
  """column name"""
  code

  """column name"""
  id

  """column name"""
  maxlatitude

  """column name"""
  maxlongitude

  """column name"""
  minlatitude

  """column name"""
  minlongitude

  """column name"""
  name

  """column name"""
  parent_id
}

input quarter_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: quarter_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: quarter_set_input

  """filter the rows which have to be updated"""
  where: quarter_bool_exp!
}

"""aggregate var_pop on columns"""
type quarter_var_pop_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
order by var_pop() on columns of table "quarter"
"""
input quarter_var_pop_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

"""aggregate var_samp on columns"""
type quarter_var_samp_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
order by var_samp() on columns of table "quarter"
"""
input quarter_var_samp_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

"""aggregate variance on columns"""
type quarter_variance_fields {
  code: Float
  id: Float
  parent_id: Float
}

"""
order by variance() on columns of table "quarter"
"""
input quarter_variance_order_by {
  code: order_by
  id: order_by
  parent_id: order_by
}

type query_root {
  """
  fetch data from the table: "address_type"
  """
  address_type(
    """distinct select on columns"""
    distinct_on: [address_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_type_order_by!]

    """filter the rows returned"""
    where: address_type_bool_exp
  ): [address_type!]!

  """
  fetch aggregated fields from the table: "address_type"
  """
  address_type_aggregate(
    """distinct select on columns"""
    distinct_on: [address_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_type_order_by!]

    """filter the rows returned"""
    where: address_type_bool_exp
  ): address_type_aggregate!

  """fetch data from the table: "address_type" using primary key columns"""
  address_type_by_pk(value: String!): address_type

  """
  fetch data from the table: "answer"
  """
  answer(
    """distinct select on columns"""
    distinct_on: [answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [answer_order_by!]

    """filter the rows returned"""
    where: answer_bool_exp
  ): [answer!]!

  """
  fetch aggregated fields from the table: "answer"
  """
  answer_aggregate(
    """distinct select on columns"""
    distinct_on: [answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [answer_order_by!]

    """filter the rows returned"""
    where: answer_bool_exp
  ): answer_aggregate!

  """fetch data from the table: "answer" using primary key columns"""
  answer_by_pk(id: bigint!): answer

  """
  fetch data from the table: "cart"
  """
  cart(
    """distinct select on columns"""
    distinct_on: [cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cart_order_by!]

    """filter the rows returned"""
    where: cart_bool_exp
  ): [cart!]!

  """
  fetch aggregated fields from the table: "cart"
  """
  cart_aggregate(
    """distinct select on columns"""
    distinct_on: [cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cart_order_by!]

    """filter the rows returned"""
    where: cart_bool_exp
  ): cart_aggregate!

  """fetch data from the table: "cart" using primary key columns"""
  cart_by_pk(id: uuid!): cart

  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): [category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  category_aggregate(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): category_aggregate!

  """fetch data from the table: "category" using primary key columns"""
  category_by_pk(id: Int!): category

  """
  fetch data from the table: "chat_thread"
  """
  chat_thread(
    """distinct select on columns"""
    distinct_on: [chat_thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_thread_order_by!]

    """filter the rows returned"""
    where: chat_thread_bool_exp
  ): [chat_thread!]!

  """
  fetch aggregated fields from the table: "chat_thread"
  """
  chat_thread_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_thread_order_by!]

    """filter the rows returned"""
    where: chat_thread_bool_exp
  ): chat_thread_aggregate!

  """fetch data from the table: "chat_thread" using primary key columns"""
  chat_thread_by_pk(id: uuid!): chat_thread

  """
  fetch data from the table: "city"
  """
  city(
    """distinct select on columns"""
    distinct_on: [city_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [city_order_by!]

    """filter the rows returned"""
    where: city_bool_exp
  ): [city!]!

  """
  fetch aggregated fields from the table: "city"
  """
  city_aggregate(
    """distinct select on columns"""
    distinct_on: [city_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [city_order_by!]

    """filter the rows returned"""
    where: city_bool_exp
  ): city_aggregate!

  """fetch data from the table: "city" using primary key columns"""
  city_by_pk(id: Int!): city

  """
  fetch data from the table: "company"
  """
  company(
    """distinct select on columns"""
    distinct_on: [company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_order_by!]

    """filter the rows returned"""
    where: company_bool_exp
  ): [company!]!

  """
  fetch aggregated fields from the table: "company"
  """
  company_aggregate(
    """distinct select on columns"""
    distinct_on: [company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_order_by!]

    """filter the rows returned"""
    where: company_bool_exp
  ): company_aggregate!

  """fetch data from the table: "company" using primary key columns"""
  company_by_pk(id: uuid!): company

  """
  fetch data from the table: "company_category"
  """
  company_category(
    """distinct select on columns"""
    distinct_on: [company_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_category_order_by!]

    """filter the rows returned"""
    where: company_category_bool_exp
  ): [company_category!]!

  """
  fetch aggregated fields from the table: "company_category"
  """
  company_category_aggregate(
    """distinct select on columns"""
    distinct_on: [company_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_category_order_by!]

    """filter the rows returned"""
    where: company_category_bool_exp
  ): company_category_aggregate!

  """
  fetch data from the table: "company_category" using primary key columns
  """
  company_category_by_pk(id: Int!): company_category

  """
  fetch data from the table: "company_type"
  """
  company_type(
    """distinct select on columns"""
    distinct_on: [company_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_type_order_by!]

    """filter the rows returned"""
    where: company_type_bool_exp
  ): [company_type!]!

  """
  fetch aggregated fields from the table: "company_type"
  """
  company_type_aggregate(
    """distinct select on columns"""
    distinct_on: [company_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_type_order_by!]

    """filter the rows returned"""
    where: company_type_bool_exp
  ): company_type_aggregate!

  """fetch data from the table: "company_type" using primary key columns"""
  company_type_by_pk(value: String!): company_type

  """
  fetch data from the table: "coupon"
  """
  coupon(
    """distinct select on columns"""
    distinct_on: [coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coupon_order_by!]

    """filter the rows returned"""
    where: coupon_bool_exp
  ): [coupon!]!

  """
  fetch aggregated fields from the table: "coupon"
  """
  coupon_aggregate(
    """distinct select on columns"""
    distinct_on: [coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coupon_order_by!]

    """filter the rows returned"""
    where: coupon_bool_exp
  ): coupon_aggregate!

  """fetch data from the table: "coupon" using primary key columns"""
  coupon_by_pk(id: uuid!): coupon

  """
  fetch data from the table: "customizable_area"
  """
  customizable_area(
    """distinct select on columns"""
    distinct_on: [customizable_area_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customizable_area_order_by!]

    """filter the rows returned"""
    where: customizable_area_bool_exp
  ): [customizable_area!]!

  """
  fetch aggregated fields from the table: "customizable_area"
  """
  customizable_area_aggregate(
    """distinct select on columns"""
    distinct_on: [customizable_area_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customizable_area_order_by!]

    """filter the rows returned"""
    where: customizable_area_bool_exp
  ): customizable_area_aggregate!

  """
  fetch data from the table: "customizable_area" using primary key columns
  """
  customizable_area_by_pk(id: Int!): customizable_area

  """
  fetch data from the table: "delivery_type"
  """
  delivery_type(
    """distinct select on columns"""
    distinct_on: [delivery_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_type_order_by!]

    """filter the rows returned"""
    where: delivery_type_bool_exp
  ): [delivery_type!]!

  """
  fetch aggregated fields from the table: "delivery_type"
  """
  delivery_type_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_type_order_by!]

    """filter the rows returned"""
    where: delivery_type_bool_exp
  ): delivery_type_aggregate!

  """fetch data from the table: "delivery_type" using primary key columns"""
  delivery_type_by_pk(value: String!): delivery_type

  """
  fetch data from the table: "district"
  """
  district(
    """distinct select on columns"""
    distinct_on: [district_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [district_order_by!]

    """filter the rows returned"""
    where: district_bool_exp
  ): [district!]!

  """
  fetch aggregated fields from the table: "district"
  """
  district_aggregate(
    """distinct select on columns"""
    distinct_on: [district_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [district_order_by!]

    """filter the rows returned"""
    where: district_bool_exp
  ): district_aggregate!

  """fetch data from the table: "district" using primary key columns"""
  district_by_pk(id: Int!): district

  """
  execute function "get_product_delivery_cities" which returns "product_delivery_city_info"
  """
  get_product_delivery_cities(
    """
    input parameters for function "get_product_delivery_cities"
    """
    args: get_product_delivery_cities_args!

    """distinct select on columns"""
    distinct_on: [product_delivery_city_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_delivery_city_info_order_by!]

    """filter the rows returned"""
    where: product_delivery_city_info_bool_exp
  ): [product_delivery_city_info!]!

  """
  execute function "get_product_delivery_cities" and query aggregates on result of table type "product_delivery_city_info"
  """
  get_product_delivery_cities_aggregate(
    """
    input parameters for function "get_product_delivery_cities_aggregate"
    """
    args: get_product_delivery_cities_args!

    """distinct select on columns"""
    distinct_on: [product_delivery_city_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_delivery_city_info_order_by!]

    """filter the rows returned"""
    where: product_delivery_city_info_bool_exp
  ): product_delivery_city_info_aggregate!

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  message_aggregate(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!

  """fetch data from the table: "message" using primary key columns"""
  message_by_pk(id: bigint!): message

  """
  fetch data from the table: "order"
  """
  order(
    """distinct select on columns"""
    distinct_on: [order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_order_by!]

    """filter the rows returned"""
    where: order_bool_exp
  ): [order!]!

  """
  fetch data from the table: "order_address"
  """
  order_address(
    """distinct select on columns"""
    distinct_on: [order_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_address_order_by!]

    """filter the rows returned"""
    where: order_address_bool_exp
  ): [order_address!]!

  """
  fetch aggregated fields from the table: "order_address"
  """
  order_address_aggregate(
    """distinct select on columns"""
    distinct_on: [order_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_address_order_by!]

    """filter the rows returned"""
    where: order_address_bool_exp
  ): order_address_aggregate!

  """fetch data from the table: "order_address" using primary key columns"""
  order_address_by_pk(id: Int!): order_address

  """
  fetch aggregated fields from the table: "order"
  """
  order_aggregate(
    """distinct select on columns"""
    distinct_on: [order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_order_by!]

    """filter the rows returned"""
    where: order_bool_exp
  ): order_aggregate!

  """fetch data from the table: "order" using primary key columns"""
  order_by_pk(id: uuid!): order

  """
  fetch data from the table: "order_item"
  """
  order_item(
    """distinct select on columns"""
    distinct_on: [order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_order_by!]

    """filter the rows returned"""
    where: order_item_bool_exp
  ): [order_item!]!

  """
  fetch aggregated fields from the table: "order_item"
  """
  order_item_aggregate(
    """distinct select on columns"""
    distinct_on: [order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_order_by!]

    """filter the rows returned"""
    where: order_item_bool_exp
  ): order_item_aggregate!

  """fetch data from the table: "order_item" using primary key columns"""
  order_item_by_pk(id: bigint!): order_item

  """
  fetch data from the table: "order_item_special_image"
  """
  order_item_special_image(
    """distinct select on columns"""
    distinct_on: [order_item_special_image_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_special_image_order_by!]

    """filter the rows returned"""
    where: order_item_special_image_bool_exp
  ): [order_item_special_image!]!

  """
  fetch aggregated fields from the table: "order_item_special_image"
  """
  order_item_special_image_aggregate(
    """distinct select on columns"""
    distinct_on: [order_item_special_image_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_special_image_order_by!]

    """filter the rows returned"""
    where: order_item_special_image_bool_exp
  ): order_item_special_image_aggregate!

  """
  fetch data from the table: "order_item_special_image" using primary key columns
  """
  order_item_special_image_by_pk(id: bigint!): order_item_special_image

  """
  fetch data from the table: "order_item_special_text"
  """
  order_item_special_text(
    """distinct select on columns"""
    distinct_on: [order_item_special_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_special_text_order_by!]

    """filter the rows returned"""
    where: order_item_special_text_bool_exp
  ): [order_item_special_text!]!

  """
  fetch aggregated fields from the table: "order_item_special_text"
  """
  order_item_special_text_aggregate(
    """distinct select on columns"""
    distinct_on: [order_item_special_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_special_text_order_by!]

    """filter the rows returned"""
    where: order_item_special_text_bool_exp
  ): order_item_special_text_aggregate!

  """
  fetch data from the table: "order_item_special_text" using primary key columns
  """
  order_item_special_text_by_pk(id: bigint!): order_item_special_text

  """
  fetch data from the table: "order_status"
  """
  order_status(
    """distinct select on columns"""
    distinct_on: [order_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_status_order_by!]

    """filter the rows returned"""
    where: order_status_bool_exp
  ): [order_status!]!

  """
  fetch aggregated fields from the table: "order_status"
  """
  order_status_aggregate(
    """distinct select on columns"""
    distinct_on: [order_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_status_order_by!]

    """filter the rows returned"""
    where: order_status_bool_exp
  ): order_status_aggregate!

  """fetch data from the table: "order_status" using primary key columns"""
  order_status_by_pk(value: String!): order_status

  """
  fetch data from the table: "order_tenant"
  """
  order_tenant(
    """distinct select on columns"""
    distinct_on: [order_tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_tenant_order_by!]

    """filter the rows returned"""
    where: order_tenant_bool_exp
  ): [order_tenant!]!

  """
  fetch aggregated fields from the table: "order_tenant"
  """
  order_tenant_aggregate(
    """distinct select on columns"""
    distinct_on: [order_tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_tenant_order_by!]

    """filter the rows returned"""
    where: order_tenant_bool_exp
  ): order_tenant_aggregate!

  """fetch data from the table: "order_tenant" using primary key columns"""
  order_tenant_by_pk(id: bigint!): order_tenant

  """
  fetch data from the table: "order_tenant_invoice"
  """
  order_tenant_invoice(
    """distinct select on columns"""
    distinct_on: [order_tenant_invoice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_tenant_invoice_order_by!]

    """filter the rows returned"""
    where: order_tenant_invoice_bool_exp
  ): [order_tenant_invoice!]!

  """
  fetch aggregated fields from the table: "order_tenant_invoice"
  """
  order_tenant_invoice_aggregate(
    """distinct select on columns"""
    distinct_on: [order_tenant_invoice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_tenant_invoice_order_by!]

    """filter the rows returned"""
    where: order_tenant_invoice_bool_exp
  ): order_tenant_invoice_aggregate!

  """
  fetch data from the table: "order_tenant_invoice" using primary key columns
  """
  order_tenant_invoice_by_pk(id: uuid!): order_tenant_invoice

  """
  fetch data from the table: "payment_status"
  """
  payment_status(
    """distinct select on columns"""
    distinct_on: [payment_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_status_order_by!]

    """filter the rows returned"""
    where: payment_status_bool_exp
  ): [payment_status!]!

  """
  fetch aggregated fields from the table: "payment_status"
  """
  payment_status_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_status_order_by!]

    """filter the rows returned"""
    where: payment_status_bool_exp
  ): payment_status_aggregate!

  """fetch data from the table: "payment_status" using primary key columns"""
  payment_status_by_pk(value: String!): payment_status

  """
  fetch data from the table: "product"
  """
  product(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """
  fetch aggregated fields from the table: "product"
  """
  product_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!

  """fetch data from the table: "product" using primary key columns"""
  product_by_pk(id: bigint!): product

  """
  fetch data from the table: "product_category"
  """
  product_category(
    """distinct select on columns"""
    distinct_on: [product_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_category_order_by!]

    """filter the rows returned"""
    where: product_category_bool_exp
  ): [product_category!]!

  """
  fetch aggregated fields from the table: "product_category"
  """
  product_category_aggregate(
    """distinct select on columns"""
    distinct_on: [product_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_category_order_by!]

    """filter the rows returned"""
    where: product_category_bool_exp
  ): product_category_aggregate!

  """
  fetch data from the table: "product_category" using primary key columns
  """
  product_category_by_pk(id: bigint!): product_category

  """
  fetch data from the table: "product_customizable_area"
  """
  product_customizable_area(
    """distinct select on columns"""
    distinct_on: [product_customizable_area_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_customizable_area_order_by!]

    """filter the rows returned"""
    where: product_customizable_area_bool_exp
  ): [product_customizable_area!]!

  """
  fetch aggregated fields from the table: "product_customizable_area"
  """
  product_customizable_area_aggregate(
    """distinct select on columns"""
    distinct_on: [product_customizable_area_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_customizable_area_order_by!]

    """filter the rows returned"""
    where: product_customizable_area_bool_exp
  ): product_customizable_area_aggregate!

  """
  fetch data from the table: "product_customizable_area" using primary key columns
  """
  product_customizable_area_by_pk(id: bigint!): product_customizable_area

  """
  fetch data from the table: "product_delivery_city_info"
  """
  product_delivery_city_info(
    """distinct select on columns"""
    distinct_on: [product_delivery_city_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_delivery_city_info_order_by!]

    """filter the rows returned"""
    where: product_delivery_city_info_bool_exp
  ): [product_delivery_city_info!]!

  """
  fetch aggregated fields from the table: "product_delivery_city_info"
  """
  product_delivery_city_info_aggregate(
    """distinct select on columns"""
    distinct_on: [product_delivery_city_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_delivery_city_info_order_by!]

    """filter the rows returned"""
    where: product_delivery_city_info_bool_exp
  ): product_delivery_city_info_aggregate!

  """
  fetch data from the table: "quarter"
  """
  quarter(
    """distinct select on columns"""
    distinct_on: [quarter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [quarter_order_by!]

    """filter the rows returned"""
    where: quarter_bool_exp
  ): [quarter!]!

  """
  fetch aggregated fields from the table: "quarter"
  """
  quarter_aggregate(
    """distinct select on columns"""
    distinct_on: [quarter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [quarter_order_by!]

    """filter the rows returned"""
    where: quarter_bool_exp
  ): quarter_aggregate!

  """fetch data from the table: "quarter" using primary key columns"""
  quarter_by_pk(id: Int!): quarter

  """
  fetch data from the table: "question"
  """
  question(
    """distinct select on columns"""
    distinct_on: [question_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [question_order_by!]

    """filter the rows returned"""
    where: question_bool_exp
  ): [question!]!

  """
  fetch aggregated fields from the table: "question"
  """
  question_aggregate(
    """distinct select on columns"""
    distinct_on: [question_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [question_order_by!]

    """filter the rows returned"""
    where: question_bool_exp
  ): question_aggregate!

  """fetch data from the table: "question" using primary key columns"""
  question_by_pk(id: bigint!): question

  """
  fetch data from the table: "review"
  """
  review(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """
  fetch aggregated fields from the table: "review"
  """
  review_aggregate(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): review_aggregate!

  """fetch data from the table: "review" using primary key columns"""
  review_by_pk(id: Int!): review

  """
  fetch data from the table: "role"
  """
  role(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """
  fetch aggregated fields from the table: "role"
  """
  role_aggregate(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): role_aggregate!

  """fetch data from the table: "role" using primary key columns"""
  role_by_pk(value: String!): role

  """
  execute function "search_location" which returns "quarter"
  """
  search_location(
    """
    input parameters for function "search_location"
    """
    args: search_location_args!

    """distinct select on columns"""
    distinct_on: [quarter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [quarter_order_by!]

    """filter the rows returned"""
    where: quarter_bool_exp
  ): [quarter!]!

  """
  execute function "search_location" and query aggregates on result of table type "quarter"
  """
  search_location_aggregate(
    """
    input parameters for function "search_location_aggregate"
    """
    args: search_location_args!

    """distinct select on columns"""
    distinct_on: [quarter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [quarter_order_by!]

    """filter the rows returned"""
    where: quarter_bool_exp
  ): quarter_aggregate!

  """
  fetch data from the table: "search_location_result"
  """
  search_location_result(
    """distinct select on columns"""
    distinct_on: [search_location_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [search_location_result_order_by!]

    """filter the rows returned"""
    where: search_location_result_bool_exp
  ): [search_location_result!]!

  """
  fetch aggregated fields from the table: "search_location_result"
  """
  search_location_result_aggregate(
    """distinct select on columns"""
    distinct_on: [search_location_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [search_location_result_order_by!]

    """filter the rows returned"""
    where: search_location_result_bool_exp
  ): search_location_result_aggregate!

  """
  execute function "search_locationv1" which returns "search_location_result"
  """
  search_locationv1(
    """
    input parameters for function "search_locationv1"
    """
    args: search_locationv1_args!

    """distinct select on columns"""
    distinct_on: [search_location_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [search_location_result_order_by!]

    """filter the rows returned"""
    where: search_location_result_bool_exp
  ): [search_location_result!]!

  """
  execute function "search_locationv1" and query aggregates on result of table type "search_location_result"
  """
  search_locationv1_aggregate(
    """
    input parameters for function "search_locationv1_aggregate"
    """
    args: search_locationv1_args!

    """distinct select on columns"""
    distinct_on: [search_location_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [search_location_result_order_by!]

    """filter the rows returned"""
    where: search_location_result_bool_exp
  ): search_location_result_aggregate!

  """
  execute function "search_products" which returns "product"
  """
  search_products(
    """
    input parameters for function "search_products"
    """
    args: search_products_args!

    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """
  execute function "search_products" and query aggregates on result of table type "product"
  """
  search_products_aggregate(
    """
    input parameters for function "search_products_aggregate"
    """
    args: search_products_args!

    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!

  """
  fetch data from the table: "session"
  """
  session(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): [session!]!

  """
  fetch aggregated fields from the table: "session"
  """
  session_aggregate(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): session_aggregate!

  """fetch data from the table: "session" using primary key columns"""
  session_by_pk(id: uuid!): session

  """
  fetch data from the table: "system_banner"
  """
  system_banner(
    """distinct select on columns"""
    distinct_on: [system_banner_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_banner_order_by!]

    """filter the rows returned"""
    where: system_banner_bool_exp
  ): [system_banner!]!

  """
  fetch aggregated fields from the table: "system_banner"
  """
  system_banner_aggregate(
    """distinct select on columns"""
    distinct_on: [system_banner_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_banner_order_by!]

    """filter the rows returned"""
    where: system_banner_bool_exp
  ): system_banner_aggregate!

  """fetch data from the table: "system_banner" using primary key columns"""
  system_banner_by_pk(id: uuid!): system_banner

  """
  fetch data from the table: "tenant"
  """
  tenant(
    """distinct select on columns"""
    distinct_on: [tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_order_by!]

    """filter the rows returned"""
    where: tenant_bool_exp
  ): [tenant!]!

  """
  fetch data from the table: "tenant_address"
  """
  tenant_address(
    """distinct select on columns"""
    distinct_on: [tenant_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_address_order_by!]

    """filter the rows returned"""
    where: tenant_address_bool_exp
  ): [tenant_address!]!

  """
  fetch aggregated fields from the table: "tenant_address"
  """
  tenant_address_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_address_order_by!]

    """filter the rows returned"""
    where: tenant_address_bool_exp
  ): tenant_address_aggregate!

  """fetch data from the table: "tenant_address" using primary key columns"""
  tenant_address_by_pk(id: uuid!): tenant_address

  """
  fetch aggregated fields from the table: "tenant"
  """
  tenant_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_order_by!]

    """filter the rows returned"""
    where: tenant_bool_exp
  ): tenant_aggregate!

  """fetch data from the table: "tenant" using primary key columns"""
  tenant_by_pk(id: uuid!): tenant

  """
  fetch data from the table: "tenant_category"
  """
  tenant_category(
    """distinct select on columns"""
    distinct_on: [tenant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_category_order_by!]

    """filter the rows returned"""
    where: tenant_category_bool_exp
  ): [tenant_category!]!

  """
  fetch aggregated fields from the table: "tenant_category"
  """
  tenant_category_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_category_order_by!]

    """filter the rows returned"""
    where: tenant_category_bool_exp
  ): tenant_category_aggregate!

  """fetch data from the table: "tenant_category" using primary key columns"""
  tenant_category_by_pk(id: bigint!): tenant_category

  """
  fetch data from the table: "tenant_shipping_place"
  """
  tenant_shipping_place(
    """distinct select on columns"""
    distinct_on: [tenant_shipping_place_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_shipping_place_order_by!]

    """filter the rows returned"""
    where: tenant_shipping_place_bool_exp
  ): [tenant_shipping_place!]!

  """
  fetch aggregated fields from the table: "tenant_shipping_place"
  """
  tenant_shipping_place_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_shipping_place_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_shipping_place_order_by!]

    """filter the rows returned"""
    where: tenant_shipping_place_bool_exp
  ): tenant_shipping_place_aggregate!

  """
  fetch data from the table: "tenant_shipping_place" using primary key columns
  """
  tenant_shipping_place_by_pk(id: Int!): tenant_shipping_place

  """
  fetch data from the table: "ticket"
  """
  ticket(
    """distinct select on columns"""
    distinct_on: [ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_order_by!]

    """filter the rows returned"""
    where: ticket_bool_exp
  ): [ticket!]!

  """
  fetch aggregated fields from the table: "ticket"
  """
  ticket_aggregate(
    """distinct select on columns"""
    distinct_on: [ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_order_by!]

    """filter the rows returned"""
    where: ticket_bool_exp
  ): ticket_aggregate!

  """
  fetch data from the table: "ticket_answer"
  """
  ticket_answer(
    """distinct select on columns"""
    distinct_on: [ticket_answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_answer_order_by!]

    """filter the rows returned"""
    where: ticket_answer_bool_exp
  ): [ticket_answer!]!

  """
  fetch aggregated fields from the table: "ticket_answer"
  """
  ticket_answer_aggregate(
    """distinct select on columns"""
    distinct_on: [ticket_answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_answer_order_by!]

    """filter the rows returned"""
    where: ticket_answer_bool_exp
  ): ticket_answer_aggregate!

  """fetch data from the table: "ticket_answer" using primary key columns"""
  ticket_answer_by_pk(id: uuid!): ticket_answer

  """fetch data from the table: "ticket" using primary key columns"""
  ticket_by_pk(id: bigint!): ticket

  """
  fetch data from the table: "ticket_status"
  """
  ticket_status(
    """distinct select on columns"""
    distinct_on: [ticket_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_status_order_by!]

    """filter the rows returned"""
    where: ticket_status_bool_exp
  ): [ticket_status!]!

  """
  fetch aggregated fields from the table: "ticket_status"
  """
  ticket_status_aggregate(
    """distinct select on columns"""
    distinct_on: [ticket_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_status_order_by!]

    """filter the rows returned"""
    where: ticket_status_bool_exp
  ): ticket_status_aggregate!

  """fetch data from the table: "ticket_status" using primary key columns"""
  ticket_status_by_pk(value: String!): ticket_status

  """
  fetch data from the table: "transaction"
  """
  transaction(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """
  fetch aggregated fields from the table: "transaction"
  """
  transaction_aggregate(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): transaction_aggregate!

  """fetch data from the table: "transaction" using primary key columns"""
  transaction_by_pk(id: uuid!): transaction

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch data from the table: "user_address"
  """
  user_address(
    """distinct select on columns"""
    distinct_on: [user_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_address_order_by!]

    """filter the rows returned"""
    where: user_address_bool_exp
  ): [user_address!]!

  """
  fetch aggregated fields from the table: "user_address"
  """
  user_address_aggregate(
    """distinct select on columns"""
    distinct_on: [user_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_address_order_by!]

    """filter the rows returned"""
    where: user_address_bool_exp
  ): user_address_aggregate!

  """fetch data from the table: "user_address" using primary key columns"""
  user_address_by_pk(id: Int!): user_address

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: uuid!): user

  """
  fetch data from the table: "user_coupon"
  """
  user_coupon(
    """distinct select on columns"""
    distinct_on: [user_coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_coupon_order_by!]

    """filter the rows returned"""
    where: user_coupon_bool_exp
  ): [user_coupon!]!

  """
  fetch aggregated fields from the table: "user_coupon"
  """
  user_coupon_aggregate(
    """distinct select on columns"""
    distinct_on: [user_coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_coupon_order_by!]

    """filter the rows returned"""
    where: user_coupon_bool_exp
  ): user_coupon_aggregate!

  """fetch data from the table: "user_coupon" using primary key columns"""
  user_coupon_by_pk(id: uuid!): user_coupon

  """
  fetch data from the table: "user_favorite"
  """
  user_favorite(
    """distinct select on columns"""
    distinct_on: [user_favorite_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_favorite_order_by!]

    """filter the rows returned"""
    where: user_favorite_bool_exp
  ): [user_favorite!]!

  """
  fetch aggregated fields from the table: "user_favorite"
  """
  user_favorite_aggregate(
    """distinct select on columns"""
    distinct_on: [user_favorite_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_favorite_order_by!]

    """filter the rows returned"""
    where: user_favorite_bool_exp
  ): user_favorite_aggregate!

  """fetch data from the table: "user_favorite" using primary key columns"""
  user_favorite_by_pk(id: bigint!): user_favorite
}

"""User question for product"""
type question {
  """An array relationship"""
  answers(
    """distinct select on columns"""
    distinct_on: [answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [answer_order_by!]

    """filter the rows returned"""
    where: answer_bool_exp
  ): [answer!]!

  """An aggregate relationship"""
  answers_aggregate(
    """distinct select on columns"""
    distinct_on: [answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [answer_order_by!]

    """filter the rows returned"""
    where: answer_bool_exp
  ): answer_aggregate!
  created_at: timestamptz!
  id: bigint!

  """An object relationship"""
  product: product!
  product_id: bigint!
  question: String!
  updated_at: timestamptz!

  """An object relationship"""
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "question"
"""
type question_aggregate {
  aggregate: question_aggregate_fields
  nodes: [question!]!
}

input question_aggregate_bool_exp {
  count: question_aggregate_bool_exp_count
}

input question_aggregate_bool_exp_count {
  arguments: [question_select_column!]
  distinct: Boolean
  filter: question_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "question"
"""
type question_aggregate_fields {
  avg: question_avg_fields
  count(columns: [question_select_column!], distinct: Boolean): Int!
  max: question_max_fields
  min: question_min_fields
  stddev: question_stddev_fields
  stddev_pop: question_stddev_pop_fields
  stddev_samp: question_stddev_samp_fields
  sum: question_sum_fields
  var_pop: question_var_pop_fields
  var_samp: question_var_samp_fields
  variance: question_variance_fields
}

"""
order by aggregate values of table "question"
"""
input question_aggregate_order_by {
  avg: question_avg_order_by
  count: order_by
  max: question_max_order_by
  min: question_min_order_by
  stddev: question_stddev_order_by
  stddev_pop: question_stddev_pop_order_by
  stddev_samp: question_stddev_samp_order_by
  sum: question_sum_order_by
  var_pop: question_var_pop_order_by
  var_samp: question_var_samp_order_by
  variance: question_variance_order_by
}

"""
input type for inserting array relation for remote table "question"
"""
input question_arr_rel_insert_input {
  data: [question_insert_input!]!

  """upsert condition"""
  on_conflict: question_on_conflict
}

"""aggregate avg on columns"""
type question_avg_fields {
  id: Float
  product_id: Float
}

"""
order by avg() on columns of table "question"
"""
input question_avg_order_by {
  id: order_by
  product_id: order_by
}

"""
Boolean expression to filter rows from the table "question". All fields are combined with a logical 'AND'.
"""
input question_bool_exp {
  _and: [question_bool_exp!]
  _not: question_bool_exp
  _or: [question_bool_exp!]
  answers: answer_bool_exp
  answers_aggregate: answer_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  product: product_bool_exp
  product_id: bigint_comparison_exp
  question: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "question"
"""
enum question_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  question_pkey
}

"""
input type for incrementing numeric columns in table "question"
"""
input question_inc_input {
  id: bigint
  product_id: bigint
}

"""
input type for inserting data into table "question"
"""
input question_insert_input {
  answers: answer_arr_rel_insert_input
  created_at: timestamptz
  id: bigint
  product: product_obj_rel_insert_input
  product_id: bigint
  question: String
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type question_max_fields {
  created_at: timestamptz
  id: bigint
  product_id: bigint
  question: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "question"
"""
input question_max_order_by {
  created_at: order_by
  id: order_by
  product_id: order_by
  question: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type question_min_fields {
  created_at: timestamptz
  id: bigint
  product_id: bigint
  question: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "question"
"""
input question_min_order_by {
  created_at: order_by
  id: order_by
  product_id: order_by
  question: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "question"
"""
type question_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [question!]!
}

"""
input type for inserting object relation for remote table "question"
"""
input question_obj_rel_insert_input {
  data: question_insert_input!

  """upsert condition"""
  on_conflict: question_on_conflict
}

"""
on_conflict condition type for table "question"
"""
input question_on_conflict {
  constraint: question_constraint!
  update_columns: [question_update_column!]! = []
  where: question_bool_exp
}

"""Ordering options when selecting data from "question"."""
input question_order_by {
  answers_aggregate: answer_aggregate_order_by
  created_at: order_by
  id: order_by
  product: product_order_by
  product_id: order_by
  question: order_by
  updated_at: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: question"""
input question_pk_columns_input {
  id: bigint!
}

"""
select columns of table "question"
"""
enum question_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  question

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "question"
"""
input question_set_input {
  created_at: timestamptz
  id: bigint
  product_id: bigint
  question: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate stddev on columns"""
type question_stddev_fields {
  id: Float
  product_id: Float
}

"""
order by stddev() on columns of table "question"
"""
input question_stddev_order_by {
  id: order_by
  product_id: order_by
}

"""aggregate stddev_pop on columns"""
type question_stddev_pop_fields {
  id: Float
  product_id: Float
}

"""
order by stddev_pop() on columns of table "question"
"""
input question_stddev_pop_order_by {
  id: order_by
  product_id: order_by
}

"""aggregate stddev_samp on columns"""
type question_stddev_samp_fields {
  id: Float
  product_id: Float
}

"""
order by stddev_samp() on columns of table "question"
"""
input question_stddev_samp_order_by {
  id: order_by
  product_id: order_by
}

"""
Streaming cursor of the table "question"
"""
input question_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: question_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input question_stream_cursor_value_input {
  created_at: timestamptz
  id: bigint
  product_id: bigint
  question: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate sum on columns"""
type question_sum_fields {
  id: bigint
  product_id: bigint
}

"""
order by sum() on columns of table "question"
"""
input question_sum_order_by {
  id: order_by
  product_id: order_by
}

"""
update columns of table "question"
"""
enum question_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  question

  """column name"""
  updated_at

  """column name"""
  user_id
}

input question_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: question_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: question_set_input

  """filter the rows which have to be updated"""
  where: question_bool_exp!
}

"""aggregate var_pop on columns"""
type question_var_pop_fields {
  id: Float
  product_id: Float
}

"""
order by var_pop() on columns of table "question"
"""
input question_var_pop_order_by {
  id: order_by
  product_id: order_by
}

"""aggregate var_samp on columns"""
type question_var_samp_fields {
  id: Float
  product_id: Float
}

"""
order by var_samp() on columns of table "question"
"""
input question_var_samp_order_by {
  id: order_by
  product_id: order_by
}

"""aggregate variance on columns"""
type question_variance_fields {
  id: Float
  product_id: Float
}

"""
order by variance() on columns of table "question"
"""
input question_variance_order_by {
  id: order_by
  product_id: order_by
}

"""
User review for a product - User should have received that product to be able to add review
"""
type review {
  comment: String
  created_at: timestamptz!
  id: Int!

  """An object relationship"""
  product: product!
  product_id: Int!
  score: Int
  updated_at: timestamptz!

  """An object relationship"""
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "review"
"""
type review_aggregate {
  aggregate: review_aggregate_fields
  nodes: [review!]!
}

input review_aggregate_bool_exp {
  count: review_aggregate_bool_exp_count
}

input review_aggregate_bool_exp_count {
  arguments: [review_select_column!]
  distinct: Boolean
  filter: review_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "review"
"""
type review_aggregate_fields {
  avg: review_avg_fields
  count(columns: [review_select_column!], distinct: Boolean): Int!
  max: review_max_fields
  min: review_min_fields
  stddev: review_stddev_fields
  stddev_pop: review_stddev_pop_fields
  stddev_samp: review_stddev_samp_fields
  sum: review_sum_fields
  var_pop: review_var_pop_fields
  var_samp: review_var_samp_fields
  variance: review_variance_fields
}

"""
order by aggregate values of table "review"
"""
input review_aggregate_order_by {
  avg: review_avg_order_by
  count: order_by
  max: review_max_order_by
  min: review_min_order_by
  stddev: review_stddev_order_by
  stddev_pop: review_stddev_pop_order_by
  stddev_samp: review_stddev_samp_order_by
  sum: review_sum_order_by
  var_pop: review_var_pop_order_by
  var_samp: review_var_samp_order_by
  variance: review_variance_order_by
}

"""
input type for inserting array relation for remote table "review"
"""
input review_arr_rel_insert_input {
  data: [review_insert_input!]!

  """upsert condition"""
  on_conflict: review_on_conflict
}

"""aggregate avg on columns"""
type review_avg_fields {
  id: Float
  product_id: Float
  score: Float
}

"""
order by avg() on columns of table "review"
"""
input review_avg_order_by {
  id: order_by
  product_id: order_by
  score: order_by
}

"""
Boolean expression to filter rows from the table "review". All fields are combined with a logical 'AND'.
"""
input review_bool_exp {
  _and: [review_bool_exp!]
  _not: review_bool_exp
  _or: [review_bool_exp!]
  comment: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  product: product_bool_exp
  product_id: Int_comparison_exp
  score: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "review"
"""
enum review_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  review_pkey
}

"""
input type for incrementing numeric columns in table "review"
"""
input review_inc_input {
  id: Int
  product_id: Int
  score: Int
}

"""
input type for inserting data into table "review"
"""
input review_insert_input {
  comment: String
  created_at: timestamptz
  id: Int
  product: product_obj_rel_insert_input
  product_id: Int
  score: Int
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type review_max_fields {
  comment: String
  created_at: timestamptz
  id: Int
  product_id: Int
  score: Int
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "review"
"""
input review_max_order_by {
  comment: order_by
  created_at: order_by
  id: order_by
  product_id: order_by
  score: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type review_min_fields {
  comment: String
  created_at: timestamptz
  id: Int
  product_id: Int
  score: Int
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "review"
"""
input review_min_order_by {
  comment: order_by
  created_at: order_by
  id: order_by
  product_id: order_by
  score: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "review"
"""
type review_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [review!]!
}

"""
on_conflict condition type for table "review"
"""
input review_on_conflict {
  constraint: review_constraint!
  update_columns: [review_update_column!]! = []
  where: review_bool_exp
}

"""Ordering options when selecting data from "review"."""
input review_order_by {
  comment: order_by
  created_at: order_by
  id: order_by
  product: product_order_by
  product_id: order_by
  score: order_by
  updated_at: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: review"""
input review_pk_columns_input {
  id: Int!
}

"""
select columns of table "review"
"""
enum review_select_column {
  """column name"""
  comment

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  score

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "review"
"""
input review_set_input {
  comment: String
  created_at: timestamptz
  id: Int
  product_id: Int
  score: Int
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate stddev on columns"""
type review_stddev_fields {
  id: Float
  product_id: Float
  score: Float
}

"""
order by stddev() on columns of table "review"
"""
input review_stddev_order_by {
  id: order_by
  product_id: order_by
  score: order_by
}

"""aggregate stddev_pop on columns"""
type review_stddev_pop_fields {
  id: Float
  product_id: Float
  score: Float
}

"""
order by stddev_pop() on columns of table "review"
"""
input review_stddev_pop_order_by {
  id: order_by
  product_id: order_by
  score: order_by
}

"""aggregate stddev_samp on columns"""
type review_stddev_samp_fields {
  id: Float
  product_id: Float
  score: Float
}

"""
order by stddev_samp() on columns of table "review"
"""
input review_stddev_samp_order_by {
  id: order_by
  product_id: order_by
  score: order_by
}

"""
Streaming cursor of the table "review"
"""
input review_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: review_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input review_stream_cursor_value_input {
  comment: String
  created_at: timestamptz
  id: Int
  product_id: Int
  score: Int
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate sum on columns"""
type review_sum_fields {
  id: Int
  product_id: Int
  score: Int
}

"""
order by sum() on columns of table "review"
"""
input review_sum_order_by {
  id: order_by
  product_id: order_by
  score: order_by
}

"""
update columns of table "review"
"""
enum review_update_column {
  """column name"""
  comment

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  score

  """column name"""
  updated_at

  """column name"""
  user_id
}

input review_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: review_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: review_set_input

  """filter the rows which have to be updated"""
  where: review_bool_exp!
}

"""aggregate var_pop on columns"""
type review_var_pop_fields {
  id: Float
  product_id: Float
  score: Float
}

"""
order by var_pop() on columns of table "review"
"""
input review_var_pop_order_by {
  id: order_by
  product_id: order_by
  score: order_by
}

"""aggregate var_samp on columns"""
type review_var_samp_fields {
  id: Float
  product_id: Float
  score: Float
}

"""
order by var_samp() on columns of table "review"
"""
input review_var_samp_order_by {
  id: order_by
  product_id: order_by
  score: order_by
}

"""aggregate variance on columns"""
type review_variance_fields {
  id: Float
  product_id: Float
  score: Float
}

"""
order by variance() on columns of table "review"
"""
input review_variance_order_by {
  id: order_by
  product_id: order_by
  score: order_by
}

"""
columns and relationships of "role"
"""
type role {
  comment: String

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!
  value: String!
}

"""
aggregated selection of "role"
"""
type role_aggregate {
  aggregate: role_aggregate_fields
  nodes: [role!]!
}

"""
aggregate fields of "role"
"""
type role_aggregate_fields {
  count(columns: [role_select_column!], distinct: Boolean): Int!
  max: role_max_fields
  min: role_min_fields
}

"""
Boolean expression to filter rows from the table "role". All fields are combined with a logical 'AND'.
"""
input role_bool_exp {
  _and: [role_bool_exp!]
  _not: role_bool_exp
  _or: [role_bool_exp!]
  comment: String_comparison_exp
  users: user_bool_exp
  users_aggregate: user_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "role"
"""
enum role_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  role_pkey
}

enum role_enum {
  """Satıcı Firma"""
  Tenant

  """Standart kullanici"""
  User
}

"""
Boolean expression to compare columns of type "role_enum". All fields are combined with logical 'AND'.
"""
input role_enum_comparison_exp {
  _eq: role_enum
  _in: [role_enum!]
  _is_null: Boolean
  _neq: role_enum
  _nin: [role_enum!]
}

"""
input type for inserting data into table "role"
"""
input role_insert_input {
  comment: String
  users: user_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type role_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type role_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "role"
"""
type role_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [role!]!
}

"""
input type for inserting object relation for remote table "role"
"""
input role_obj_rel_insert_input {
  data: role_insert_input!

  """upsert condition"""
  on_conflict: role_on_conflict
}

"""
on_conflict condition type for table "role"
"""
input role_on_conflict {
  constraint: role_constraint!
  update_columns: [role_update_column!]! = []
  where: role_bool_exp
}

"""Ordering options when selecting data from "role"."""
input role_order_by {
  comment: order_by
  users_aggregate: user_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: role"""
input role_pk_columns_input {
  value: String!
}

"""
select columns of table "role"
"""
enum role_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "role"
"""
input role_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "role"
"""
input role_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: role_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input role_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "role"
"""
enum role_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input role_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: role_set_input

  """filter the rows which have to be updated"""
  where: role_bool_exp!
}

input search_location_args {
  search: String
}

"""
columns and relationships of "search_location_result"
"""
type search_location_result {
  city_id: Int
  city_name: String
  district_id: Int
  district_name: String
  id: Int
  name: String
  type: String
}

"""
aggregated selection of "search_location_result"
"""
type search_location_result_aggregate {
  aggregate: search_location_result_aggregate_fields
  nodes: [search_location_result!]!
}

"""
aggregate fields of "search_location_result"
"""
type search_location_result_aggregate_fields {
  avg: search_location_result_avg_fields
  count(columns: [search_location_result_select_column!], distinct: Boolean): Int!
  max: search_location_result_max_fields
  min: search_location_result_min_fields
  stddev: search_location_result_stddev_fields
  stddev_pop: search_location_result_stddev_pop_fields
  stddev_samp: search_location_result_stddev_samp_fields
  sum: search_location_result_sum_fields
  var_pop: search_location_result_var_pop_fields
  var_samp: search_location_result_var_samp_fields
  variance: search_location_result_variance_fields
}

"""aggregate avg on columns"""
type search_location_result_avg_fields {
  city_id: Float
  district_id: Float
  id: Float
}

"""
Boolean expression to filter rows from the table "search_location_result". All fields are combined with a logical 'AND'.
"""
input search_location_result_bool_exp {
  _and: [search_location_result_bool_exp!]
  _not: search_location_result_bool_exp
  _or: [search_location_result_bool_exp!]
  city_id: Int_comparison_exp
  city_name: String_comparison_exp
  district_id: Int_comparison_exp
  district_name: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  type: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "search_location_result"
"""
input search_location_result_inc_input {
  city_id: Int
  district_id: Int
  id: Int
}

"""
input type for inserting data into table "search_location_result"
"""
input search_location_result_insert_input {
  city_id: Int
  city_name: String
  district_id: Int
  district_name: String
  id: Int
  name: String
  type: String
}

"""aggregate max on columns"""
type search_location_result_max_fields {
  city_id: Int
  city_name: String
  district_id: Int
  district_name: String
  id: Int
  name: String
  type: String
}

"""aggregate min on columns"""
type search_location_result_min_fields {
  city_id: Int
  city_name: String
  district_id: Int
  district_name: String
  id: Int
  name: String
  type: String
}

"""
response of any mutation on the table "search_location_result"
"""
type search_location_result_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [search_location_result!]!
}

"""Ordering options when selecting data from "search_location_result"."""
input search_location_result_order_by {
  city_id: order_by
  city_name: order_by
  district_id: order_by
  district_name: order_by
  id: order_by
  name: order_by
  type: order_by
}

"""
select columns of table "search_location_result"
"""
enum search_location_result_select_column {
  """column name"""
  city_id

  """column name"""
  city_name

  """column name"""
  district_id

  """column name"""
  district_name

  """column name"""
  id

  """column name"""
  name

  """column name"""
  type
}

"""
input type for updating data in table "search_location_result"
"""
input search_location_result_set_input {
  city_id: Int
  city_name: String
  district_id: Int
  district_name: String
  id: Int
  name: String
  type: String
}

"""aggregate stddev on columns"""
type search_location_result_stddev_fields {
  city_id: Float
  district_id: Float
  id: Float
}

"""aggregate stddev_pop on columns"""
type search_location_result_stddev_pop_fields {
  city_id: Float
  district_id: Float
  id: Float
}

"""aggregate stddev_samp on columns"""
type search_location_result_stddev_samp_fields {
  city_id: Float
  district_id: Float
  id: Float
}

"""
Streaming cursor of the table "search_location_result"
"""
input search_location_result_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: search_location_result_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input search_location_result_stream_cursor_value_input {
  city_id: Int
  city_name: String
  district_id: Int
  district_name: String
  id: Int
  name: String
  type: String
}

"""aggregate sum on columns"""
type search_location_result_sum_fields {
  city_id: Int
  district_id: Int
  id: Int
}

input search_location_result_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: search_location_result_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: search_location_result_set_input

  """filter the rows which have to be updated"""
  where: search_location_result_bool_exp!
}

"""aggregate var_pop on columns"""
type search_location_result_var_pop_fields {
  city_id: Float
  district_id: Float
  id: Float
}

"""aggregate var_samp on columns"""
type search_location_result_var_samp_fields {
  city_id: Float
  district_id: Float
  id: Float
}

"""aggregate variance on columns"""
type search_location_result_variance_fields {
  city_id: Float
  district_id: Float
  id: Float
}

input search_locationv1_args {
  search: String
}

input search_products_args {
  search: String
}

"""User sessions"""
type session {
  access_expiry: timestamp
  access_token: String!
  created_at: timestamptz!
  id: uuid!
  refresh_expiry: timestamp
  refresh_token: String!
  updated_at: timestamptz!
  user_id: uuid!
}

"""
aggregated selection of "session"
"""
type session_aggregate {
  aggregate: session_aggregate_fields
  nodes: [session!]!
}

input session_aggregate_bool_exp {
  count: session_aggregate_bool_exp_count
}

input session_aggregate_bool_exp_count {
  arguments: [session_select_column!]
  distinct: Boolean
  filter: session_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "session"
"""
type session_aggregate_fields {
  count(columns: [session_select_column!], distinct: Boolean): Int!
  max: session_max_fields
  min: session_min_fields
}

"""
order by aggregate values of table "session"
"""
input session_aggregate_order_by {
  count: order_by
  max: session_max_order_by
  min: session_min_order_by
}

"""
input type for inserting array relation for remote table "session"
"""
input session_arr_rel_insert_input {
  data: [session_insert_input!]!

  """upsert condition"""
  on_conflict: session_on_conflict
}

"""
Boolean expression to filter rows from the table "session". All fields are combined with a logical 'AND'.
"""
input session_bool_exp {
  _and: [session_bool_exp!]
  _not: session_bool_exp
  _or: [session_bool_exp!]
  access_expiry: timestamp_comparison_exp
  access_token: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  refresh_expiry: timestamp_comparison_exp
  refresh_token: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "session"
"""
enum session_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  session_pkey
}

"""
input type for inserting data into table "session"
"""
input session_insert_input {
  access_expiry: timestamp
  access_token: String
  created_at: timestamptz
  id: uuid
  refresh_expiry: timestamp
  refresh_token: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type session_max_fields {
  access_expiry: timestamp
  access_token: String
  created_at: timestamptz
  id: uuid
  refresh_expiry: timestamp
  refresh_token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "session"
"""
input session_max_order_by {
  access_expiry: order_by
  access_token: order_by
  created_at: order_by
  id: order_by
  refresh_expiry: order_by
  refresh_token: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type session_min_fields {
  access_expiry: timestamp
  access_token: String
  created_at: timestamptz
  id: uuid
  refresh_expiry: timestamp
  refresh_token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "session"
"""
input session_min_order_by {
  access_expiry: order_by
  access_token: order_by
  created_at: order_by
  id: order_by
  refresh_expiry: order_by
  refresh_token: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "session"
"""
type session_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [session!]!
}

"""
on_conflict condition type for table "session"
"""
input session_on_conflict {
  constraint: session_constraint!
  update_columns: [session_update_column!]! = []
  where: session_bool_exp
}

"""Ordering options when selecting data from "session"."""
input session_order_by {
  access_expiry: order_by
  access_token: order_by
  created_at: order_by
  id: order_by
  refresh_expiry: order_by
  refresh_token: order_by
  updated_at: order_by
  user_id: order_by
}

"""primary key columns input for table: session"""
input session_pk_columns_input {
  id: uuid!
}

"""
select columns of table "session"
"""
enum session_select_column {
  """column name"""
  access_expiry

  """column name"""
  access_token

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  refresh_expiry

  """column name"""
  refresh_token

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "session"
"""
input session_set_input {
  access_expiry: timestamp
  access_token: String
  created_at: timestamptz
  id: uuid
  refresh_expiry: timestamp
  refresh_token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "session"
"""
input session_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: session_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input session_stream_cursor_value_input {
  access_expiry: timestamp
  access_token: String
  created_at: timestamptz
  id: uuid
  refresh_expiry: timestamp
  refresh_token: String
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "session"
"""
enum session_update_column {
  """column name"""
  access_expiry

  """column name"""
  access_token

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  refresh_expiry

  """column name"""
  refresh_token

  """column name"""
  updated_at

  """column name"""
  user_id
}

input session_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: session_set_input

  """filter the rows which have to be updated"""
  where: session_bool_exp!
}

type subscription_root {
  """
  fetch data from the table: "address_type"
  """
  address_type(
    """distinct select on columns"""
    distinct_on: [address_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_type_order_by!]

    """filter the rows returned"""
    where: address_type_bool_exp
  ): [address_type!]!

  """
  fetch aggregated fields from the table: "address_type"
  """
  address_type_aggregate(
    """distinct select on columns"""
    distinct_on: [address_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [address_type_order_by!]

    """filter the rows returned"""
    where: address_type_bool_exp
  ): address_type_aggregate!

  """fetch data from the table: "address_type" using primary key columns"""
  address_type_by_pk(value: String!): address_type

  """
  fetch data from the table in a streaming manner: "address_type"
  """
  address_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [address_type_stream_cursor_input]!

    """filter the rows returned"""
    where: address_type_bool_exp
  ): [address_type!]!

  """
  fetch data from the table: "answer"
  """
  answer(
    """distinct select on columns"""
    distinct_on: [answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [answer_order_by!]

    """filter the rows returned"""
    where: answer_bool_exp
  ): [answer!]!

  """
  fetch aggregated fields from the table: "answer"
  """
  answer_aggregate(
    """distinct select on columns"""
    distinct_on: [answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [answer_order_by!]

    """filter the rows returned"""
    where: answer_bool_exp
  ): answer_aggregate!

  """fetch data from the table: "answer" using primary key columns"""
  answer_by_pk(id: bigint!): answer

  """
  fetch data from the table in a streaming manner: "answer"
  """
  answer_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [answer_stream_cursor_input]!

    """filter the rows returned"""
    where: answer_bool_exp
  ): [answer!]!

  """
  fetch data from the table: "cart"
  """
  cart(
    """distinct select on columns"""
    distinct_on: [cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cart_order_by!]

    """filter the rows returned"""
    where: cart_bool_exp
  ): [cart!]!

  """
  fetch aggregated fields from the table: "cart"
  """
  cart_aggregate(
    """distinct select on columns"""
    distinct_on: [cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cart_order_by!]

    """filter the rows returned"""
    where: cart_bool_exp
  ): cart_aggregate!

  """fetch data from the table: "cart" using primary key columns"""
  cart_by_pk(id: uuid!): cart

  """
  fetch data from the table in a streaming manner: "cart"
  """
  cart_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [cart_stream_cursor_input]!

    """filter the rows returned"""
    where: cart_bool_exp
  ): [cart!]!

  """
  fetch data from the table: "category"
  """
  category(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): [category!]!

  """
  fetch aggregated fields from the table: "category"
  """
  category_aggregate(
    """distinct select on columns"""
    distinct_on: [category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [category_order_by!]

    """filter the rows returned"""
    where: category_bool_exp
  ): category_aggregate!

  """fetch data from the table: "category" using primary key columns"""
  category_by_pk(id: Int!): category

  """
  fetch data from the table in a streaming manner: "category"
  """
  category_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [category_stream_cursor_input]!

    """filter the rows returned"""
    where: category_bool_exp
  ): [category!]!

  """
  fetch data from the table: "chat_thread"
  """
  chat_thread(
    """distinct select on columns"""
    distinct_on: [chat_thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_thread_order_by!]

    """filter the rows returned"""
    where: chat_thread_bool_exp
  ): [chat_thread!]!

  """
  fetch aggregated fields from the table: "chat_thread"
  """
  chat_thread_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_thread_order_by!]

    """filter the rows returned"""
    where: chat_thread_bool_exp
  ): chat_thread_aggregate!

  """fetch data from the table: "chat_thread" using primary key columns"""
  chat_thread_by_pk(id: uuid!): chat_thread

  """
  fetch data from the table in a streaming manner: "chat_thread"
  """
  chat_thread_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [chat_thread_stream_cursor_input]!

    """filter the rows returned"""
    where: chat_thread_bool_exp
  ): [chat_thread!]!

  """
  fetch data from the table: "city"
  """
  city(
    """distinct select on columns"""
    distinct_on: [city_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [city_order_by!]

    """filter the rows returned"""
    where: city_bool_exp
  ): [city!]!

  """
  fetch aggregated fields from the table: "city"
  """
  city_aggregate(
    """distinct select on columns"""
    distinct_on: [city_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [city_order_by!]

    """filter the rows returned"""
    where: city_bool_exp
  ): city_aggregate!

  """fetch data from the table: "city" using primary key columns"""
  city_by_pk(id: Int!): city

  """
  fetch data from the table in a streaming manner: "city"
  """
  city_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [city_stream_cursor_input]!

    """filter the rows returned"""
    where: city_bool_exp
  ): [city!]!

  """
  fetch data from the table: "company"
  """
  company(
    """distinct select on columns"""
    distinct_on: [company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_order_by!]

    """filter the rows returned"""
    where: company_bool_exp
  ): [company!]!

  """
  fetch aggregated fields from the table: "company"
  """
  company_aggregate(
    """distinct select on columns"""
    distinct_on: [company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_order_by!]

    """filter the rows returned"""
    where: company_bool_exp
  ): company_aggregate!

  """fetch data from the table: "company" using primary key columns"""
  company_by_pk(id: uuid!): company

  """
  fetch data from the table: "company_category"
  """
  company_category(
    """distinct select on columns"""
    distinct_on: [company_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_category_order_by!]

    """filter the rows returned"""
    where: company_category_bool_exp
  ): [company_category!]!

  """
  fetch aggregated fields from the table: "company_category"
  """
  company_category_aggregate(
    """distinct select on columns"""
    distinct_on: [company_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_category_order_by!]

    """filter the rows returned"""
    where: company_category_bool_exp
  ): company_category_aggregate!

  """
  fetch data from the table: "company_category" using primary key columns
  """
  company_category_by_pk(id: Int!): company_category

  """
  fetch data from the table in a streaming manner: "company_category"
  """
  company_category_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [company_category_stream_cursor_input]!

    """filter the rows returned"""
    where: company_category_bool_exp
  ): [company_category!]!

  """
  fetch data from the table in a streaming manner: "company"
  """
  company_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [company_stream_cursor_input]!

    """filter the rows returned"""
    where: company_bool_exp
  ): [company!]!

  """
  fetch data from the table: "company_type"
  """
  company_type(
    """distinct select on columns"""
    distinct_on: [company_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_type_order_by!]

    """filter the rows returned"""
    where: company_type_bool_exp
  ): [company_type!]!

  """
  fetch aggregated fields from the table: "company_type"
  """
  company_type_aggregate(
    """distinct select on columns"""
    distinct_on: [company_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_type_order_by!]

    """filter the rows returned"""
    where: company_type_bool_exp
  ): company_type_aggregate!

  """fetch data from the table: "company_type" using primary key columns"""
  company_type_by_pk(value: String!): company_type

  """
  fetch data from the table in a streaming manner: "company_type"
  """
  company_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [company_type_stream_cursor_input]!

    """filter the rows returned"""
    where: company_type_bool_exp
  ): [company_type!]!

  """
  fetch data from the table: "coupon"
  """
  coupon(
    """distinct select on columns"""
    distinct_on: [coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coupon_order_by!]

    """filter the rows returned"""
    where: coupon_bool_exp
  ): [coupon!]!

  """
  fetch aggregated fields from the table: "coupon"
  """
  coupon_aggregate(
    """distinct select on columns"""
    distinct_on: [coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coupon_order_by!]

    """filter the rows returned"""
    where: coupon_bool_exp
  ): coupon_aggregate!

  """fetch data from the table: "coupon" using primary key columns"""
  coupon_by_pk(id: uuid!): coupon

  """
  fetch data from the table in a streaming manner: "coupon"
  """
  coupon_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [coupon_stream_cursor_input]!

    """filter the rows returned"""
    where: coupon_bool_exp
  ): [coupon!]!

  """
  fetch data from the table: "customizable_area"
  """
  customizable_area(
    """distinct select on columns"""
    distinct_on: [customizable_area_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customizable_area_order_by!]

    """filter the rows returned"""
    where: customizable_area_bool_exp
  ): [customizable_area!]!

  """
  fetch aggregated fields from the table: "customizable_area"
  """
  customizable_area_aggregate(
    """distinct select on columns"""
    distinct_on: [customizable_area_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customizable_area_order_by!]

    """filter the rows returned"""
    where: customizable_area_bool_exp
  ): customizable_area_aggregate!

  """
  fetch data from the table: "customizable_area" using primary key columns
  """
  customizable_area_by_pk(id: Int!): customizable_area

  """
  fetch data from the table in a streaming manner: "customizable_area"
  """
  customizable_area_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [customizable_area_stream_cursor_input]!

    """filter the rows returned"""
    where: customizable_area_bool_exp
  ): [customizable_area!]!

  """
  fetch data from the table: "delivery_type"
  """
  delivery_type(
    """distinct select on columns"""
    distinct_on: [delivery_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_type_order_by!]

    """filter the rows returned"""
    where: delivery_type_bool_exp
  ): [delivery_type!]!

  """
  fetch aggregated fields from the table: "delivery_type"
  """
  delivery_type_aggregate(
    """distinct select on columns"""
    distinct_on: [delivery_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [delivery_type_order_by!]

    """filter the rows returned"""
    where: delivery_type_bool_exp
  ): delivery_type_aggregate!

  """fetch data from the table: "delivery_type" using primary key columns"""
  delivery_type_by_pk(value: String!): delivery_type

  """
  fetch data from the table in a streaming manner: "delivery_type"
  """
  delivery_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [delivery_type_stream_cursor_input]!

    """filter the rows returned"""
    where: delivery_type_bool_exp
  ): [delivery_type!]!

  """
  fetch data from the table: "district"
  """
  district(
    """distinct select on columns"""
    distinct_on: [district_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [district_order_by!]

    """filter the rows returned"""
    where: district_bool_exp
  ): [district!]!

  """
  fetch aggregated fields from the table: "district"
  """
  district_aggregate(
    """distinct select on columns"""
    distinct_on: [district_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [district_order_by!]

    """filter the rows returned"""
    where: district_bool_exp
  ): district_aggregate!

  """fetch data from the table: "district" using primary key columns"""
  district_by_pk(id: Int!): district

  """
  fetch data from the table in a streaming manner: "district"
  """
  district_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [district_stream_cursor_input]!

    """filter the rows returned"""
    where: district_bool_exp
  ): [district!]!

  """
  execute function "get_product_delivery_cities" which returns "product_delivery_city_info"
  """
  get_product_delivery_cities(
    """
    input parameters for function "get_product_delivery_cities"
    """
    args: get_product_delivery_cities_args!

    """distinct select on columns"""
    distinct_on: [product_delivery_city_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_delivery_city_info_order_by!]

    """filter the rows returned"""
    where: product_delivery_city_info_bool_exp
  ): [product_delivery_city_info!]!

  """
  execute function "get_product_delivery_cities" and query aggregates on result of table type "product_delivery_city_info"
  """
  get_product_delivery_cities_aggregate(
    """
    input parameters for function "get_product_delivery_cities_aggregate"
    """
    args: get_product_delivery_cities_args!

    """distinct select on columns"""
    distinct_on: [product_delivery_city_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_delivery_city_info_order_by!]

    """filter the rows returned"""
    where: product_delivery_city_info_bool_exp
  ): product_delivery_city_info_aggregate!

  """
  fetch data from the table: "message"
  """
  message(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """
  fetch aggregated fields from the table: "message"
  """
  message_aggregate(
    """distinct select on columns"""
    distinct_on: [message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_order_by!]

    """filter the rows returned"""
    where: message_bool_exp
  ): message_aggregate!

  """fetch data from the table: "message" using primary key columns"""
  message_by_pk(id: bigint!): message

  """
  fetch data from the table in a streaming manner: "message"
  """
  message_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [message_stream_cursor_input]!

    """filter the rows returned"""
    where: message_bool_exp
  ): [message!]!

  """
  fetch data from the table: "order"
  """
  order(
    """distinct select on columns"""
    distinct_on: [order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_order_by!]

    """filter the rows returned"""
    where: order_bool_exp
  ): [order!]!

  """
  fetch data from the table: "order_address"
  """
  order_address(
    """distinct select on columns"""
    distinct_on: [order_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_address_order_by!]

    """filter the rows returned"""
    where: order_address_bool_exp
  ): [order_address!]!

  """
  fetch aggregated fields from the table: "order_address"
  """
  order_address_aggregate(
    """distinct select on columns"""
    distinct_on: [order_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_address_order_by!]

    """filter the rows returned"""
    where: order_address_bool_exp
  ): order_address_aggregate!

  """fetch data from the table: "order_address" using primary key columns"""
  order_address_by_pk(id: Int!): order_address

  """
  fetch data from the table in a streaming manner: "order_address"
  """
  order_address_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [order_address_stream_cursor_input]!

    """filter the rows returned"""
    where: order_address_bool_exp
  ): [order_address!]!

  """
  fetch aggregated fields from the table: "order"
  """
  order_aggregate(
    """distinct select on columns"""
    distinct_on: [order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_order_by!]

    """filter the rows returned"""
    where: order_bool_exp
  ): order_aggregate!

  """fetch data from the table: "order" using primary key columns"""
  order_by_pk(id: uuid!): order

  """
  fetch data from the table: "order_item"
  """
  order_item(
    """distinct select on columns"""
    distinct_on: [order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_order_by!]

    """filter the rows returned"""
    where: order_item_bool_exp
  ): [order_item!]!

  """
  fetch aggregated fields from the table: "order_item"
  """
  order_item_aggregate(
    """distinct select on columns"""
    distinct_on: [order_item_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_order_by!]

    """filter the rows returned"""
    where: order_item_bool_exp
  ): order_item_aggregate!

  """fetch data from the table: "order_item" using primary key columns"""
  order_item_by_pk(id: bigint!): order_item

  """
  fetch data from the table: "order_item_special_image"
  """
  order_item_special_image(
    """distinct select on columns"""
    distinct_on: [order_item_special_image_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_special_image_order_by!]

    """filter the rows returned"""
    where: order_item_special_image_bool_exp
  ): [order_item_special_image!]!

  """
  fetch aggregated fields from the table: "order_item_special_image"
  """
  order_item_special_image_aggregate(
    """distinct select on columns"""
    distinct_on: [order_item_special_image_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_special_image_order_by!]

    """filter the rows returned"""
    where: order_item_special_image_bool_exp
  ): order_item_special_image_aggregate!

  """
  fetch data from the table: "order_item_special_image" using primary key columns
  """
  order_item_special_image_by_pk(id: bigint!): order_item_special_image

  """
  fetch data from the table in a streaming manner: "order_item_special_image"
  """
  order_item_special_image_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [order_item_special_image_stream_cursor_input]!

    """filter the rows returned"""
    where: order_item_special_image_bool_exp
  ): [order_item_special_image!]!

  """
  fetch data from the table: "order_item_special_text"
  """
  order_item_special_text(
    """distinct select on columns"""
    distinct_on: [order_item_special_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_special_text_order_by!]

    """filter the rows returned"""
    where: order_item_special_text_bool_exp
  ): [order_item_special_text!]!

  """
  fetch aggregated fields from the table: "order_item_special_text"
  """
  order_item_special_text_aggregate(
    """distinct select on columns"""
    distinct_on: [order_item_special_text_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_item_special_text_order_by!]

    """filter the rows returned"""
    where: order_item_special_text_bool_exp
  ): order_item_special_text_aggregate!

  """
  fetch data from the table: "order_item_special_text" using primary key columns
  """
  order_item_special_text_by_pk(id: bigint!): order_item_special_text

  """
  fetch data from the table in a streaming manner: "order_item_special_text"
  """
  order_item_special_text_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [order_item_special_text_stream_cursor_input]!

    """filter the rows returned"""
    where: order_item_special_text_bool_exp
  ): [order_item_special_text!]!

  """
  fetch data from the table in a streaming manner: "order_item"
  """
  order_item_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [order_item_stream_cursor_input]!

    """filter the rows returned"""
    where: order_item_bool_exp
  ): [order_item!]!

  """
  fetch data from the table: "order_status"
  """
  order_status(
    """distinct select on columns"""
    distinct_on: [order_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_status_order_by!]

    """filter the rows returned"""
    where: order_status_bool_exp
  ): [order_status!]!

  """
  fetch aggregated fields from the table: "order_status"
  """
  order_status_aggregate(
    """distinct select on columns"""
    distinct_on: [order_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_status_order_by!]

    """filter the rows returned"""
    where: order_status_bool_exp
  ): order_status_aggregate!

  """fetch data from the table: "order_status" using primary key columns"""
  order_status_by_pk(value: String!): order_status

  """
  fetch data from the table in a streaming manner: "order_status"
  """
  order_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [order_status_stream_cursor_input]!

    """filter the rows returned"""
    where: order_status_bool_exp
  ): [order_status!]!

  """
  fetch data from the table in a streaming manner: "order"
  """
  order_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [order_stream_cursor_input]!

    """filter the rows returned"""
    where: order_bool_exp
  ): [order!]!

  """
  fetch data from the table: "order_tenant"
  """
  order_tenant(
    """distinct select on columns"""
    distinct_on: [order_tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_tenant_order_by!]

    """filter the rows returned"""
    where: order_tenant_bool_exp
  ): [order_tenant!]!

  """
  fetch aggregated fields from the table: "order_tenant"
  """
  order_tenant_aggregate(
    """distinct select on columns"""
    distinct_on: [order_tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_tenant_order_by!]

    """filter the rows returned"""
    where: order_tenant_bool_exp
  ): order_tenant_aggregate!

  """fetch data from the table: "order_tenant" using primary key columns"""
  order_tenant_by_pk(id: bigint!): order_tenant

  """
  fetch data from the table: "order_tenant_invoice"
  """
  order_tenant_invoice(
    """distinct select on columns"""
    distinct_on: [order_tenant_invoice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_tenant_invoice_order_by!]

    """filter the rows returned"""
    where: order_tenant_invoice_bool_exp
  ): [order_tenant_invoice!]!

  """
  fetch aggregated fields from the table: "order_tenant_invoice"
  """
  order_tenant_invoice_aggregate(
    """distinct select on columns"""
    distinct_on: [order_tenant_invoice_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_tenant_invoice_order_by!]

    """filter the rows returned"""
    where: order_tenant_invoice_bool_exp
  ): order_tenant_invoice_aggregate!

  """
  fetch data from the table: "order_tenant_invoice" using primary key columns
  """
  order_tenant_invoice_by_pk(id: uuid!): order_tenant_invoice

  """
  fetch data from the table in a streaming manner: "order_tenant_invoice"
  """
  order_tenant_invoice_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [order_tenant_invoice_stream_cursor_input]!

    """filter the rows returned"""
    where: order_tenant_invoice_bool_exp
  ): [order_tenant_invoice!]!

  """
  fetch data from the table in a streaming manner: "order_tenant"
  """
  order_tenant_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [order_tenant_stream_cursor_input]!

    """filter the rows returned"""
    where: order_tenant_bool_exp
  ): [order_tenant!]!

  """
  fetch data from the table: "payment_status"
  """
  payment_status(
    """distinct select on columns"""
    distinct_on: [payment_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_status_order_by!]

    """filter the rows returned"""
    where: payment_status_bool_exp
  ): [payment_status!]!

  """
  fetch aggregated fields from the table: "payment_status"
  """
  payment_status_aggregate(
    """distinct select on columns"""
    distinct_on: [payment_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [payment_status_order_by!]

    """filter the rows returned"""
    where: payment_status_bool_exp
  ): payment_status_aggregate!

  """fetch data from the table: "payment_status" using primary key columns"""
  payment_status_by_pk(value: String!): payment_status

  """
  fetch data from the table in a streaming manner: "payment_status"
  """
  payment_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [payment_status_stream_cursor_input]!

    """filter the rows returned"""
    where: payment_status_bool_exp
  ): [payment_status!]!

  """
  fetch data from the table: "product"
  """
  product(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """
  fetch aggregated fields from the table: "product"
  """
  product_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!

  """fetch data from the table: "product" using primary key columns"""
  product_by_pk(id: bigint!): product

  """
  fetch data from the table: "product_category"
  """
  product_category(
    """distinct select on columns"""
    distinct_on: [product_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_category_order_by!]

    """filter the rows returned"""
    where: product_category_bool_exp
  ): [product_category!]!

  """
  fetch aggregated fields from the table: "product_category"
  """
  product_category_aggregate(
    """distinct select on columns"""
    distinct_on: [product_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_category_order_by!]

    """filter the rows returned"""
    where: product_category_bool_exp
  ): product_category_aggregate!

  """
  fetch data from the table: "product_category" using primary key columns
  """
  product_category_by_pk(id: bigint!): product_category

  """
  fetch data from the table in a streaming manner: "product_category"
  """
  product_category_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_category_stream_cursor_input]!

    """filter the rows returned"""
    where: product_category_bool_exp
  ): [product_category!]!

  """
  fetch data from the table: "product_customizable_area"
  """
  product_customizable_area(
    """distinct select on columns"""
    distinct_on: [product_customizable_area_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_customizable_area_order_by!]

    """filter the rows returned"""
    where: product_customizable_area_bool_exp
  ): [product_customizable_area!]!

  """
  fetch aggregated fields from the table: "product_customizable_area"
  """
  product_customizable_area_aggregate(
    """distinct select on columns"""
    distinct_on: [product_customizable_area_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_customizable_area_order_by!]

    """filter the rows returned"""
    where: product_customizable_area_bool_exp
  ): product_customizable_area_aggregate!

  """
  fetch data from the table: "product_customizable_area" using primary key columns
  """
  product_customizable_area_by_pk(id: bigint!): product_customizable_area

  """
  fetch data from the table in a streaming manner: "product_customizable_area"
  """
  product_customizable_area_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_customizable_area_stream_cursor_input]!

    """filter the rows returned"""
    where: product_customizable_area_bool_exp
  ): [product_customizable_area!]!

  """
  fetch data from the table: "product_delivery_city_info"
  """
  product_delivery_city_info(
    """distinct select on columns"""
    distinct_on: [product_delivery_city_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_delivery_city_info_order_by!]

    """filter the rows returned"""
    where: product_delivery_city_info_bool_exp
  ): [product_delivery_city_info!]!

  """
  fetch aggregated fields from the table: "product_delivery_city_info"
  """
  product_delivery_city_info_aggregate(
    """distinct select on columns"""
    distinct_on: [product_delivery_city_info_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_delivery_city_info_order_by!]

    """filter the rows returned"""
    where: product_delivery_city_info_bool_exp
  ): product_delivery_city_info_aggregate!

  """
  fetch data from the table in a streaming manner: "product_delivery_city_info"
  """
  product_delivery_city_info_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_delivery_city_info_stream_cursor_input]!

    """filter the rows returned"""
    where: product_delivery_city_info_bool_exp
  ): [product_delivery_city_info!]!

  """
  fetch data from the table in a streaming manner: "product"
  """
  product_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [product_stream_cursor_input]!

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """
  fetch data from the table: "quarter"
  """
  quarter(
    """distinct select on columns"""
    distinct_on: [quarter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [quarter_order_by!]

    """filter the rows returned"""
    where: quarter_bool_exp
  ): [quarter!]!

  """
  fetch aggregated fields from the table: "quarter"
  """
  quarter_aggregate(
    """distinct select on columns"""
    distinct_on: [quarter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [quarter_order_by!]

    """filter the rows returned"""
    where: quarter_bool_exp
  ): quarter_aggregate!

  """fetch data from the table: "quarter" using primary key columns"""
  quarter_by_pk(id: Int!): quarter

  """
  fetch data from the table in a streaming manner: "quarter"
  """
  quarter_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [quarter_stream_cursor_input]!

    """filter the rows returned"""
    where: quarter_bool_exp
  ): [quarter!]!

  """
  fetch data from the table: "question"
  """
  question(
    """distinct select on columns"""
    distinct_on: [question_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [question_order_by!]

    """filter the rows returned"""
    where: question_bool_exp
  ): [question!]!

  """
  fetch aggregated fields from the table: "question"
  """
  question_aggregate(
    """distinct select on columns"""
    distinct_on: [question_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [question_order_by!]

    """filter the rows returned"""
    where: question_bool_exp
  ): question_aggregate!

  """fetch data from the table: "question" using primary key columns"""
  question_by_pk(id: bigint!): question

  """
  fetch data from the table in a streaming manner: "question"
  """
  question_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [question_stream_cursor_input]!

    """filter the rows returned"""
    where: question_bool_exp
  ): [question!]!

  """
  fetch data from the table: "review"
  """
  review(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """
  fetch aggregated fields from the table: "review"
  """
  review_aggregate(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): review_aggregate!

  """fetch data from the table: "review" using primary key columns"""
  review_by_pk(id: Int!): review

  """
  fetch data from the table in a streaming manner: "review"
  """
  review_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [review_stream_cursor_input]!

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """
  fetch data from the table: "role"
  """
  role(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """
  fetch aggregated fields from the table: "role"
  """
  role_aggregate(
    """distinct select on columns"""
    distinct_on: [role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [role_order_by!]

    """filter the rows returned"""
    where: role_bool_exp
  ): role_aggregate!

  """fetch data from the table: "role" using primary key columns"""
  role_by_pk(value: String!): role

  """
  fetch data from the table in a streaming manner: "role"
  """
  role_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [role_stream_cursor_input]!

    """filter the rows returned"""
    where: role_bool_exp
  ): [role!]!

  """
  execute function "search_location" which returns "quarter"
  """
  search_location(
    """
    input parameters for function "search_location"
    """
    args: search_location_args!

    """distinct select on columns"""
    distinct_on: [quarter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [quarter_order_by!]

    """filter the rows returned"""
    where: quarter_bool_exp
  ): [quarter!]!

  """
  execute function "search_location" and query aggregates on result of table type "quarter"
  """
  search_location_aggregate(
    """
    input parameters for function "search_location_aggregate"
    """
    args: search_location_args!

    """distinct select on columns"""
    distinct_on: [quarter_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [quarter_order_by!]

    """filter the rows returned"""
    where: quarter_bool_exp
  ): quarter_aggregate!

  """
  fetch data from the table: "search_location_result"
  """
  search_location_result(
    """distinct select on columns"""
    distinct_on: [search_location_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [search_location_result_order_by!]

    """filter the rows returned"""
    where: search_location_result_bool_exp
  ): [search_location_result!]!

  """
  fetch aggregated fields from the table: "search_location_result"
  """
  search_location_result_aggregate(
    """distinct select on columns"""
    distinct_on: [search_location_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [search_location_result_order_by!]

    """filter the rows returned"""
    where: search_location_result_bool_exp
  ): search_location_result_aggregate!

  """
  fetch data from the table in a streaming manner: "search_location_result"
  """
  search_location_result_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [search_location_result_stream_cursor_input]!

    """filter the rows returned"""
    where: search_location_result_bool_exp
  ): [search_location_result!]!

  """
  execute function "search_locationv1" which returns "search_location_result"
  """
  search_locationv1(
    """
    input parameters for function "search_locationv1"
    """
    args: search_locationv1_args!

    """distinct select on columns"""
    distinct_on: [search_location_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [search_location_result_order_by!]

    """filter the rows returned"""
    where: search_location_result_bool_exp
  ): [search_location_result!]!

  """
  execute function "search_locationv1" and query aggregates on result of table type "search_location_result"
  """
  search_locationv1_aggregate(
    """
    input parameters for function "search_locationv1_aggregate"
    """
    args: search_locationv1_args!

    """distinct select on columns"""
    distinct_on: [search_location_result_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [search_location_result_order_by!]

    """filter the rows returned"""
    where: search_location_result_bool_exp
  ): search_location_result_aggregate!

  """
  execute function "search_products" which returns "product"
  """
  search_products(
    """
    input parameters for function "search_products"
    """
    args: search_products_args!

    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """
  execute function "search_products" and query aggregates on result of table type "product"
  """
  search_products_aggregate(
    """
    input parameters for function "search_products_aggregate"
    """
    args: search_products_args!

    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!

  """
  fetch data from the table: "session"
  """
  session(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): [session!]!

  """
  fetch aggregated fields from the table: "session"
  """
  session_aggregate(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): session_aggregate!

  """fetch data from the table: "session" using primary key columns"""
  session_by_pk(id: uuid!): session

  """
  fetch data from the table in a streaming manner: "session"
  """
  session_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [session_stream_cursor_input]!

    """filter the rows returned"""
    where: session_bool_exp
  ): [session!]!

  """
  fetch data from the table: "system_banner"
  """
  system_banner(
    """distinct select on columns"""
    distinct_on: [system_banner_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_banner_order_by!]

    """filter the rows returned"""
    where: system_banner_bool_exp
  ): [system_banner!]!

  """
  fetch aggregated fields from the table: "system_banner"
  """
  system_banner_aggregate(
    """distinct select on columns"""
    distinct_on: [system_banner_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [system_banner_order_by!]

    """filter the rows returned"""
    where: system_banner_bool_exp
  ): system_banner_aggregate!

  """fetch data from the table: "system_banner" using primary key columns"""
  system_banner_by_pk(id: uuid!): system_banner

  """
  fetch data from the table in a streaming manner: "system_banner"
  """
  system_banner_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [system_banner_stream_cursor_input]!

    """filter the rows returned"""
    where: system_banner_bool_exp
  ): [system_banner!]!

  """
  fetch data from the table: "tenant"
  """
  tenant(
    """distinct select on columns"""
    distinct_on: [tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_order_by!]

    """filter the rows returned"""
    where: tenant_bool_exp
  ): [tenant!]!

  """
  fetch data from the table: "tenant_address"
  """
  tenant_address(
    """distinct select on columns"""
    distinct_on: [tenant_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_address_order_by!]

    """filter the rows returned"""
    where: tenant_address_bool_exp
  ): [tenant_address!]!

  """
  fetch aggregated fields from the table: "tenant_address"
  """
  tenant_address_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_address_order_by!]

    """filter the rows returned"""
    where: tenant_address_bool_exp
  ): tenant_address_aggregate!

  """fetch data from the table: "tenant_address" using primary key columns"""
  tenant_address_by_pk(id: uuid!): tenant_address

  """
  fetch data from the table in a streaming manner: "tenant_address"
  """
  tenant_address_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tenant_address_stream_cursor_input]!

    """filter the rows returned"""
    where: tenant_address_bool_exp
  ): [tenant_address!]!

  """
  fetch aggregated fields from the table: "tenant"
  """
  tenant_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_order_by!]

    """filter the rows returned"""
    where: tenant_bool_exp
  ): tenant_aggregate!

  """fetch data from the table: "tenant" using primary key columns"""
  tenant_by_pk(id: uuid!): tenant

  """
  fetch data from the table: "tenant_category"
  """
  tenant_category(
    """distinct select on columns"""
    distinct_on: [tenant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_category_order_by!]

    """filter the rows returned"""
    where: tenant_category_bool_exp
  ): [tenant_category!]!

  """
  fetch aggregated fields from the table: "tenant_category"
  """
  tenant_category_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_category_order_by!]

    """filter the rows returned"""
    where: tenant_category_bool_exp
  ): tenant_category_aggregate!

  """fetch data from the table: "tenant_category" using primary key columns"""
  tenant_category_by_pk(id: bigint!): tenant_category

  """
  fetch data from the table in a streaming manner: "tenant_category"
  """
  tenant_category_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tenant_category_stream_cursor_input]!

    """filter the rows returned"""
    where: tenant_category_bool_exp
  ): [tenant_category!]!

  """
  fetch data from the table: "tenant_shipping_place"
  """
  tenant_shipping_place(
    """distinct select on columns"""
    distinct_on: [tenant_shipping_place_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_shipping_place_order_by!]

    """filter the rows returned"""
    where: tenant_shipping_place_bool_exp
  ): [tenant_shipping_place!]!

  """
  fetch aggregated fields from the table: "tenant_shipping_place"
  """
  tenant_shipping_place_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_shipping_place_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_shipping_place_order_by!]

    """filter the rows returned"""
    where: tenant_shipping_place_bool_exp
  ): tenant_shipping_place_aggregate!

  """
  fetch data from the table: "tenant_shipping_place" using primary key columns
  """
  tenant_shipping_place_by_pk(id: Int!): tenant_shipping_place

  """
  fetch data from the table in a streaming manner: "tenant_shipping_place"
  """
  tenant_shipping_place_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tenant_shipping_place_stream_cursor_input]!

    """filter the rows returned"""
    where: tenant_shipping_place_bool_exp
  ): [tenant_shipping_place!]!

  """
  fetch data from the table in a streaming manner: "tenant"
  """
  tenant_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tenant_stream_cursor_input]!

    """filter the rows returned"""
    where: tenant_bool_exp
  ): [tenant!]!

  """
  fetch data from the table: "ticket"
  """
  ticket(
    """distinct select on columns"""
    distinct_on: [ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_order_by!]

    """filter the rows returned"""
    where: ticket_bool_exp
  ): [ticket!]!

  """
  fetch aggregated fields from the table: "ticket"
  """
  ticket_aggregate(
    """distinct select on columns"""
    distinct_on: [ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_order_by!]

    """filter the rows returned"""
    where: ticket_bool_exp
  ): ticket_aggregate!

  """
  fetch data from the table: "ticket_answer"
  """
  ticket_answer(
    """distinct select on columns"""
    distinct_on: [ticket_answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_answer_order_by!]

    """filter the rows returned"""
    where: ticket_answer_bool_exp
  ): [ticket_answer!]!

  """
  fetch aggregated fields from the table: "ticket_answer"
  """
  ticket_answer_aggregate(
    """distinct select on columns"""
    distinct_on: [ticket_answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_answer_order_by!]

    """filter the rows returned"""
    where: ticket_answer_bool_exp
  ): ticket_answer_aggregate!

  """fetch data from the table: "ticket_answer" using primary key columns"""
  ticket_answer_by_pk(id: uuid!): ticket_answer

  """
  fetch data from the table in a streaming manner: "ticket_answer"
  """
  ticket_answer_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ticket_answer_stream_cursor_input]!

    """filter the rows returned"""
    where: ticket_answer_bool_exp
  ): [ticket_answer!]!

  """fetch data from the table: "ticket" using primary key columns"""
  ticket_by_pk(id: bigint!): ticket

  """
  fetch data from the table: "ticket_status"
  """
  ticket_status(
    """distinct select on columns"""
    distinct_on: [ticket_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_status_order_by!]

    """filter the rows returned"""
    where: ticket_status_bool_exp
  ): [ticket_status!]!

  """
  fetch aggregated fields from the table: "ticket_status"
  """
  ticket_status_aggregate(
    """distinct select on columns"""
    distinct_on: [ticket_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_status_order_by!]

    """filter the rows returned"""
    where: ticket_status_bool_exp
  ): ticket_status_aggregate!

  """fetch data from the table: "ticket_status" using primary key columns"""
  ticket_status_by_pk(value: String!): ticket_status

  """
  fetch data from the table in a streaming manner: "ticket_status"
  """
  ticket_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ticket_status_stream_cursor_input]!

    """filter the rows returned"""
    where: ticket_status_bool_exp
  ): [ticket_status!]!

  """
  fetch data from the table in a streaming manner: "ticket"
  """
  ticket_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ticket_stream_cursor_input]!

    """filter the rows returned"""
    where: ticket_bool_exp
  ): [ticket!]!

  """
  fetch data from the table: "transaction"
  """
  transaction(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """
  fetch aggregated fields from the table: "transaction"
  """
  transaction_aggregate(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): transaction_aggregate!

  """fetch data from the table: "transaction" using primary key columns"""
  transaction_by_pk(id: uuid!): transaction

  """
  fetch data from the table in a streaming manner: "transaction"
  """
  transaction_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [transaction_stream_cursor_input]!

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch data from the table: "user_address"
  """
  user_address(
    """distinct select on columns"""
    distinct_on: [user_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_address_order_by!]

    """filter the rows returned"""
    where: user_address_bool_exp
  ): [user_address!]!

  """
  fetch aggregated fields from the table: "user_address"
  """
  user_address_aggregate(
    """distinct select on columns"""
    distinct_on: [user_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_address_order_by!]

    """filter the rows returned"""
    where: user_address_bool_exp
  ): user_address_aggregate!

  """fetch data from the table: "user_address" using primary key columns"""
  user_address_by_pk(id: Int!): user_address

  """
  fetch data from the table in a streaming manner: "user_address"
  """
  user_address_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_address_stream_cursor_input]!

    """filter the rows returned"""
    where: user_address_bool_exp
  ): [user_address!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: uuid!): user

  """
  fetch data from the table: "user_coupon"
  """
  user_coupon(
    """distinct select on columns"""
    distinct_on: [user_coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_coupon_order_by!]

    """filter the rows returned"""
    where: user_coupon_bool_exp
  ): [user_coupon!]!

  """
  fetch aggregated fields from the table: "user_coupon"
  """
  user_coupon_aggregate(
    """distinct select on columns"""
    distinct_on: [user_coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_coupon_order_by!]

    """filter the rows returned"""
    where: user_coupon_bool_exp
  ): user_coupon_aggregate!

  """fetch data from the table: "user_coupon" using primary key columns"""
  user_coupon_by_pk(id: uuid!): user_coupon

  """
  fetch data from the table in a streaming manner: "user_coupon"
  """
  user_coupon_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_coupon_stream_cursor_input]!

    """filter the rows returned"""
    where: user_coupon_bool_exp
  ): [user_coupon!]!

  """
  fetch data from the table: "user_favorite"
  """
  user_favorite(
    """distinct select on columns"""
    distinct_on: [user_favorite_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_favorite_order_by!]

    """filter the rows returned"""
    where: user_favorite_bool_exp
  ): [user_favorite!]!

  """
  fetch aggregated fields from the table: "user_favorite"
  """
  user_favorite_aggregate(
    """distinct select on columns"""
    distinct_on: [user_favorite_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_favorite_order_by!]

    """filter the rows returned"""
    where: user_favorite_bool_exp
  ): user_favorite_aggregate!

  """fetch data from the table: "user_favorite" using primary key columns"""
  user_favorite_by_pk(id: bigint!): user_favorite

  """
  fetch data from the table in a streaming manner: "user_favorite"
  """
  user_favorite_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_favorite_stream_cursor_input]!

    """filter the rows returned"""
    where: user_favorite_bool_exp
  ): [user_favorite!]!

  """
  fetch data from the table in a streaming manner: "user"
  """
  user_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_stream_cursor_input]!

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!
}

"""
columns and relationships of "system_banner"
"""
type system_banner {
  created_at: timestamptz!
  expire_date: timestamptz
  id: uuid!
  name: String
  path: String
  redirect_link: String!
}

"""
aggregated selection of "system_banner"
"""
type system_banner_aggregate {
  aggregate: system_banner_aggregate_fields
  nodes: [system_banner!]!
}

"""
aggregate fields of "system_banner"
"""
type system_banner_aggregate_fields {
  count(columns: [system_banner_select_column!], distinct: Boolean): Int!
  max: system_banner_max_fields
  min: system_banner_min_fields
}

"""
Boolean expression to filter rows from the table "system_banner". All fields are combined with a logical 'AND'.
"""
input system_banner_bool_exp {
  _and: [system_banner_bool_exp!]
  _not: system_banner_bool_exp
  _or: [system_banner_bool_exp!]
  created_at: timestamptz_comparison_exp
  expire_date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  path: String_comparison_exp
  redirect_link: String_comparison_exp
}

"""
unique or primary key constraints on table "system_banner"
"""
enum system_banner_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  system_banner_pkey
}

"""
input type for inserting data into table "system_banner"
"""
input system_banner_insert_input {
  created_at: timestamptz
  expire_date: timestamptz
  id: uuid
  name: String
  path: String
  redirect_link: String
}

"""aggregate max on columns"""
type system_banner_max_fields {
  created_at: timestamptz
  expire_date: timestamptz
  id: uuid
  name: String
  path: String
  redirect_link: String
}

"""aggregate min on columns"""
type system_banner_min_fields {
  created_at: timestamptz
  expire_date: timestamptz
  id: uuid
  name: String
  path: String
  redirect_link: String
}

"""
response of any mutation on the table "system_banner"
"""
type system_banner_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [system_banner!]!
}

"""
on_conflict condition type for table "system_banner"
"""
input system_banner_on_conflict {
  constraint: system_banner_constraint!
  update_columns: [system_banner_update_column!]! = []
  where: system_banner_bool_exp
}

"""Ordering options when selecting data from "system_banner"."""
input system_banner_order_by {
  created_at: order_by
  expire_date: order_by
  id: order_by
  name: order_by
  path: order_by
  redirect_link: order_by
}

"""primary key columns input for table: system_banner"""
input system_banner_pk_columns_input {
  id: uuid!
}

"""
select columns of table "system_banner"
"""
enum system_banner_select_column {
  """column name"""
  created_at

  """column name"""
  expire_date

  """column name"""
  id

  """column name"""
  name

  """column name"""
  path

  """column name"""
  redirect_link
}

"""
input type for updating data in table "system_banner"
"""
input system_banner_set_input {
  created_at: timestamptz
  expire_date: timestamptz
  id: uuid
  name: String
  path: String
  redirect_link: String
}

"""
Streaming cursor of the table "system_banner"
"""
input system_banner_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: system_banner_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input system_banner_stream_cursor_value_input {
  created_at: timestamptz
  expire_date: timestamptz
  id: uuid
  name: String
  path: String
  redirect_link: String
}

"""
update columns of table "system_banner"
"""
enum system_banner_update_column {
  """column name"""
  created_at

  """column name"""
  expire_date

  """column name"""
  id

  """column name"""
  name

  """column name"""
  path

  """column name"""
  redirect_link
}

input system_banner_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: system_banner_set_input

  """filter the rows which have to be updated"""
  where: system_banner_bool_exp!
}

"""
columns and relationships of "tenant"
"""
type tenant {
  address: String

  """An array relationship"""
  categories(
    """distinct select on columns"""
    distinct_on: [tenant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_category_order_by!]

    """filter the rows returned"""
    where: tenant_category_bool_exp
  ): [tenant_category!]!

  """An aggregate relationship"""
  categories_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_category_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_category_order_by!]

    """filter the rows returned"""
    where: tenant_category_bool_exp
  ): tenant_category_aggregate!
  commision_rate: numeric
  company_type: company_type_enum

  """An object relationship"""
  company_type_rel: company_type
  created_at: timestamptz!
  iban: String
  iban_holder_name: String
  id: uuid!
  is_active: Boolean!
  iyzi_sub_merchant_key: String
  legal_company_title: String
  logo: String
  name: String
  off_days: [Int!]

  """An object relationship"""
  owner: user!
  owner_id: uuid!
  phone: String

  """An object relationship"""
  quarter: quarter
  quarter_id: Int
  tax_office_name: String
  tax_plate_url: String

  """An object relationship"""
  tax_quarter: quarter
  tax_quarter_id: Int

  """An array relationship"""
  tenant_addresses(
    """distinct select on columns"""
    distinct_on: [tenant_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_address_order_by!]

    """filter the rows returned"""
    where: tenant_address_bool_exp
  ): [tenant_address!]!

  """An aggregate relationship"""
  tenant_addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_address_order_by!]

    """filter the rows returned"""
    where: tenant_address_bool_exp
  ): tenant_address_aggregate!

  """An array relationship"""
  tenant_shipping_places(
    """distinct select on columns"""
    distinct_on: [tenant_shipping_place_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_shipping_place_order_by!]

    """filter the rows returned"""
    where: tenant_shipping_place_bool_exp
  ): [tenant_shipping_place!]!

  """An aggregate relationship"""
  tenant_shipping_places_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_shipping_place_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_shipping_place_order_by!]

    """filter the rows returned"""
    where: tenant_shipping_place_bool_exp
  ): tenant_shipping_place_aggregate!
  updated_at: timestamptz!
  vkn_tckn: String
}

"""
columns and relationships of "tenant_address"
"""
type tenant_address {
  address: String!

  """An object relationship"""
  address_type: address_type
  created_at: timestamptz!
  id: uuid!

  """An object relationship"""
  quarter: quarter!
  quarter_id: Int!

  """An object relationship"""
  tenant: tenant
  tenant_id: uuid
  type: address_type_enum
  updated_at: timestamptz!
}

"""
aggregated selection of "tenant_address"
"""
type tenant_address_aggregate {
  aggregate: tenant_address_aggregate_fields
  nodes: [tenant_address!]!
}

input tenant_address_aggregate_bool_exp {
  count: tenant_address_aggregate_bool_exp_count
}

input tenant_address_aggregate_bool_exp_count {
  arguments: [tenant_address_select_column!]
  distinct: Boolean
  filter: tenant_address_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "tenant_address"
"""
type tenant_address_aggregate_fields {
  avg: tenant_address_avg_fields
  count(columns: [tenant_address_select_column!], distinct: Boolean): Int!
  max: tenant_address_max_fields
  min: tenant_address_min_fields
  stddev: tenant_address_stddev_fields
  stddev_pop: tenant_address_stddev_pop_fields
  stddev_samp: tenant_address_stddev_samp_fields
  sum: tenant_address_sum_fields
  var_pop: tenant_address_var_pop_fields
  var_samp: tenant_address_var_samp_fields
  variance: tenant_address_variance_fields
}

"""
order by aggregate values of table "tenant_address"
"""
input tenant_address_aggregate_order_by {
  avg: tenant_address_avg_order_by
  count: order_by
  max: tenant_address_max_order_by
  min: tenant_address_min_order_by
  stddev: tenant_address_stddev_order_by
  stddev_pop: tenant_address_stddev_pop_order_by
  stddev_samp: tenant_address_stddev_samp_order_by
  sum: tenant_address_sum_order_by
  var_pop: tenant_address_var_pop_order_by
  var_samp: tenant_address_var_samp_order_by
  variance: tenant_address_variance_order_by
}

"""
input type for inserting array relation for remote table "tenant_address"
"""
input tenant_address_arr_rel_insert_input {
  data: [tenant_address_insert_input!]!

  """upsert condition"""
  on_conflict: tenant_address_on_conflict
}

"""aggregate avg on columns"""
type tenant_address_avg_fields {
  quarter_id: Float
}

"""
order by avg() on columns of table "tenant_address"
"""
input tenant_address_avg_order_by {
  quarter_id: order_by
}

"""
Boolean expression to filter rows from the table "tenant_address". All fields are combined with a logical 'AND'.
"""
input tenant_address_bool_exp {
  _and: [tenant_address_bool_exp!]
  _not: tenant_address_bool_exp
  _or: [tenant_address_bool_exp!]
  address: String_comparison_exp
  address_type: address_type_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  quarter: quarter_bool_exp
  quarter_id: Int_comparison_exp
  tenant: tenant_bool_exp
  tenant_id: uuid_comparison_exp
  type: address_type_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "tenant_address"
"""
enum tenant_address_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tenant_address_pkey
}

"""
input type for incrementing numeric columns in table "tenant_address"
"""
input tenant_address_inc_input {
  quarter_id: Int
}

"""
input type for inserting data into table "tenant_address"
"""
input tenant_address_insert_input {
  address: String
  address_type: address_type_obj_rel_insert_input
  created_at: timestamptz
  id: uuid
  quarter: quarter_obj_rel_insert_input
  quarter_id: Int
  tenant: tenant_obj_rel_insert_input
  tenant_id: uuid
  type: address_type_enum
  updated_at: timestamptz
}

"""aggregate max on columns"""
type tenant_address_max_fields {
  address: String
  created_at: timestamptz
  id: uuid
  quarter_id: Int
  tenant_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "tenant_address"
"""
input tenant_address_max_order_by {
  address: order_by
  created_at: order_by
  id: order_by
  quarter_id: order_by
  tenant_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type tenant_address_min_fields {
  address: String
  created_at: timestamptz
  id: uuid
  quarter_id: Int
  tenant_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "tenant_address"
"""
input tenant_address_min_order_by {
  address: order_by
  created_at: order_by
  id: order_by
  quarter_id: order_by
  tenant_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "tenant_address"
"""
type tenant_address_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tenant_address!]!
}

"""
on_conflict condition type for table "tenant_address"
"""
input tenant_address_on_conflict {
  constraint: tenant_address_constraint!
  update_columns: [tenant_address_update_column!]! = []
  where: tenant_address_bool_exp
}

"""Ordering options when selecting data from "tenant_address"."""
input tenant_address_order_by {
  address: order_by
  address_type: address_type_order_by
  created_at: order_by
  id: order_by
  quarter: quarter_order_by
  quarter_id: order_by
  tenant: tenant_order_by
  tenant_id: order_by
  type: order_by
  updated_at: order_by
}

"""primary key columns input for table: tenant_address"""
input tenant_address_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tenant_address"
"""
enum tenant_address_select_column {
  """column name"""
  address

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  quarter_id

  """column name"""
  tenant_id

  """column name"""
  type

  """column name"""
  updated_at
}

"""
input type for updating data in table "tenant_address"
"""
input tenant_address_set_input {
  address: String
  created_at: timestamptz
  id: uuid
  quarter_id: Int
  tenant_id: uuid
  type: address_type_enum
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type tenant_address_stddev_fields {
  quarter_id: Float
}

"""
order by stddev() on columns of table "tenant_address"
"""
input tenant_address_stddev_order_by {
  quarter_id: order_by
}

"""aggregate stddev_pop on columns"""
type tenant_address_stddev_pop_fields {
  quarter_id: Float
}

"""
order by stddev_pop() on columns of table "tenant_address"
"""
input tenant_address_stddev_pop_order_by {
  quarter_id: order_by
}

"""aggregate stddev_samp on columns"""
type tenant_address_stddev_samp_fields {
  quarter_id: Float
}

"""
order by stddev_samp() on columns of table "tenant_address"
"""
input tenant_address_stddev_samp_order_by {
  quarter_id: order_by
}

"""
Streaming cursor of the table "tenant_address"
"""
input tenant_address_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tenant_address_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tenant_address_stream_cursor_value_input {
  address: String
  created_at: timestamptz
  id: uuid
  quarter_id: Int
  tenant_id: uuid
  type: address_type_enum
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type tenant_address_sum_fields {
  quarter_id: Int
}

"""
order by sum() on columns of table "tenant_address"
"""
input tenant_address_sum_order_by {
  quarter_id: order_by
}

"""
update columns of table "tenant_address"
"""
enum tenant_address_update_column {
  """column name"""
  address

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  quarter_id

  """column name"""
  tenant_id

  """column name"""
  type

  """column name"""
  updated_at
}

input tenant_address_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: tenant_address_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: tenant_address_set_input

  """filter the rows which have to be updated"""
  where: tenant_address_bool_exp!
}

"""aggregate var_pop on columns"""
type tenant_address_var_pop_fields {
  quarter_id: Float
}

"""
order by var_pop() on columns of table "tenant_address"
"""
input tenant_address_var_pop_order_by {
  quarter_id: order_by
}

"""aggregate var_samp on columns"""
type tenant_address_var_samp_fields {
  quarter_id: Float
}

"""
order by var_samp() on columns of table "tenant_address"
"""
input tenant_address_var_samp_order_by {
  quarter_id: order_by
}

"""aggregate variance on columns"""
type tenant_address_variance_fields {
  quarter_id: Float
}

"""
order by variance() on columns of table "tenant_address"
"""
input tenant_address_variance_order_by {
  quarter_id: order_by
}

"""
aggregated selection of "tenant"
"""
type tenant_aggregate {
  aggregate: tenant_aggregate_fields
  nodes: [tenant!]!
}

input tenant_aggregate_bool_exp {
  bool_and: tenant_aggregate_bool_exp_bool_and
  bool_or: tenant_aggregate_bool_exp_bool_or
  count: tenant_aggregate_bool_exp_count
}

input tenant_aggregate_bool_exp_bool_and {
  arguments: tenant_select_column_tenant_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: tenant_bool_exp
  predicate: Boolean_comparison_exp!
}

input tenant_aggregate_bool_exp_bool_or {
  arguments: tenant_select_column_tenant_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: tenant_bool_exp
  predicate: Boolean_comparison_exp!
}

input tenant_aggregate_bool_exp_count {
  arguments: [tenant_select_column!]
  distinct: Boolean
  filter: tenant_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "tenant"
"""
type tenant_aggregate_fields {
  avg: tenant_avg_fields
  count(columns: [tenant_select_column!], distinct: Boolean): Int!
  max: tenant_max_fields
  min: tenant_min_fields
  stddev: tenant_stddev_fields
  stddev_pop: tenant_stddev_pop_fields
  stddev_samp: tenant_stddev_samp_fields
  sum: tenant_sum_fields
  var_pop: tenant_var_pop_fields
  var_samp: tenant_var_samp_fields
  variance: tenant_variance_fields
}

"""
order by aggregate values of table "tenant"
"""
input tenant_aggregate_order_by {
  avg: tenant_avg_order_by
  count: order_by
  max: tenant_max_order_by
  min: tenant_min_order_by
  stddev: tenant_stddev_order_by
  stddev_pop: tenant_stddev_pop_order_by
  stddev_samp: tenant_stddev_samp_order_by
  sum: tenant_sum_order_by
  var_pop: tenant_var_pop_order_by
  var_samp: tenant_var_samp_order_by
  variance: tenant_variance_order_by
}

"""
input type for inserting array relation for remote table "tenant"
"""
input tenant_arr_rel_insert_input {
  data: [tenant_insert_input!]!

  """upsert condition"""
  on_conflict: tenant_on_conflict
}

"""aggregate avg on columns"""
type tenant_avg_fields {
  commision_rate: Float
  quarter_id: Float
  tax_quarter_id: Float
}

"""
order by avg() on columns of table "tenant"
"""
input tenant_avg_order_by {
  commision_rate: order_by
  quarter_id: order_by
  tax_quarter_id: order_by
}

"""
Boolean expression to filter rows from the table "tenant". All fields are combined with a logical 'AND'.
"""
input tenant_bool_exp {
  _and: [tenant_bool_exp!]
  _not: tenant_bool_exp
  _or: [tenant_bool_exp!]
  address: String_comparison_exp
  categories: tenant_category_bool_exp
  categories_aggregate: tenant_category_aggregate_bool_exp
  commision_rate: numeric_comparison_exp
  company_type: company_type_enum_comparison_exp
  company_type_rel: company_type_bool_exp
  created_at: timestamptz_comparison_exp
  iban: String_comparison_exp
  iban_holder_name: String_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  iyzi_sub_merchant_key: String_comparison_exp
  legal_company_title: String_comparison_exp
  logo: String_comparison_exp
  name: String_comparison_exp
  off_days: Int_array_comparison_exp
  owner: user_bool_exp
  owner_id: uuid_comparison_exp
  phone: String_comparison_exp
  quarter: quarter_bool_exp
  quarter_id: Int_comparison_exp
  tax_office_name: String_comparison_exp
  tax_plate_url: String_comparison_exp
  tax_quarter: quarter_bool_exp
  tax_quarter_id: Int_comparison_exp
  tenant_addresses: tenant_address_bool_exp
  tenant_addresses_aggregate: tenant_address_aggregate_bool_exp
  tenant_shipping_places: tenant_shipping_place_bool_exp
  tenant_shipping_places_aggregate: tenant_shipping_place_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  vkn_tckn: String_comparison_exp
}

"""
columns and relationships of "tenant_category"
"""
type tenant_category {
  """An object relationship"""
  category: category!
  category_id: Int!
  created_at: timestamptz!
  id: bigint!

  """An object relationship"""
  tenant: tenant!
  tenant_id: uuid!
}

"""
aggregated selection of "tenant_category"
"""
type tenant_category_aggregate {
  aggregate: tenant_category_aggregate_fields
  nodes: [tenant_category!]!
}

input tenant_category_aggregate_bool_exp {
  count: tenant_category_aggregate_bool_exp_count
}

input tenant_category_aggregate_bool_exp_count {
  arguments: [tenant_category_select_column!]
  distinct: Boolean
  filter: tenant_category_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "tenant_category"
"""
type tenant_category_aggregate_fields {
  avg: tenant_category_avg_fields
  count(columns: [tenant_category_select_column!], distinct: Boolean): Int!
  max: tenant_category_max_fields
  min: tenant_category_min_fields
  stddev: tenant_category_stddev_fields
  stddev_pop: tenant_category_stddev_pop_fields
  stddev_samp: tenant_category_stddev_samp_fields
  sum: tenant_category_sum_fields
  var_pop: tenant_category_var_pop_fields
  var_samp: tenant_category_var_samp_fields
  variance: tenant_category_variance_fields
}

"""
order by aggregate values of table "tenant_category"
"""
input tenant_category_aggregate_order_by {
  avg: tenant_category_avg_order_by
  count: order_by
  max: tenant_category_max_order_by
  min: tenant_category_min_order_by
  stddev: tenant_category_stddev_order_by
  stddev_pop: tenant_category_stddev_pop_order_by
  stddev_samp: tenant_category_stddev_samp_order_by
  sum: tenant_category_sum_order_by
  var_pop: tenant_category_var_pop_order_by
  var_samp: tenant_category_var_samp_order_by
  variance: tenant_category_variance_order_by
}

"""
input type for inserting array relation for remote table "tenant_category"
"""
input tenant_category_arr_rel_insert_input {
  data: [tenant_category_insert_input!]!

  """upsert condition"""
  on_conflict: tenant_category_on_conflict
}

"""aggregate avg on columns"""
type tenant_category_avg_fields {
  category_id: Float
  id: Float
}

"""
order by avg() on columns of table "tenant_category"
"""
input tenant_category_avg_order_by {
  category_id: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "tenant_category". All fields are combined with a logical 'AND'.
"""
input tenant_category_bool_exp {
  _and: [tenant_category_bool_exp!]
  _not: tenant_category_bool_exp
  _or: [tenant_category_bool_exp!]
  category: category_bool_exp
  category_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  tenant: tenant_bool_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "tenant_category"
"""
enum tenant_category_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tenant_category_pkey

  """
  unique or primary key constraint on columns "category_id", "tenant_id"
  """
  tenant_category_tenant_id_category_id_key
}

"""
input type for incrementing numeric columns in table "tenant_category"
"""
input tenant_category_inc_input {
  category_id: Int
  id: bigint
}

"""
input type for inserting data into table "tenant_category"
"""
input tenant_category_insert_input {
  category: category_obj_rel_insert_input
  category_id: Int
  created_at: timestamptz
  id: bigint
  tenant: tenant_obj_rel_insert_input
  tenant_id: uuid
}

"""aggregate max on columns"""
type tenant_category_max_fields {
  category_id: Int
  created_at: timestamptz
  id: bigint
  tenant_id: uuid
}

"""
order by max() on columns of table "tenant_category"
"""
input tenant_category_max_order_by {
  category_id: order_by
  created_at: order_by
  id: order_by
  tenant_id: order_by
}

"""aggregate min on columns"""
type tenant_category_min_fields {
  category_id: Int
  created_at: timestamptz
  id: bigint
  tenant_id: uuid
}

"""
order by min() on columns of table "tenant_category"
"""
input tenant_category_min_order_by {
  category_id: order_by
  created_at: order_by
  id: order_by
  tenant_id: order_by
}

"""
response of any mutation on the table "tenant_category"
"""
type tenant_category_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tenant_category!]!
}

"""
on_conflict condition type for table "tenant_category"
"""
input tenant_category_on_conflict {
  constraint: tenant_category_constraint!
  update_columns: [tenant_category_update_column!]! = []
  where: tenant_category_bool_exp
}

"""Ordering options when selecting data from "tenant_category"."""
input tenant_category_order_by {
  category: category_order_by
  category_id: order_by
  created_at: order_by
  id: order_by
  tenant: tenant_order_by
  tenant_id: order_by
}

"""primary key columns input for table: tenant_category"""
input tenant_category_pk_columns_input {
  id: bigint!
}

"""
select columns of table "tenant_category"
"""
enum tenant_category_select_column {
  """column name"""
  category_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  tenant_id
}

"""
input type for updating data in table "tenant_category"
"""
input tenant_category_set_input {
  category_id: Int
  created_at: timestamptz
  id: bigint
  tenant_id: uuid
}

"""aggregate stddev on columns"""
type tenant_category_stddev_fields {
  category_id: Float
  id: Float
}

"""
order by stddev() on columns of table "tenant_category"
"""
input tenant_category_stddev_order_by {
  category_id: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type tenant_category_stddev_pop_fields {
  category_id: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "tenant_category"
"""
input tenant_category_stddev_pop_order_by {
  category_id: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type tenant_category_stddev_samp_fields {
  category_id: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "tenant_category"
"""
input tenant_category_stddev_samp_order_by {
  category_id: order_by
  id: order_by
}

"""
Streaming cursor of the table "tenant_category"
"""
input tenant_category_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tenant_category_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tenant_category_stream_cursor_value_input {
  category_id: Int
  created_at: timestamptz
  id: bigint
  tenant_id: uuid
}

"""aggregate sum on columns"""
type tenant_category_sum_fields {
  category_id: Int
  id: bigint
}

"""
order by sum() on columns of table "tenant_category"
"""
input tenant_category_sum_order_by {
  category_id: order_by
  id: order_by
}

"""
update columns of table "tenant_category"
"""
enum tenant_category_update_column {
  """column name"""
  category_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  tenant_id
}

input tenant_category_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: tenant_category_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: tenant_category_set_input

  """filter the rows which have to be updated"""
  where: tenant_category_bool_exp!
}

"""aggregate var_pop on columns"""
type tenant_category_var_pop_fields {
  category_id: Float
  id: Float
}

"""
order by var_pop() on columns of table "tenant_category"
"""
input tenant_category_var_pop_order_by {
  category_id: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type tenant_category_var_samp_fields {
  category_id: Float
  id: Float
}

"""
order by var_samp() on columns of table "tenant_category"
"""
input tenant_category_var_samp_order_by {
  category_id: order_by
  id: order_by
}

"""aggregate variance on columns"""
type tenant_category_variance_fields {
  category_id: Float
  id: Float
}

"""
order by variance() on columns of table "tenant_category"
"""
input tenant_category_variance_order_by {
  category_id: order_by
  id: order_by
}

"""
unique or primary key constraints on table "tenant"
"""
enum tenant_constraint {
  """
  unique or primary key constraint on columns "owner_id"
  """
  tenant_owner_id_key

  """
  unique or primary key constraint on columns "id"
  """
  tenant_pkey
}

"""
input type for incrementing numeric columns in table "tenant"
"""
input tenant_inc_input {
  commision_rate: numeric
  quarter_id: Int
  tax_quarter_id: Int
}

"""
input type for inserting data into table "tenant"
"""
input tenant_insert_input {
  address: String
  categories: tenant_category_arr_rel_insert_input
  commision_rate: numeric
  company_type: company_type_enum
  company_type_rel: company_type_obj_rel_insert_input
  created_at: timestamptz
  iban: String
  iban_holder_name: String
  id: uuid
  is_active: Boolean
  iyzi_sub_merchant_key: String
  legal_company_title: String
  logo: String
  name: String
  off_days: [Int!]
  owner: user_obj_rel_insert_input
  owner_id: uuid
  phone: String
  quarter: quarter_obj_rel_insert_input
  quarter_id: Int
  tax_office_name: String
  tax_plate_url: String
  tax_quarter: quarter_obj_rel_insert_input
  tax_quarter_id: Int
  tenant_addresses: tenant_address_arr_rel_insert_input
  tenant_shipping_places: tenant_shipping_place_arr_rel_insert_input
  updated_at: timestamptz
  vkn_tckn: String
}

"""aggregate max on columns"""
type tenant_max_fields {
  address: String
  commision_rate: numeric
  created_at: timestamptz
  iban: String
  iban_holder_name: String
  id: uuid
  iyzi_sub_merchant_key: String
  legal_company_title: String
  logo: String
  name: String
  off_days: [Int!]
  owner_id: uuid
  phone: String
  quarter_id: Int
  tax_office_name: String
  tax_plate_url: String
  tax_quarter_id: Int
  updated_at: timestamptz
  vkn_tckn: String
}

"""
order by max() on columns of table "tenant"
"""
input tenant_max_order_by {
  address: order_by
  commision_rate: order_by
  created_at: order_by
  iban: order_by
  iban_holder_name: order_by
  id: order_by
  iyzi_sub_merchant_key: order_by
  legal_company_title: order_by
  logo: order_by
  name: order_by
  off_days: order_by
  owner_id: order_by
  phone: order_by
  quarter_id: order_by
  tax_office_name: order_by
  tax_plate_url: order_by
  tax_quarter_id: order_by
  updated_at: order_by
  vkn_tckn: order_by
}

"""aggregate min on columns"""
type tenant_min_fields {
  address: String
  commision_rate: numeric
  created_at: timestamptz
  iban: String
  iban_holder_name: String
  id: uuid
  iyzi_sub_merchant_key: String
  legal_company_title: String
  logo: String
  name: String
  off_days: [Int!]
  owner_id: uuid
  phone: String
  quarter_id: Int
  tax_office_name: String
  tax_plate_url: String
  tax_quarter_id: Int
  updated_at: timestamptz
  vkn_tckn: String
}

"""
order by min() on columns of table "tenant"
"""
input tenant_min_order_by {
  address: order_by
  commision_rate: order_by
  created_at: order_by
  iban: order_by
  iban_holder_name: order_by
  id: order_by
  iyzi_sub_merchant_key: order_by
  legal_company_title: order_by
  logo: order_by
  name: order_by
  off_days: order_by
  owner_id: order_by
  phone: order_by
  quarter_id: order_by
  tax_office_name: order_by
  tax_plate_url: order_by
  tax_quarter_id: order_by
  updated_at: order_by
  vkn_tckn: order_by
}

"""
response of any mutation on the table "tenant"
"""
type tenant_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tenant!]!
}

"""
input type for inserting object relation for remote table "tenant"
"""
input tenant_obj_rel_insert_input {
  data: tenant_insert_input!

  """upsert condition"""
  on_conflict: tenant_on_conflict
}

"""
on_conflict condition type for table "tenant"
"""
input tenant_on_conflict {
  constraint: tenant_constraint!
  update_columns: [tenant_update_column!]! = []
  where: tenant_bool_exp
}

"""Ordering options when selecting data from "tenant"."""
input tenant_order_by {
  address: order_by
  categories_aggregate: tenant_category_aggregate_order_by
  commision_rate: order_by
  company_type: order_by
  company_type_rel: company_type_order_by
  created_at: order_by
  iban: order_by
  iban_holder_name: order_by
  id: order_by
  is_active: order_by
  iyzi_sub_merchant_key: order_by
  legal_company_title: order_by
  logo: order_by
  name: order_by
  off_days: order_by
  owner: user_order_by
  owner_id: order_by
  phone: order_by
  quarter: quarter_order_by
  quarter_id: order_by
  tax_office_name: order_by
  tax_plate_url: order_by
  tax_quarter: quarter_order_by
  tax_quarter_id: order_by
  tenant_addresses_aggregate: tenant_address_aggregate_order_by
  tenant_shipping_places_aggregate: tenant_shipping_place_aggregate_order_by
  updated_at: order_by
  vkn_tckn: order_by
}

"""primary key columns input for table: tenant"""
input tenant_pk_columns_input {
  id: uuid!
}

"""
select columns of table "tenant"
"""
enum tenant_select_column {
  """column name"""
  address

  """column name"""
  commision_rate

  """column name"""
  company_type

  """column name"""
  created_at

  """column name"""
  iban

  """column name"""
  iban_holder_name

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  iyzi_sub_merchant_key

  """column name"""
  legal_company_title

  """column name"""
  logo

  """column name"""
  name

  """column name"""
  off_days

  """column name"""
  owner_id

  """column name"""
  phone

  """column name"""
  quarter_id

  """column name"""
  tax_office_name

  """column name"""
  tax_plate_url

  """column name"""
  tax_quarter_id

  """column name"""
  updated_at

  """column name"""
  vkn_tckn
}

"""
select "tenant_aggregate_bool_exp_bool_and_arguments_columns" columns of table "tenant"
"""
enum tenant_select_column_tenant_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_active
}

"""
select "tenant_aggregate_bool_exp_bool_or_arguments_columns" columns of table "tenant"
"""
enum tenant_select_column_tenant_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_active
}

"""
input type for updating data in table "tenant"
"""
input tenant_set_input {
  address: String
  commision_rate: numeric
  company_type: company_type_enum
  created_at: timestamptz
  iban: String
  iban_holder_name: String
  id: uuid
  is_active: Boolean
  iyzi_sub_merchant_key: String
  legal_company_title: String
  logo: String
  name: String
  off_days: [Int!]
  owner_id: uuid
  phone: String
  quarter_id: Int
  tax_office_name: String
  tax_plate_url: String
  tax_quarter_id: Int
  updated_at: timestamptz
  vkn_tckn: String
}

"""
columns and relationships of "tenant_shipping_place"
"""
type tenant_shipping_place {
  id: Int!
  is_active: Boolean

  """An object relationship"""
  quarter: quarter!
  quarter_code: Int!

  """An object relationship"""
  tenant: tenant!
  tenant_id: uuid!
}

"""
aggregated selection of "tenant_shipping_place"
"""
type tenant_shipping_place_aggregate {
  aggregate: tenant_shipping_place_aggregate_fields
  nodes: [tenant_shipping_place!]!
}

input tenant_shipping_place_aggregate_bool_exp {
  bool_and: tenant_shipping_place_aggregate_bool_exp_bool_and
  bool_or: tenant_shipping_place_aggregate_bool_exp_bool_or
  count: tenant_shipping_place_aggregate_bool_exp_count
}

input tenant_shipping_place_aggregate_bool_exp_bool_and {
  arguments: tenant_shipping_place_select_column_tenant_shipping_place_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: tenant_shipping_place_bool_exp
  predicate: Boolean_comparison_exp!
}

input tenant_shipping_place_aggregate_bool_exp_bool_or {
  arguments: tenant_shipping_place_select_column_tenant_shipping_place_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: tenant_shipping_place_bool_exp
  predicate: Boolean_comparison_exp!
}

input tenant_shipping_place_aggregate_bool_exp_count {
  arguments: [tenant_shipping_place_select_column!]
  distinct: Boolean
  filter: tenant_shipping_place_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "tenant_shipping_place"
"""
type tenant_shipping_place_aggregate_fields {
  avg: tenant_shipping_place_avg_fields
  count(columns: [tenant_shipping_place_select_column!], distinct: Boolean): Int!
  max: tenant_shipping_place_max_fields
  min: tenant_shipping_place_min_fields
  stddev: tenant_shipping_place_stddev_fields
  stddev_pop: tenant_shipping_place_stddev_pop_fields
  stddev_samp: tenant_shipping_place_stddev_samp_fields
  sum: tenant_shipping_place_sum_fields
  var_pop: tenant_shipping_place_var_pop_fields
  var_samp: tenant_shipping_place_var_samp_fields
  variance: tenant_shipping_place_variance_fields
}

"""
order by aggregate values of table "tenant_shipping_place"
"""
input tenant_shipping_place_aggregate_order_by {
  avg: tenant_shipping_place_avg_order_by
  count: order_by
  max: tenant_shipping_place_max_order_by
  min: tenant_shipping_place_min_order_by
  stddev: tenant_shipping_place_stddev_order_by
  stddev_pop: tenant_shipping_place_stddev_pop_order_by
  stddev_samp: tenant_shipping_place_stddev_samp_order_by
  sum: tenant_shipping_place_sum_order_by
  var_pop: tenant_shipping_place_var_pop_order_by
  var_samp: tenant_shipping_place_var_samp_order_by
  variance: tenant_shipping_place_variance_order_by
}

"""
input type for inserting array relation for remote table "tenant_shipping_place"
"""
input tenant_shipping_place_arr_rel_insert_input {
  data: [tenant_shipping_place_insert_input!]!

  """upsert condition"""
  on_conflict: tenant_shipping_place_on_conflict
}

"""aggregate avg on columns"""
type tenant_shipping_place_avg_fields {
  id: Float
  quarter_code: Float
}

"""
order by avg() on columns of table "tenant_shipping_place"
"""
input tenant_shipping_place_avg_order_by {
  id: order_by
  quarter_code: order_by
}

"""
Boolean expression to filter rows from the table "tenant_shipping_place". All fields are combined with a logical 'AND'.
"""
input tenant_shipping_place_bool_exp {
  _and: [tenant_shipping_place_bool_exp!]
  _not: tenant_shipping_place_bool_exp
  _or: [tenant_shipping_place_bool_exp!]
  id: Int_comparison_exp
  is_active: Boolean_comparison_exp
  quarter: quarter_bool_exp
  quarter_code: Int_comparison_exp
  tenant: tenant_bool_exp
  tenant_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "tenant_shipping_place"
"""
enum tenant_shipping_place_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  tenant_shipping_place_pkey

  """
  unique or primary key constraint on columns "quarter_code", "tenant_id"
  """
  tenant_shipping_place_tenant_id_quarter_code_key
}

"""
input type for incrementing numeric columns in table "tenant_shipping_place"
"""
input tenant_shipping_place_inc_input {
  id: Int
  quarter_code: Int
}

"""
input type for inserting data into table "tenant_shipping_place"
"""
input tenant_shipping_place_insert_input {
  id: Int
  is_active: Boolean
  quarter: quarter_obj_rel_insert_input
  quarter_code: Int
  tenant: tenant_obj_rel_insert_input
  tenant_id: uuid
}

"""aggregate max on columns"""
type tenant_shipping_place_max_fields {
  id: Int
  quarter_code: Int
  tenant_id: uuid
}

"""
order by max() on columns of table "tenant_shipping_place"
"""
input tenant_shipping_place_max_order_by {
  id: order_by
  quarter_code: order_by
  tenant_id: order_by
}

"""aggregate min on columns"""
type tenant_shipping_place_min_fields {
  id: Int
  quarter_code: Int
  tenant_id: uuid
}

"""
order by min() on columns of table "tenant_shipping_place"
"""
input tenant_shipping_place_min_order_by {
  id: order_by
  quarter_code: order_by
  tenant_id: order_by
}

"""
response of any mutation on the table "tenant_shipping_place"
"""
type tenant_shipping_place_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tenant_shipping_place!]!
}

"""
on_conflict condition type for table "tenant_shipping_place"
"""
input tenant_shipping_place_on_conflict {
  constraint: tenant_shipping_place_constraint!
  update_columns: [tenant_shipping_place_update_column!]! = []
  where: tenant_shipping_place_bool_exp
}

"""Ordering options when selecting data from "tenant_shipping_place"."""
input tenant_shipping_place_order_by {
  id: order_by
  is_active: order_by
  quarter: quarter_order_by
  quarter_code: order_by
  tenant: tenant_order_by
  tenant_id: order_by
}

"""primary key columns input for table: tenant_shipping_place"""
input tenant_shipping_place_pk_columns_input {
  id: Int!
}

"""
select columns of table "tenant_shipping_place"
"""
enum tenant_shipping_place_select_column {
  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  quarter_code

  """column name"""
  tenant_id
}

"""
select "tenant_shipping_place_aggregate_bool_exp_bool_and_arguments_columns" columns of table "tenant_shipping_place"
"""
enum tenant_shipping_place_select_column_tenant_shipping_place_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_active
}

"""
select "tenant_shipping_place_aggregate_bool_exp_bool_or_arguments_columns" columns of table "tenant_shipping_place"
"""
enum tenant_shipping_place_select_column_tenant_shipping_place_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_active
}

"""
input type for updating data in table "tenant_shipping_place"
"""
input tenant_shipping_place_set_input {
  id: Int
  is_active: Boolean
  quarter_code: Int
  tenant_id: uuid
}

"""aggregate stddev on columns"""
type tenant_shipping_place_stddev_fields {
  id: Float
  quarter_code: Float
}

"""
order by stddev() on columns of table "tenant_shipping_place"
"""
input tenant_shipping_place_stddev_order_by {
  id: order_by
  quarter_code: order_by
}

"""aggregate stddev_pop on columns"""
type tenant_shipping_place_stddev_pop_fields {
  id: Float
  quarter_code: Float
}

"""
order by stddev_pop() on columns of table "tenant_shipping_place"
"""
input tenant_shipping_place_stddev_pop_order_by {
  id: order_by
  quarter_code: order_by
}

"""aggregate stddev_samp on columns"""
type tenant_shipping_place_stddev_samp_fields {
  id: Float
  quarter_code: Float
}

"""
order by stddev_samp() on columns of table "tenant_shipping_place"
"""
input tenant_shipping_place_stddev_samp_order_by {
  id: order_by
  quarter_code: order_by
}

"""
Streaming cursor of the table "tenant_shipping_place"
"""
input tenant_shipping_place_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tenant_shipping_place_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tenant_shipping_place_stream_cursor_value_input {
  id: Int
  is_active: Boolean
  quarter_code: Int
  tenant_id: uuid
}

"""aggregate sum on columns"""
type tenant_shipping_place_sum_fields {
  id: Int
  quarter_code: Int
}

"""
order by sum() on columns of table "tenant_shipping_place"
"""
input tenant_shipping_place_sum_order_by {
  id: order_by
  quarter_code: order_by
}

"""
update columns of table "tenant_shipping_place"
"""
enum tenant_shipping_place_update_column {
  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  quarter_code

  """column name"""
  tenant_id
}

input tenant_shipping_place_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: tenant_shipping_place_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: tenant_shipping_place_set_input

  """filter the rows which have to be updated"""
  where: tenant_shipping_place_bool_exp!
}

"""aggregate var_pop on columns"""
type tenant_shipping_place_var_pop_fields {
  id: Float
  quarter_code: Float
}

"""
order by var_pop() on columns of table "tenant_shipping_place"
"""
input tenant_shipping_place_var_pop_order_by {
  id: order_by
  quarter_code: order_by
}

"""aggregate var_samp on columns"""
type tenant_shipping_place_var_samp_fields {
  id: Float
  quarter_code: Float
}

"""
order by var_samp() on columns of table "tenant_shipping_place"
"""
input tenant_shipping_place_var_samp_order_by {
  id: order_by
  quarter_code: order_by
}

"""aggregate variance on columns"""
type tenant_shipping_place_variance_fields {
  id: Float
  quarter_code: Float
}

"""
order by variance() on columns of table "tenant_shipping_place"
"""
input tenant_shipping_place_variance_order_by {
  id: order_by
  quarter_code: order_by
}

"""aggregate stddev on columns"""
type tenant_stddev_fields {
  commision_rate: Float
  quarter_id: Float
  tax_quarter_id: Float
}

"""
order by stddev() on columns of table "tenant"
"""
input tenant_stddev_order_by {
  commision_rate: order_by
  quarter_id: order_by
  tax_quarter_id: order_by
}

"""aggregate stddev_pop on columns"""
type tenant_stddev_pop_fields {
  commision_rate: Float
  quarter_id: Float
  tax_quarter_id: Float
}

"""
order by stddev_pop() on columns of table "tenant"
"""
input tenant_stddev_pop_order_by {
  commision_rate: order_by
  quarter_id: order_by
  tax_quarter_id: order_by
}

"""aggregate stddev_samp on columns"""
type tenant_stddev_samp_fields {
  commision_rate: Float
  quarter_id: Float
  tax_quarter_id: Float
}

"""
order by stddev_samp() on columns of table "tenant"
"""
input tenant_stddev_samp_order_by {
  commision_rate: order_by
  quarter_id: order_by
  tax_quarter_id: order_by
}

"""
Streaming cursor of the table "tenant"
"""
input tenant_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tenant_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tenant_stream_cursor_value_input {
  address: String
  commision_rate: numeric
  company_type: company_type_enum
  created_at: timestamptz
  iban: String
  iban_holder_name: String
  id: uuid
  is_active: Boolean
  iyzi_sub_merchant_key: String
  legal_company_title: String
  logo: String
  name: String
  off_days: [Int!]
  owner_id: uuid
  phone: String
  quarter_id: Int
  tax_office_name: String
  tax_plate_url: String
  tax_quarter_id: Int
  updated_at: timestamptz
  vkn_tckn: String
}

"""aggregate sum on columns"""
type tenant_sum_fields {
  commision_rate: numeric
  quarter_id: Int
  tax_quarter_id: Int
}

"""
order by sum() on columns of table "tenant"
"""
input tenant_sum_order_by {
  commision_rate: order_by
  quarter_id: order_by
  tax_quarter_id: order_by
}

"""
update columns of table "tenant"
"""
enum tenant_update_column {
  """column name"""
  address

  """column name"""
  commision_rate

  """column name"""
  company_type

  """column name"""
  created_at

  """column name"""
  iban

  """column name"""
  iban_holder_name

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  iyzi_sub_merchant_key

  """column name"""
  legal_company_title

  """column name"""
  logo

  """column name"""
  name

  """column name"""
  off_days

  """column name"""
  owner_id

  """column name"""
  phone

  """column name"""
  quarter_id

  """column name"""
  tax_office_name

  """column name"""
  tax_plate_url

  """column name"""
  tax_quarter_id

  """column name"""
  updated_at

  """column name"""
  vkn_tckn
}

input tenant_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: tenant_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: tenant_set_input

  """filter the rows which have to be updated"""
  where: tenant_bool_exp!
}

"""aggregate var_pop on columns"""
type tenant_var_pop_fields {
  commision_rate: Float
  quarter_id: Float
  tax_quarter_id: Float
}

"""
order by var_pop() on columns of table "tenant"
"""
input tenant_var_pop_order_by {
  commision_rate: order_by
  quarter_id: order_by
  tax_quarter_id: order_by
}

"""aggregate var_samp on columns"""
type tenant_var_samp_fields {
  commision_rate: Float
  quarter_id: Float
  tax_quarter_id: Float
}

"""
order by var_samp() on columns of table "tenant"
"""
input tenant_var_samp_order_by {
  commision_rate: order_by
  quarter_id: order_by
  tax_quarter_id: order_by
}

"""aggregate variance on columns"""
type tenant_variance_fields {
  commision_rate: Float
  quarter_id: Float
  tax_quarter_id: Float
}

"""
order by variance() on columns of table "tenant"
"""
input tenant_variance_order_by {
  commision_rate: order_by
  quarter_id: order_by
  tax_quarter_id: order_by
}

"""Support tickets that opened by tenant to system admin"""
type ticket {
  attachments: [String!]
  created_at: timestamptz!
  description: String!
  id: bigint!

  """An object relationship"""
  order_tenant: order_tenant
  order_tenant_id: bigint
  status: ticket_status_enum

  """An object relationship"""
  tenant: user!
  tenant_id: uuid!

  """An array relationship"""
  ticket_answers(
    """distinct select on columns"""
    distinct_on: [ticket_answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_answer_order_by!]

    """filter the rows returned"""
    where: ticket_answer_bool_exp
  ): [ticket_answer!]!

  """An aggregate relationship"""
  ticket_answers_aggregate(
    """distinct select on columns"""
    distinct_on: [ticket_answer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_answer_order_by!]

    """filter the rows returned"""
    where: ticket_answer_bool_exp
  ): ticket_answer_aggregate!

  """An object relationship"""
  ticket_status: ticket_status
  title: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "ticket"
"""
type ticket_aggregate {
  aggregate: ticket_aggregate_fields
  nodes: [ticket!]!
}

input ticket_aggregate_bool_exp {
  count: ticket_aggregate_bool_exp_count
}

input ticket_aggregate_bool_exp_count {
  arguments: [ticket_select_column!]
  distinct: Boolean
  filter: ticket_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "ticket"
"""
type ticket_aggregate_fields {
  avg: ticket_avg_fields
  count(columns: [ticket_select_column!], distinct: Boolean): Int!
  max: ticket_max_fields
  min: ticket_min_fields
  stddev: ticket_stddev_fields
  stddev_pop: ticket_stddev_pop_fields
  stddev_samp: ticket_stddev_samp_fields
  sum: ticket_sum_fields
  var_pop: ticket_var_pop_fields
  var_samp: ticket_var_samp_fields
  variance: ticket_variance_fields
}

"""
order by aggregate values of table "ticket"
"""
input ticket_aggregate_order_by {
  avg: ticket_avg_order_by
  count: order_by
  max: ticket_max_order_by
  min: ticket_min_order_by
  stddev: ticket_stddev_order_by
  stddev_pop: ticket_stddev_pop_order_by
  stddev_samp: ticket_stddev_samp_order_by
  sum: ticket_sum_order_by
  var_pop: ticket_var_pop_order_by
  var_samp: ticket_var_samp_order_by
  variance: ticket_variance_order_by
}

"""
columns and relationships of "ticket_answer"
"""
type ticket_answer {
  answer: String!
  author: String!
  created_at: timestamptz!
  id: uuid!

  """An object relationship"""
  ticket: ticket!
  ticket_id: bigint!
  updated_at: timestamptz!
}

"""
aggregated selection of "ticket_answer"
"""
type ticket_answer_aggregate {
  aggregate: ticket_answer_aggregate_fields
  nodes: [ticket_answer!]!
}

input ticket_answer_aggregate_bool_exp {
  count: ticket_answer_aggregate_bool_exp_count
}

input ticket_answer_aggregate_bool_exp_count {
  arguments: [ticket_answer_select_column!]
  distinct: Boolean
  filter: ticket_answer_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "ticket_answer"
"""
type ticket_answer_aggregate_fields {
  avg: ticket_answer_avg_fields
  count(columns: [ticket_answer_select_column!], distinct: Boolean): Int!
  max: ticket_answer_max_fields
  min: ticket_answer_min_fields
  stddev: ticket_answer_stddev_fields
  stddev_pop: ticket_answer_stddev_pop_fields
  stddev_samp: ticket_answer_stddev_samp_fields
  sum: ticket_answer_sum_fields
  var_pop: ticket_answer_var_pop_fields
  var_samp: ticket_answer_var_samp_fields
  variance: ticket_answer_variance_fields
}

"""
order by aggregate values of table "ticket_answer"
"""
input ticket_answer_aggregate_order_by {
  avg: ticket_answer_avg_order_by
  count: order_by
  max: ticket_answer_max_order_by
  min: ticket_answer_min_order_by
  stddev: ticket_answer_stddev_order_by
  stddev_pop: ticket_answer_stddev_pop_order_by
  stddev_samp: ticket_answer_stddev_samp_order_by
  sum: ticket_answer_sum_order_by
  var_pop: ticket_answer_var_pop_order_by
  var_samp: ticket_answer_var_samp_order_by
  variance: ticket_answer_variance_order_by
}

"""
input type for inserting array relation for remote table "ticket_answer"
"""
input ticket_answer_arr_rel_insert_input {
  data: [ticket_answer_insert_input!]!

  """upsert condition"""
  on_conflict: ticket_answer_on_conflict
}

"""aggregate avg on columns"""
type ticket_answer_avg_fields {
  ticket_id: Float
}

"""
order by avg() on columns of table "ticket_answer"
"""
input ticket_answer_avg_order_by {
  ticket_id: order_by
}

"""
Boolean expression to filter rows from the table "ticket_answer". All fields are combined with a logical 'AND'.
"""
input ticket_answer_bool_exp {
  _and: [ticket_answer_bool_exp!]
  _not: ticket_answer_bool_exp
  _or: [ticket_answer_bool_exp!]
  answer: String_comparison_exp
  author: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  ticket: ticket_bool_exp
  ticket_id: bigint_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "ticket_answer"
"""
enum ticket_answer_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  ticket_answer_id_key

  """
  unique or primary key constraint on columns "id"
  """
  ticket_answer_pkey
}

"""
input type for incrementing numeric columns in table "ticket_answer"
"""
input ticket_answer_inc_input {
  ticket_id: bigint
}

"""
input type for inserting data into table "ticket_answer"
"""
input ticket_answer_insert_input {
  answer: String
  author: String
  created_at: timestamptz
  id: uuid
  ticket: ticket_obj_rel_insert_input
  ticket_id: bigint
  updated_at: timestamptz
}

"""aggregate max on columns"""
type ticket_answer_max_fields {
  answer: String
  author: String
  created_at: timestamptz
  id: uuid
  ticket_id: bigint
  updated_at: timestamptz
}

"""
order by max() on columns of table "ticket_answer"
"""
input ticket_answer_max_order_by {
  answer: order_by
  author: order_by
  created_at: order_by
  id: order_by
  ticket_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type ticket_answer_min_fields {
  answer: String
  author: String
  created_at: timestamptz
  id: uuid
  ticket_id: bigint
  updated_at: timestamptz
}

"""
order by min() on columns of table "ticket_answer"
"""
input ticket_answer_min_order_by {
  answer: order_by
  author: order_by
  created_at: order_by
  id: order_by
  ticket_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "ticket_answer"
"""
type ticket_answer_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ticket_answer!]!
}

"""
on_conflict condition type for table "ticket_answer"
"""
input ticket_answer_on_conflict {
  constraint: ticket_answer_constraint!
  update_columns: [ticket_answer_update_column!]! = []
  where: ticket_answer_bool_exp
}

"""Ordering options when selecting data from "ticket_answer"."""
input ticket_answer_order_by {
  answer: order_by
  author: order_by
  created_at: order_by
  id: order_by
  ticket: ticket_order_by
  ticket_id: order_by
  updated_at: order_by
}

"""primary key columns input for table: ticket_answer"""
input ticket_answer_pk_columns_input {
  id: uuid!
}

"""
select columns of table "ticket_answer"
"""
enum ticket_answer_select_column {
  """column name"""
  answer

  """column name"""
  author

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  ticket_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "ticket_answer"
"""
input ticket_answer_set_input {
  answer: String
  author: String
  created_at: timestamptz
  id: uuid
  ticket_id: bigint
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type ticket_answer_stddev_fields {
  ticket_id: Float
}

"""
order by stddev() on columns of table "ticket_answer"
"""
input ticket_answer_stddev_order_by {
  ticket_id: order_by
}

"""aggregate stddev_pop on columns"""
type ticket_answer_stddev_pop_fields {
  ticket_id: Float
}

"""
order by stddev_pop() on columns of table "ticket_answer"
"""
input ticket_answer_stddev_pop_order_by {
  ticket_id: order_by
}

"""aggregate stddev_samp on columns"""
type ticket_answer_stddev_samp_fields {
  ticket_id: Float
}

"""
order by stddev_samp() on columns of table "ticket_answer"
"""
input ticket_answer_stddev_samp_order_by {
  ticket_id: order_by
}

"""
Streaming cursor of the table "ticket_answer"
"""
input ticket_answer_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ticket_answer_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ticket_answer_stream_cursor_value_input {
  answer: String
  author: String
  created_at: timestamptz
  id: uuid
  ticket_id: bigint
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type ticket_answer_sum_fields {
  ticket_id: bigint
}

"""
order by sum() on columns of table "ticket_answer"
"""
input ticket_answer_sum_order_by {
  ticket_id: order_by
}

"""
update columns of table "ticket_answer"
"""
enum ticket_answer_update_column {
  """column name"""
  answer

  """column name"""
  author

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  ticket_id

  """column name"""
  updated_at
}

input ticket_answer_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ticket_answer_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: ticket_answer_set_input

  """filter the rows which have to be updated"""
  where: ticket_answer_bool_exp!
}

"""aggregate var_pop on columns"""
type ticket_answer_var_pop_fields {
  ticket_id: Float
}

"""
order by var_pop() on columns of table "ticket_answer"
"""
input ticket_answer_var_pop_order_by {
  ticket_id: order_by
}

"""aggregate var_samp on columns"""
type ticket_answer_var_samp_fields {
  ticket_id: Float
}

"""
order by var_samp() on columns of table "ticket_answer"
"""
input ticket_answer_var_samp_order_by {
  ticket_id: order_by
}

"""aggregate variance on columns"""
type ticket_answer_variance_fields {
  ticket_id: Float
}

"""
order by variance() on columns of table "ticket_answer"
"""
input ticket_answer_variance_order_by {
  ticket_id: order_by
}

"""
input type for inserting array relation for remote table "ticket"
"""
input ticket_arr_rel_insert_input {
  data: [ticket_insert_input!]!

  """upsert condition"""
  on_conflict: ticket_on_conflict
}

"""aggregate avg on columns"""
type ticket_avg_fields {
  id: Float
  order_tenant_id: Float
}

"""
order by avg() on columns of table "ticket"
"""
input ticket_avg_order_by {
  id: order_by
  order_tenant_id: order_by
}

"""
Boolean expression to filter rows from the table "ticket". All fields are combined with a logical 'AND'.
"""
input ticket_bool_exp {
  _and: [ticket_bool_exp!]
  _not: ticket_bool_exp
  _or: [ticket_bool_exp!]
  attachments: String_array_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: bigint_comparison_exp
  order_tenant: order_tenant_bool_exp
  order_tenant_id: bigint_comparison_exp
  status: ticket_status_enum_comparison_exp
  tenant: user_bool_exp
  tenant_id: uuid_comparison_exp
  ticket_answers: ticket_answer_bool_exp
  ticket_answers_aggregate: ticket_answer_aggregate_bool_exp
  ticket_status: ticket_status_bool_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "ticket"
"""
enum ticket_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  ticket_pkey
}

"""
input type for incrementing numeric columns in table "ticket"
"""
input ticket_inc_input {
  id: bigint
  order_tenant_id: bigint
}

"""
input type for inserting data into table "ticket"
"""
input ticket_insert_input {
  attachments: [String!]
  created_at: timestamptz
  description: String
  id: bigint
  order_tenant: order_tenant_obj_rel_insert_input
  order_tenant_id: bigint
  status: ticket_status_enum
  tenant: user_obj_rel_insert_input
  tenant_id: uuid
  ticket_answers: ticket_answer_arr_rel_insert_input
  ticket_status: ticket_status_obj_rel_insert_input
  title: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type ticket_max_fields {
  attachments: [String!]
  created_at: timestamptz
  description: String
  id: bigint
  order_tenant_id: bigint
  tenant_id: uuid
  title: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "ticket"
"""
input ticket_max_order_by {
  attachments: order_by
  created_at: order_by
  description: order_by
  id: order_by
  order_tenant_id: order_by
  tenant_id: order_by
  title: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type ticket_min_fields {
  attachments: [String!]
  created_at: timestamptz
  description: String
  id: bigint
  order_tenant_id: bigint
  tenant_id: uuid
  title: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "ticket"
"""
input ticket_min_order_by {
  attachments: order_by
  created_at: order_by
  description: order_by
  id: order_by
  order_tenant_id: order_by
  tenant_id: order_by
  title: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "ticket"
"""
type ticket_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ticket!]!
}

"""
input type for inserting object relation for remote table "ticket"
"""
input ticket_obj_rel_insert_input {
  data: ticket_insert_input!

  """upsert condition"""
  on_conflict: ticket_on_conflict
}

"""
on_conflict condition type for table "ticket"
"""
input ticket_on_conflict {
  constraint: ticket_constraint!
  update_columns: [ticket_update_column!]! = []
  where: ticket_bool_exp
}

"""Ordering options when selecting data from "ticket"."""
input ticket_order_by {
  attachments: order_by
  created_at: order_by
  description: order_by
  id: order_by
  order_tenant: order_tenant_order_by
  order_tenant_id: order_by
  status: order_by
  tenant: user_order_by
  tenant_id: order_by
  ticket_answers_aggregate: ticket_answer_aggregate_order_by
  ticket_status: ticket_status_order_by
  title: order_by
  updated_at: order_by
}

"""primary key columns input for table: ticket"""
input ticket_pk_columns_input {
  id: bigint!
}

"""
select columns of table "ticket"
"""
enum ticket_select_column {
  """column name"""
  attachments

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  order_tenant_id

  """column name"""
  status

  """column name"""
  tenant_id

  """column name"""
  title

  """column name"""
  updated_at
}

"""
input type for updating data in table "ticket"
"""
input ticket_set_input {
  attachments: [String!]
  created_at: timestamptz
  description: String
  id: bigint
  order_tenant_id: bigint
  status: ticket_status_enum
  tenant_id: uuid
  title: String
  updated_at: timestamptz
}

"""
columns and relationships of "ticket_status"
"""
type ticket_status {
  comment: String!

  """An array relationship"""
  tickets(
    """distinct select on columns"""
    distinct_on: [ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_order_by!]

    """filter the rows returned"""
    where: ticket_bool_exp
  ): [ticket!]!

  """An aggregate relationship"""
  tickets_aggregate(
    """distinct select on columns"""
    distinct_on: [ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_order_by!]

    """filter the rows returned"""
    where: ticket_bool_exp
  ): ticket_aggregate!
  value: String!
}

"""
aggregated selection of "ticket_status"
"""
type ticket_status_aggregate {
  aggregate: ticket_status_aggregate_fields
  nodes: [ticket_status!]!
}

"""
aggregate fields of "ticket_status"
"""
type ticket_status_aggregate_fields {
  count(columns: [ticket_status_select_column!], distinct: Boolean): Int!
  max: ticket_status_max_fields
  min: ticket_status_min_fields
}

"""
Boolean expression to filter rows from the table "ticket_status". All fields are combined with a logical 'AND'.
"""
input ticket_status_bool_exp {
  _and: [ticket_status_bool_exp!]
  _not: ticket_status_bool_exp
  _or: [ticket_status_bool_exp!]
  comment: String_comparison_exp
  tickets: ticket_bool_exp
  tickets_aggregate: ticket_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "ticket_status"
"""
enum ticket_status_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  ticket_status_pkey
}

enum ticket_status_enum {
  """ticket has been closed due timeout or solved"""
  Closed

  """ticket is in processing by system admin"""
  Processing

  """ticket answered by system admin to tenant"""
  Replied

  """ticket has been created in database"""
  Sent
}

"""
Boolean expression to compare columns of type "ticket_status_enum". All fields are combined with logical 'AND'.
"""
input ticket_status_enum_comparison_exp {
  _eq: ticket_status_enum
  _in: [ticket_status_enum!]
  _is_null: Boolean
  _neq: ticket_status_enum
  _nin: [ticket_status_enum!]
}

"""
input type for inserting data into table "ticket_status"
"""
input ticket_status_insert_input {
  comment: String
  tickets: ticket_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type ticket_status_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type ticket_status_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "ticket_status"
"""
type ticket_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ticket_status!]!
}

"""
input type for inserting object relation for remote table "ticket_status"
"""
input ticket_status_obj_rel_insert_input {
  data: ticket_status_insert_input!

  """upsert condition"""
  on_conflict: ticket_status_on_conflict
}

"""
on_conflict condition type for table "ticket_status"
"""
input ticket_status_on_conflict {
  constraint: ticket_status_constraint!
  update_columns: [ticket_status_update_column!]! = []
  where: ticket_status_bool_exp
}

"""Ordering options when selecting data from "ticket_status"."""
input ticket_status_order_by {
  comment: order_by
  tickets_aggregate: ticket_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: ticket_status"""
input ticket_status_pk_columns_input {
  value: String!
}

"""
select columns of table "ticket_status"
"""
enum ticket_status_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "ticket_status"
"""
input ticket_status_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "ticket_status"
"""
input ticket_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ticket_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ticket_status_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "ticket_status"
"""
enum ticket_status_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input ticket_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: ticket_status_set_input

  """filter the rows which have to be updated"""
  where: ticket_status_bool_exp!
}

"""aggregate stddev on columns"""
type ticket_stddev_fields {
  id: Float
  order_tenant_id: Float
}

"""
order by stddev() on columns of table "ticket"
"""
input ticket_stddev_order_by {
  id: order_by
  order_tenant_id: order_by
}

"""aggregate stddev_pop on columns"""
type ticket_stddev_pop_fields {
  id: Float
  order_tenant_id: Float
}

"""
order by stddev_pop() on columns of table "ticket"
"""
input ticket_stddev_pop_order_by {
  id: order_by
  order_tenant_id: order_by
}

"""aggregate stddev_samp on columns"""
type ticket_stddev_samp_fields {
  id: Float
  order_tenant_id: Float
}

"""
order by stddev_samp() on columns of table "ticket"
"""
input ticket_stddev_samp_order_by {
  id: order_by
  order_tenant_id: order_by
}

"""
Streaming cursor of the table "ticket"
"""
input ticket_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ticket_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ticket_stream_cursor_value_input {
  attachments: [String!]
  created_at: timestamptz
  description: String
  id: bigint
  order_tenant_id: bigint
  status: ticket_status_enum
  tenant_id: uuid
  title: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type ticket_sum_fields {
  id: bigint
  order_tenant_id: bigint
}

"""
order by sum() on columns of table "ticket"
"""
input ticket_sum_order_by {
  id: order_by
  order_tenant_id: order_by
}

"""
update columns of table "ticket"
"""
enum ticket_update_column {
  """column name"""
  attachments

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  order_tenant_id

  """column name"""
  status

  """column name"""
  tenant_id

  """column name"""
  title

  """column name"""
  updated_at
}

input ticket_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ticket_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: ticket_set_input

  """filter the rows which have to be updated"""
  where: ticket_bool_exp!
}

"""aggregate var_pop on columns"""
type ticket_var_pop_fields {
  id: Float
  order_tenant_id: Float
}

"""
order by var_pop() on columns of table "ticket"
"""
input ticket_var_pop_order_by {
  id: order_by
  order_tenant_id: order_by
}

"""aggregate var_samp on columns"""
type ticket_var_samp_fields {
  id: Float
  order_tenant_id: Float
}

"""
order by var_samp() on columns of table "ticket"
"""
input ticket_var_samp_order_by {
  id: order_by
  order_tenant_id: order_by
}

"""aggregate variance on columns"""
type ticket_variance_fields {
  id: Float
  order_tenant_id: Float
}

"""
order by variance() on columns of table "ticket"
"""
input ticket_variance_order_by {
  id: order_by
  order_tenant_id: order_by
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "transaction"
"""
type transaction {
  id: uuid!
  iyziEventTime: String
  iyziEventType: String
  iyziReferenceCode: String

  """An object relationship"""
  order: order
  paymentConversationId: String
  paymentId: String
  status: String
}

"""
aggregated selection of "transaction"
"""
type transaction_aggregate {
  aggregate: transaction_aggregate_fields
  nodes: [transaction!]!
}

input transaction_aggregate_bool_exp {
  count: transaction_aggregate_bool_exp_count
}

input transaction_aggregate_bool_exp_count {
  arguments: [transaction_select_column!]
  distinct: Boolean
  filter: transaction_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "transaction"
"""
type transaction_aggregate_fields {
  count(columns: [transaction_select_column!], distinct: Boolean): Int!
  max: transaction_max_fields
  min: transaction_min_fields
}

"""
order by aggregate values of table "transaction"
"""
input transaction_aggregate_order_by {
  count: order_by
  max: transaction_max_order_by
  min: transaction_min_order_by
}

"""
input type for inserting array relation for remote table "transaction"
"""
input transaction_arr_rel_insert_input {
  data: [transaction_insert_input!]!

  """upsert condition"""
  on_conflict: transaction_on_conflict
}

"""
Boolean expression to filter rows from the table "transaction". All fields are combined with a logical 'AND'.
"""
input transaction_bool_exp {
  _and: [transaction_bool_exp!]
  _not: transaction_bool_exp
  _or: [transaction_bool_exp!]
  id: uuid_comparison_exp
  iyziEventTime: String_comparison_exp
  iyziEventType: String_comparison_exp
  iyziReferenceCode: String_comparison_exp
  order: order_bool_exp
  paymentConversationId: String_comparison_exp
  paymentId: String_comparison_exp
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "transaction"
"""
enum transaction_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  transaction_pkey
}

"""
input type for inserting data into table "transaction"
"""
input transaction_insert_input {
  id: uuid
  iyziEventTime: String
  iyziEventType: String
  iyziReferenceCode: String
  order: order_obj_rel_insert_input
  paymentConversationId: String
  paymentId: String
  status: String
}

"""aggregate max on columns"""
type transaction_max_fields {
  id: uuid
  iyziEventTime: String
  iyziEventType: String
  iyziReferenceCode: String
  paymentConversationId: String
  paymentId: String
  status: String
}

"""
order by max() on columns of table "transaction"
"""
input transaction_max_order_by {
  id: order_by
  iyziEventTime: order_by
  iyziEventType: order_by
  iyziReferenceCode: order_by
  paymentConversationId: order_by
  paymentId: order_by
  status: order_by
}

"""aggregate min on columns"""
type transaction_min_fields {
  id: uuid
  iyziEventTime: String
  iyziEventType: String
  iyziReferenceCode: String
  paymentConversationId: String
  paymentId: String
  status: String
}

"""
order by min() on columns of table "transaction"
"""
input transaction_min_order_by {
  id: order_by
  iyziEventTime: order_by
  iyziEventType: order_by
  iyziReferenceCode: order_by
  paymentConversationId: order_by
  paymentId: order_by
  status: order_by
}

"""
response of any mutation on the table "transaction"
"""
type transaction_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [transaction!]!
}

"""
on_conflict condition type for table "transaction"
"""
input transaction_on_conflict {
  constraint: transaction_constraint!
  update_columns: [transaction_update_column!]! = []
  where: transaction_bool_exp
}

"""Ordering options when selecting data from "transaction"."""
input transaction_order_by {
  id: order_by
  iyziEventTime: order_by
  iyziEventType: order_by
  iyziReferenceCode: order_by
  order: order_order_by
  paymentConversationId: order_by
  paymentId: order_by
  status: order_by
}

"""primary key columns input for table: transaction"""
input transaction_pk_columns_input {
  id: uuid!
}

"""
select columns of table "transaction"
"""
enum transaction_select_column {
  """column name"""
  id

  """column name"""
  iyziEventTime

  """column name"""
  iyziEventType

  """column name"""
  iyziReferenceCode

  """column name"""
  paymentConversationId

  """column name"""
  paymentId

  """column name"""
  status
}

"""
input type for updating data in table "transaction"
"""
input transaction_set_input {
  id: uuid
  iyziEventTime: String
  iyziEventType: String
  iyziReferenceCode: String
  paymentConversationId: String
  paymentId: String
  status: String
}

"""
Streaming cursor of the table "transaction"
"""
input transaction_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: transaction_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input transaction_stream_cursor_value_input {
  id: uuid
  iyziEventTime: String
  iyziEventType: String
  iyziReferenceCode: String
  paymentConversationId: String
  paymentId: String
  status: String
}

"""
update columns of table "transaction"
"""
enum transaction_update_column {
  """column name"""
  id

  """column name"""
  iyziEventTime

  """column name"""
  iyziEventType

  """column name"""
  iyziReferenceCode

  """column name"""
  paymentConversationId

  """column name"""
  paymentId

  """column name"""
  status
}

input transaction_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: transaction_set_input

  """filter the rows which have to be updated"""
  where: transaction_bool_exp!
}

"""
columns and relationships of "user"
"""
type user {
  auth_provider: String

  """An array relationship"""
  carts(
    """distinct select on columns"""
    distinct_on: [cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cart_order_by!]

    """filter the rows returned"""
    where: cart_bool_exp
  ): [cart!]!

  """An aggregate relationship"""
  carts_aggregate(
    """distinct select on columns"""
    distinct_on: [cart_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cart_order_by!]

    """filter the rows returned"""
    where: cart_bool_exp
  ): cart_aggregate!

  """An array relationship"""
  chat_threads_tenant(
    """distinct select on columns"""
    distinct_on: [chat_thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_thread_order_by!]

    """filter the rows returned"""
    where: chat_thread_bool_exp
  ): [chat_thread!]!

  """An aggregate relationship"""
  chat_threads_tenant_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_thread_order_by!]

    """filter the rows returned"""
    where: chat_thread_bool_exp
  ): chat_thread_aggregate!

  """An array relationship"""
  chat_threads_user(
    """distinct select on columns"""
    distinct_on: [chat_thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_thread_order_by!]

    """filter the rows returned"""
    where: chat_thread_bool_exp
  ): [chat_thread!]!

  """An aggregate relationship"""
  chat_threads_user_aggregate(
    """distinct select on columns"""
    distinct_on: [chat_thread_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chat_thread_order_by!]

    """filter the rows returned"""
    where: chat_thread_bool_exp
  ): chat_thread_aggregate!

  """An array relationship"""
  companies(
    """distinct select on columns"""
    distinct_on: [company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_order_by!]

    """filter the rows returned"""
    where: company_bool_exp
  ): [company!]!

  """An aggregate relationship"""
  companies_aggregate(
    """distinct select on columns"""
    distinct_on: [company_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_order_by!]

    """filter the rows returned"""
    where: company_bool_exp
  ): company_aggregate!
  created_at: timestamptz
  email: String
  email_verified: Boolean

  """An array relationship"""
  favorites(
    """distinct select on columns"""
    distinct_on: [user_favorite_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_favorite_order_by!]

    """filter the rows returned"""
    where: user_favorite_bool_exp
  ): [user_favorite!]!

  """An aggregate relationship"""
  favorites_aggregate(
    """distinct select on columns"""
    distinct_on: [user_favorite_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_favorite_order_by!]

    """filter the rows returned"""
    where: user_favorite_bool_exp
  ): user_favorite_aggregate!
  firstname: String
  id: uuid!
  identity_number: String
  is_active_user: Boolean
  lastname: String

  """An array relationship"""
  orders(
    """distinct select on columns"""
    distinct_on: [order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_order_by!]

    """filter the rows returned"""
    where: order_bool_exp
  ): [order!]!

  """An aggregate relationship"""
  orders_aggregate(
    """distinct select on columns"""
    distinct_on: [order_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [order_order_by!]

    """filter the rows returned"""
    where: order_bool_exp
  ): order_aggregate!
  password: String
  password_reset_token: String
  password_reset_token_exp: timestamptz
  phone: String
  phone_verified: Boolean
  picture: String

  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): [product!]!

  """An aggregate relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [product_order_by!]

    """filter the rows returned"""
    where: product_bool_exp
  ): product_aggregate!
  provider_id: String

  """An array relationship"""
  questions(
    """distinct select on columns"""
    distinct_on: [question_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [question_order_by!]

    """filter the rows returned"""
    where: question_bool_exp
  ): [question!]!

  """An aggregate relationship"""
  questions_aggregate(
    """distinct select on columns"""
    distinct_on: [question_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [question_order_by!]

    """filter the rows returned"""
    where: question_bool_exp
  ): question_aggregate!
  reference_code: String

  """An array relationship"""
  reviews(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): [review!]!

  """An aggregate relationship"""
  reviews_aggregate(
    """distinct select on columns"""
    distinct_on: [review_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [review_order_by!]

    """filter the rows returned"""
    where: review_bool_exp
  ): review_aggregate!
  role: role_enum
  session_id: String

  """An array relationship"""
  sessions(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): [session!]!

  """An aggregate relationship"""
  sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [session_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [session_order_by!]

    """filter the rows returned"""
    where: session_bool_exp
  ): session_aggregate!

  """An array relationship"""
  tenants(
    """distinct select on columns"""
    distinct_on: [tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_order_by!]

    """filter the rows returned"""
    where: tenant_bool_exp
  ): [tenant!]!

  """An aggregate relationship"""
  tenants_aggregate(
    """distinct select on columns"""
    distinct_on: [tenant_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tenant_order_by!]

    """filter the rows returned"""
    where: tenant_bool_exp
  ): tenant_aggregate!

  """An array relationship"""
  tickets(
    """distinct select on columns"""
    distinct_on: [ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_order_by!]

    """filter the rows returned"""
    where: ticket_bool_exp
  ): [ticket!]!

  """An aggregate relationship"""
  tickets_aggregate(
    """distinct select on columns"""
    distinct_on: [ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ticket_order_by!]

    """filter the rows returned"""
    where: ticket_bool_exp
  ): ticket_aggregate!
  updated_at: timestamptz

  """An array relationship"""
  user_addresses(
    """distinct select on columns"""
    distinct_on: [user_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_address_order_by!]

    """filter the rows returned"""
    where: user_address_bool_exp
  ): [user_address!]!

  """An aggregate relationship"""
  user_addresses_aggregate(
    """distinct select on columns"""
    distinct_on: [user_address_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_address_order_by!]

    """filter the rows returned"""
    where: user_address_bool_exp
  ): user_address_aggregate!

  """An array relationship"""
  user_coupons(
    """distinct select on columns"""
    distinct_on: [user_coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_coupon_order_by!]

    """filter the rows returned"""
    where: user_coupon_bool_exp
  ): [user_coupon!]!

  """An aggregate relationship"""
  user_coupons_aggregate(
    """distinct select on columns"""
    distinct_on: [user_coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_coupon_order_by!]

    """filter the rows returned"""
    where: user_coupon_bool_exp
  ): user_coupon_aggregate!

  """An object relationship"""
  user_role: role
  verify_token: String
  verify_token_exp: timestamptz
}

"""
columns and relationships of "user_address"
"""
type user_address {
  address: String!
  address_title: String!

  """An object relationship"""
  city: city!
  city_id: Int!

  """An object relationship"""
  district: district!
  district_id: Int!
  id: Int!

  """An object relationship"""
  quarter: quarter!
  quarter_id: Int!
  receiver_firstname: String!
  receiver_phone: String!
  receiver_surname: String!

  """An object relationship"""
  user: user!
  user_id: uuid!
}

"""
aggregated selection of "user_address"
"""
type user_address_aggregate {
  aggregate: user_address_aggregate_fields
  nodes: [user_address!]!
}

input user_address_aggregate_bool_exp {
  count: user_address_aggregate_bool_exp_count
}

input user_address_aggregate_bool_exp_count {
  arguments: [user_address_select_column!]
  distinct: Boolean
  filter: user_address_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_address"
"""
type user_address_aggregate_fields {
  avg: user_address_avg_fields
  count(columns: [user_address_select_column!], distinct: Boolean): Int!
  max: user_address_max_fields
  min: user_address_min_fields
  stddev: user_address_stddev_fields
  stddev_pop: user_address_stddev_pop_fields
  stddev_samp: user_address_stddev_samp_fields
  sum: user_address_sum_fields
  var_pop: user_address_var_pop_fields
  var_samp: user_address_var_samp_fields
  variance: user_address_variance_fields
}

"""
order by aggregate values of table "user_address"
"""
input user_address_aggregate_order_by {
  avg: user_address_avg_order_by
  count: order_by
  max: user_address_max_order_by
  min: user_address_min_order_by
  stddev: user_address_stddev_order_by
  stddev_pop: user_address_stddev_pop_order_by
  stddev_samp: user_address_stddev_samp_order_by
  sum: user_address_sum_order_by
  var_pop: user_address_var_pop_order_by
  var_samp: user_address_var_samp_order_by
  variance: user_address_variance_order_by
}

"""
input type for inserting array relation for remote table "user_address"
"""
input user_address_arr_rel_insert_input {
  data: [user_address_insert_input!]!

  """upsert condition"""
  on_conflict: user_address_on_conflict
}

"""aggregate avg on columns"""
type user_address_avg_fields {
  city_id: Float
  district_id: Float
  id: Float
  quarter_id: Float
}

"""
order by avg() on columns of table "user_address"
"""
input user_address_avg_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""
Boolean expression to filter rows from the table "user_address". All fields are combined with a logical 'AND'.
"""
input user_address_bool_exp {
  _and: [user_address_bool_exp!]
  _not: user_address_bool_exp
  _or: [user_address_bool_exp!]
  address: String_comparison_exp
  address_title: String_comparison_exp
  city: city_bool_exp
  city_id: Int_comparison_exp
  district: district_bool_exp
  district_id: Int_comparison_exp
  id: Int_comparison_exp
  quarter: quarter_bool_exp
  quarter_id: Int_comparison_exp
  receiver_firstname: String_comparison_exp
  receiver_phone: String_comparison_exp
  receiver_surname: String_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_address"
"""
enum user_address_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_address_pkey

  """
  unique or primary key constraint on columns "user_id", "address_title"
  """
  user_address_user_id_address_title_key
}

"""
input type for incrementing numeric columns in table "user_address"
"""
input user_address_inc_input {
  city_id: Int
  district_id: Int
  id: Int
  quarter_id: Int
}

"""
input type for inserting data into table "user_address"
"""
input user_address_insert_input {
  address: String
  address_title: String
  city: city_obj_rel_insert_input
  city_id: Int
  district: district_obj_rel_insert_input
  district_id: Int
  id: Int
  quarter: quarter_obj_rel_insert_input
  quarter_id: Int
  receiver_firstname: String
  receiver_phone: String
  receiver_surname: String
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type user_address_max_fields {
  address: String
  address_title: String
  city_id: Int
  district_id: Int
  id: Int
  quarter_id: Int
  receiver_firstname: String
  receiver_phone: String
  receiver_surname: String
  user_id: uuid
}

"""
order by max() on columns of table "user_address"
"""
input user_address_max_order_by {
  address: order_by
  address_title: order_by
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
  receiver_firstname: order_by
  receiver_phone: order_by
  receiver_surname: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type user_address_min_fields {
  address: String
  address_title: String
  city_id: Int
  district_id: Int
  id: Int
  quarter_id: Int
  receiver_firstname: String
  receiver_phone: String
  receiver_surname: String
  user_id: uuid
}

"""
order by min() on columns of table "user_address"
"""
input user_address_min_order_by {
  address: order_by
  address_title: order_by
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
  receiver_firstname: order_by
  receiver_phone: order_by
  receiver_surname: order_by
  user_id: order_by
}

"""
response of any mutation on the table "user_address"
"""
type user_address_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_address!]!
}

"""
on_conflict condition type for table "user_address"
"""
input user_address_on_conflict {
  constraint: user_address_constraint!
  update_columns: [user_address_update_column!]! = []
  where: user_address_bool_exp
}

"""Ordering options when selecting data from "user_address"."""
input user_address_order_by {
  address: order_by
  address_title: order_by
  city: city_order_by
  city_id: order_by
  district: district_order_by
  district_id: order_by
  id: order_by
  quarter: quarter_order_by
  quarter_id: order_by
  receiver_firstname: order_by
  receiver_phone: order_by
  receiver_surname: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: user_address"""
input user_address_pk_columns_input {
  id: Int!
}

"""
select columns of table "user_address"
"""
enum user_address_select_column {
  """column name"""
  address

  """column name"""
  address_title

  """column name"""
  city_id

  """column name"""
  district_id

  """column name"""
  id

  """column name"""
  quarter_id

  """column name"""
  receiver_firstname

  """column name"""
  receiver_phone

  """column name"""
  receiver_surname

  """column name"""
  user_id
}

"""
input type for updating data in table "user_address"
"""
input user_address_set_input {
  address: String
  address_title: String
  city_id: Int
  district_id: Int
  id: Int
  quarter_id: Int
  receiver_firstname: String
  receiver_phone: String
  receiver_surname: String
  user_id: uuid
}

"""aggregate stddev on columns"""
type user_address_stddev_fields {
  city_id: Float
  district_id: Float
  id: Float
  quarter_id: Float
}

"""
order by stddev() on columns of table "user_address"
"""
input user_address_stddev_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""aggregate stddev_pop on columns"""
type user_address_stddev_pop_fields {
  city_id: Float
  district_id: Float
  id: Float
  quarter_id: Float
}

"""
order by stddev_pop() on columns of table "user_address"
"""
input user_address_stddev_pop_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""aggregate stddev_samp on columns"""
type user_address_stddev_samp_fields {
  city_id: Float
  district_id: Float
  id: Float
  quarter_id: Float
}

"""
order by stddev_samp() on columns of table "user_address"
"""
input user_address_stddev_samp_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""
Streaming cursor of the table "user_address"
"""
input user_address_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_address_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_address_stream_cursor_value_input {
  address: String
  address_title: String
  city_id: Int
  district_id: Int
  id: Int
  quarter_id: Int
  receiver_firstname: String
  receiver_phone: String
  receiver_surname: String
  user_id: uuid
}

"""aggregate sum on columns"""
type user_address_sum_fields {
  city_id: Int
  district_id: Int
  id: Int
  quarter_id: Int
}

"""
order by sum() on columns of table "user_address"
"""
input user_address_sum_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""
update columns of table "user_address"
"""
enum user_address_update_column {
  """column name"""
  address

  """column name"""
  address_title

  """column name"""
  city_id

  """column name"""
  district_id

  """column name"""
  id

  """column name"""
  quarter_id

  """column name"""
  receiver_firstname

  """column name"""
  receiver_phone

  """column name"""
  receiver_surname

  """column name"""
  user_id
}

input user_address_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: user_address_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_address_set_input

  """filter the rows which have to be updated"""
  where: user_address_bool_exp!
}

"""aggregate var_pop on columns"""
type user_address_var_pop_fields {
  city_id: Float
  district_id: Float
  id: Float
  quarter_id: Float
}

"""
order by var_pop() on columns of table "user_address"
"""
input user_address_var_pop_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""aggregate var_samp on columns"""
type user_address_var_samp_fields {
  city_id: Float
  district_id: Float
  id: Float
  quarter_id: Float
}

"""
order by var_samp() on columns of table "user_address"
"""
input user_address_var_samp_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""aggregate variance on columns"""
type user_address_variance_fields {
  city_id: Float
  district_id: Float
  id: Float
  quarter_id: Float
}

"""
order by variance() on columns of table "user_address"
"""
input user_address_variance_order_by {
  city_id: order_by
  district_id: order_by
  id: order_by
  quarter_id: order_by
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

input user_aggregate_bool_exp {
  bool_and: user_aggregate_bool_exp_bool_and
  bool_or: user_aggregate_bool_exp_bool_or
  count: user_aggregate_bool_exp_count
}

input user_aggregate_bool_exp_bool_and {
  arguments: user_select_column_user_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: user_bool_exp
  predicate: Boolean_comparison_exp!
}

input user_aggregate_bool_exp_bool_or {
  arguments: user_select_column_user_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: user_bool_exp
  predicate: Boolean_comparison_exp!
}

input user_aggregate_bool_exp_count {
  arguments: [user_select_column!]
  distinct: Boolean
  filter: user_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  count(columns: [user_select_column!], distinct: Boolean): Int!
  max: user_max_fields
  min: user_min_fields
}

"""
order by aggregate values of table "user"
"""
input user_aggregate_order_by {
  count: order_by
  max: user_max_order_by
  min: user_min_order_by
}

"""
input type for inserting array relation for remote table "user"
"""
input user_arr_rel_insert_input {
  data: [user_insert_input!]!

  """upsert condition"""
  on_conflict: user_on_conflict
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  auth_provider: String_comparison_exp
  carts: cart_bool_exp
  carts_aggregate: cart_aggregate_bool_exp
  chat_threads_tenant: chat_thread_bool_exp
  chat_threads_tenant_aggregate: chat_thread_aggregate_bool_exp
  chat_threads_user: chat_thread_bool_exp
  chat_threads_user_aggregate: chat_thread_aggregate_bool_exp
  companies: company_bool_exp
  companies_aggregate: company_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  email_verified: Boolean_comparison_exp
  favorites: user_favorite_bool_exp
  favorites_aggregate: user_favorite_aggregate_bool_exp
  firstname: String_comparison_exp
  id: uuid_comparison_exp
  identity_number: String_comparison_exp
  is_active_user: Boolean_comparison_exp
  lastname: String_comparison_exp
  orders: order_bool_exp
  orders_aggregate: order_aggregate_bool_exp
  password: String_comparison_exp
  password_reset_token: String_comparison_exp
  password_reset_token_exp: timestamptz_comparison_exp
  phone: String_comparison_exp
  phone_verified: Boolean_comparison_exp
  picture: String_comparison_exp
  products: product_bool_exp
  products_aggregate: product_aggregate_bool_exp
  provider_id: String_comparison_exp
  questions: question_bool_exp
  questions_aggregate: question_aggregate_bool_exp
  reference_code: String_comparison_exp
  reviews: review_bool_exp
  reviews_aggregate: review_aggregate_bool_exp
  role: role_enum_comparison_exp
  session_id: String_comparison_exp
  sessions: session_bool_exp
  sessions_aggregate: session_aggregate_bool_exp
  tenants: tenant_bool_exp
  tenants_aggregate: tenant_aggregate_bool_exp
  tickets: ticket_bool_exp
  tickets_aggregate: ticket_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  user_addresses: user_address_bool_exp
  user_addresses_aggregate: user_address_aggregate_bool_exp
  user_coupons: user_coupon_bool_exp
  user_coupons_aggregate: user_coupon_aggregate_bool_exp
  user_role: role_bool_exp
  verify_token: String_comparison_exp
  verify_token_exp: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  user_email_key

  """
  unique or primary key constraint on columns "id"
  """
  user_pkey

  """
  unique or primary key constraint on columns "session_id"
  """
  user_session_id_key
}

"""
columns and relationships of "user_coupon"
"""
type user_coupon {
  """An object relationship"""
  coupon: coupon!
  coupon_code: String!
  created_at: timestamptz!
  guest_id: uuid
  id: uuid!

  """An object relationship"""
  order: order!
  order_id: uuid!

  """An object relationship"""
  user: user
  user_id: uuid
}

"""
aggregated selection of "user_coupon"
"""
type user_coupon_aggregate {
  aggregate: user_coupon_aggregate_fields
  nodes: [user_coupon!]!
}

input user_coupon_aggregate_bool_exp {
  count: user_coupon_aggregate_bool_exp_count
}

input user_coupon_aggregate_bool_exp_count {
  arguments: [user_coupon_select_column!]
  distinct: Boolean
  filter: user_coupon_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_coupon"
"""
type user_coupon_aggregate_fields {
  count(columns: [user_coupon_select_column!], distinct: Boolean): Int!
  max: user_coupon_max_fields
  min: user_coupon_min_fields
}

"""
order by aggregate values of table "user_coupon"
"""
input user_coupon_aggregate_order_by {
  count: order_by
  max: user_coupon_max_order_by
  min: user_coupon_min_order_by
}

"""
input type for inserting array relation for remote table "user_coupon"
"""
input user_coupon_arr_rel_insert_input {
  data: [user_coupon_insert_input!]!

  """upsert condition"""
  on_conflict: user_coupon_on_conflict
}

"""
Boolean expression to filter rows from the table "user_coupon". All fields are combined with a logical 'AND'.
"""
input user_coupon_bool_exp {
  _and: [user_coupon_bool_exp!]
  _not: user_coupon_bool_exp
  _or: [user_coupon_bool_exp!]
  coupon: coupon_bool_exp
  coupon_code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  guest_id: uuid_comparison_exp
  id: uuid_comparison_exp
  order: order_bool_exp
  order_id: uuid_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_coupon"
"""
enum user_coupon_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_coupon_pkey
}

"""
input type for inserting data into table "user_coupon"
"""
input user_coupon_insert_input {
  coupon: coupon_obj_rel_insert_input
  coupon_code: String
  created_at: timestamptz
  guest_id: uuid
  id: uuid
  order: order_obj_rel_insert_input
  order_id: uuid
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type user_coupon_max_fields {
  coupon_code: String
  created_at: timestamptz
  guest_id: uuid
  id: uuid
  order_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "user_coupon"
"""
input user_coupon_max_order_by {
  coupon_code: order_by
  created_at: order_by
  guest_id: order_by
  id: order_by
  order_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type user_coupon_min_fields {
  coupon_code: String
  created_at: timestamptz
  guest_id: uuid
  id: uuid
  order_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "user_coupon"
"""
input user_coupon_min_order_by {
  coupon_code: order_by
  created_at: order_by
  guest_id: order_by
  id: order_by
  order_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "user_coupon"
"""
type user_coupon_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_coupon!]!
}

"""
on_conflict condition type for table "user_coupon"
"""
input user_coupon_on_conflict {
  constraint: user_coupon_constraint!
  update_columns: [user_coupon_update_column!]! = []
  where: user_coupon_bool_exp
}

"""Ordering options when selecting data from "user_coupon"."""
input user_coupon_order_by {
  coupon: coupon_order_by
  coupon_code: order_by
  created_at: order_by
  guest_id: order_by
  id: order_by
  order: order_order_by
  order_id: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: user_coupon"""
input user_coupon_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user_coupon"
"""
enum user_coupon_select_column {
  """column name"""
  coupon_code

  """column name"""
  created_at

  """column name"""
  guest_id

  """column name"""
  id

  """column name"""
  order_id

  """column name"""
  user_id
}

"""
input type for updating data in table "user_coupon"
"""
input user_coupon_set_input {
  coupon_code: String
  created_at: timestamptz
  guest_id: uuid
  id: uuid
  order_id: uuid
  user_id: uuid
}

"""
Streaming cursor of the table "user_coupon"
"""
input user_coupon_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_coupon_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_coupon_stream_cursor_value_input {
  coupon_code: String
  created_at: timestamptz
  guest_id: uuid
  id: uuid
  order_id: uuid
  user_id: uuid
}

"""
update columns of table "user_coupon"
"""
enum user_coupon_update_column {
  """column name"""
  coupon_code

  """column name"""
  created_at

  """column name"""
  guest_id

  """column name"""
  id

  """column name"""
  order_id

  """column name"""
  user_id
}

input user_coupon_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_coupon_set_input

  """filter the rows which have to be updated"""
  where: user_coupon_bool_exp!
}

"""
columns and relationships of "user_favorite"
"""
type user_favorite {
  created_at: timestamptz!
  id: bigint!

  """An object relationship"""
  product: product!
  product_id: bigint!
  session_id: String

  """An object relationship"""
  user: user
  user_id: uuid
}

"""
aggregated selection of "user_favorite"
"""
type user_favorite_aggregate {
  aggregate: user_favorite_aggregate_fields
  nodes: [user_favorite!]!
}

input user_favorite_aggregate_bool_exp {
  count: user_favorite_aggregate_bool_exp_count
}

input user_favorite_aggregate_bool_exp_count {
  arguments: [user_favorite_select_column!]
  distinct: Boolean
  filter: user_favorite_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_favorite"
"""
type user_favorite_aggregate_fields {
  avg: user_favorite_avg_fields
  count(columns: [user_favorite_select_column!], distinct: Boolean): Int!
  max: user_favorite_max_fields
  min: user_favorite_min_fields
  stddev: user_favorite_stddev_fields
  stddev_pop: user_favorite_stddev_pop_fields
  stddev_samp: user_favorite_stddev_samp_fields
  sum: user_favorite_sum_fields
  var_pop: user_favorite_var_pop_fields
  var_samp: user_favorite_var_samp_fields
  variance: user_favorite_variance_fields
}

"""
order by aggregate values of table "user_favorite"
"""
input user_favorite_aggregate_order_by {
  avg: user_favorite_avg_order_by
  count: order_by
  max: user_favorite_max_order_by
  min: user_favorite_min_order_by
  stddev: user_favorite_stddev_order_by
  stddev_pop: user_favorite_stddev_pop_order_by
  stddev_samp: user_favorite_stddev_samp_order_by
  sum: user_favorite_sum_order_by
  var_pop: user_favorite_var_pop_order_by
  var_samp: user_favorite_var_samp_order_by
  variance: user_favorite_variance_order_by
}

"""
input type for inserting array relation for remote table "user_favorite"
"""
input user_favorite_arr_rel_insert_input {
  data: [user_favorite_insert_input!]!

  """upsert condition"""
  on_conflict: user_favorite_on_conflict
}

"""aggregate avg on columns"""
type user_favorite_avg_fields {
  id: Float
  product_id: Float
}

"""
order by avg() on columns of table "user_favorite"
"""
input user_favorite_avg_order_by {
  id: order_by
  product_id: order_by
}

"""
Boolean expression to filter rows from the table "user_favorite". All fields are combined with a logical 'AND'.
"""
input user_favorite_bool_exp {
  _and: [user_favorite_bool_exp!]
  _not: user_favorite_bool_exp
  _or: [user_favorite_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  product: product_bool_exp
  product_id: bigint_comparison_exp
  session_id: String_comparison_exp
  user: user_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_favorite"
"""
enum user_favorite_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_favorite_pkey

  """
  unique or primary key constraint on columns "user_id", "product_id"
  """
  user_favorite_user_id_product_id_key
}

"""
input type for incrementing numeric columns in table "user_favorite"
"""
input user_favorite_inc_input {
  id: bigint
  product_id: bigint
}

"""
input type for inserting data into table "user_favorite"
"""
input user_favorite_insert_input {
  created_at: timestamptz
  id: bigint
  product: product_obj_rel_insert_input
  product_id: bigint
  session_id: String
  user: user_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type user_favorite_max_fields {
  created_at: timestamptz
  id: bigint
  product_id: bigint
  session_id: String
  user_id: uuid
}

"""
order by max() on columns of table "user_favorite"
"""
input user_favorite_max_order_by {
  created_at: order_by
  id: order_by
  product_id: order_by
  session_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type user_favorite_min_fields {
  created_at: timestamptz
  id: bigint
  product_id: bigint
  session_id: String
  user_id: uuid
}

"""
order by min() on columns of table "user_favorite"
"""
input user_favorite_min_order_by {
  created_at: order_by
  id: order_by
  product_id: order_by
  session_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "user_favorite"
"""
type user_favorite_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_favorite!]!
}

"""
on_conflict condition type for table "user_favorite"
"""
input user_favorite_on_conflict {
  constraint: user_favorite_constraint!
  update_columns: [user_favorite_update_column!]! = []
  where: user_favorite_bool_exp
}

"""Ordering options when selecting data from "user_favorite"."""
input user_favorite_order_by {
  created_at: order_by
  id: order_by
  product: product_order_by
  product_id: order_by
  session_id: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: user_favorite"""
input user_favorite_pk_columns_input {
  id: bigint!
}

"""
select columns of table "user_favorite"
"""
enum user_favorite_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  session_id

  """column name"""
  user_id
}

"""
input type for updating data in table "user_favorite"
"""
input user_favorite_set_input {
  created_at: timestamptz
  id: bigint
  product_id: bigint
  session_id: String
  user_id: uuid
}

"""aggregate stddev on columns"""
type user_favorite_stddev_fields {
  id: Float
  product_id: Float
}

"""
order by stddev() on columns of table "user_favorite"
"""
input user_favorite_stddev_order_by {
  id: order_by
  product_id: order_by
}

"""aggregate stddev_pop on columns"""
type user_favorite_stddev_pop_fields {
  id: Float
  product_id: Float
}

"""
order by stddev_pop() on columns of table "user_favorite"
"""
input user_favorite_stddev_pop_order_by {
  id: order_by
  product_id: order_by
}

"""aggregate stddev_samp on columns"""
type user_favorite_stddev_samp_fields {
  id: Float
  product_id: Float
}

"""
order by stddev_samp() on columns of table "user_favorite"
"""
input user_favorite_stddev_samp_order_by {
  id: order_by
  product_id: order_by
}

"""
Streaming cursor of the table "user_favorite"
"""
input user_favorite_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_favorite_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_favorite_stream_cursor_value_input {
  created_at: timestamptz
  id: bigint
  product_id: bigint
  session_id: String
  user_id: uuid
}

"""aggregate sum on columns"""
type user_favorite_sum_fields {
  id: bigint
  product_id: bigint
}

"""
order by sum() on columns of table "user_favorite"
"""
input user_favorite_sum_order_by {
  id: order_by
  product_id: order_by
}

"""
update columns of table "user_favorite"
"""
enum user_favorite_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  session_id

  """column name"""
  user_id
}

input user_favorite_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: user_favorite_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_favorite_set_input

  """filter the rows which have to be updated"""
  where: user_favorite_bool_exp!
}

"""aggregate var_pop on columns"""
type user_favorite_var_pop_fields {
  id: Float
  product_id: Float
}

"""
order by var_pop() on columns of table "user_favorite"
"""
input user_favorite_var_pop_order_by {
  id: order_by
  product_id: order_by
}

"""aggregate var_samp on columns"""
type user_favorite_var_samp_fields {
  id: Float
  product_id: Float
}

"""
order by var_samp() on columns of table "user_favorite"
"""
input user_favorite_var_samp_order_by {
  id: order_by
  product_id: order_by
}

"""aggregate variance on columns"""
type user_favorite_variance_fields {
  id: Float
  product_id: Float
}

"""
order by variance() on columns of table "user_favorite"
"""
input user_favorite_variance_order_by {
  id: order_by
  product_id: order_by
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  auth_provider: String
  carts: cart_arr_rel_insert_input
  chat_threads_tenant: chat_thread_arr_rel_insert_input
  chat_threads_user: chat_thread_arr_rel_insert_input
  companies: company_arr_rel_insert_input
  created_at: timestamptz
  email: String
  email_verified: Boolean
  favorites: user_favorite_arr_rel_insert_input
  firstname: String
  id: uuid
  identity_number: String
  is_active_user: Boolean
  lastname: String
  orders: order_arr_rel_insert_input
  password: String
  password_reset_token: String
  password_reset_token_exp: timestamptz
  phone: String
  phone_verified: Boolean
  picture: String
  products: product_arr_rel_insert_input
  provider_id: String
  questions: question_arr_rel_insert_input
  reference_code: String
  reviews: review_arr_rel_insert_input
  role: role_enum
  session_id: String
  sessions: session_arr_rel_insert_input
  tenants: tenant_arr_rel_insert_input
  tickets: ticket_arr_rel_insert_input
  updated_at: timestamptz
  user_addresses: user_address_arr_rel_insert_input
  user_coupons: user_coupon_arr_rel_insert_input
  user_role: role_obj_rel_insert_input
  verify_token: String
  verify_token_exp: timestamptz
}

"""aggregate max on columns"""
type user_max_fields {
  auth_provider: String
  created_at: timestamptz
  email: String
  firstname: String
  id: uuid
  identity_number: String
  lastname: String
  password: String
  password_reset_token: String
  password_reset_token_exp: timestamptz
  phone: String
  picture: String
  provider_id: String
  reference_code: String
  session_id: String
  updated_at: timestamptz
  verify_token: String
  verify_token_exp: timestamptz
}

"""
order by max() on columns of table "user"
"""
input user_max_order_by {
  auth_provider: order_by
  created_at: order_by
  email: order_by
  firstname: order_by
  id: order_by
  identity_number: order_by
  lastname: order_by
  password: order_by
  password_reset_token: order_by
  password_reset_token_exp: order_by
  phone: order_by
  picture: order_by
  provider_id: order_by
  reference_code: order_by
  session_id: order_by
  updated_at: order_by
  verify_token: order_by
  verify_token_exp: order_by
}

"""aggregate min on columns"""
type user_min_fields {
  auth_provider: String
  created_at: timestamptz
  email: String
  firstname: String
  id: uuid
  identity_number: String
  lastname: String
  password: String
  password_reset_token: String
  password_reset_token_exp: timestamptz
  phone: String
  picture: String
  provider_id: String
  reference_code: String
  session_id: String
  updated_at: timestamptz
  verify_token: String
  verify_token_exp: timestamptz
}

"""
order by min() on columns of table "user"
"""
input user_min_order_by {
  auth_provider: order_by
  created_at: order_by
  email: order_by
  firstname: order_by
  id: order_by
  identity_number: order_by
  lastname: order_by
  password: order_by
  password_reset_token: order_by
  password_reset_token_exp: order_by
  phone: order_by
  picture: order_by
  provider_id: order_by
  reference_code: order_by
  session_id: order_by
  updated_at: order_by
  verify_token: order_by
  verify_token_exp: order_by
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!

  """upsert condition"""
  on_conflict: user_on_conflict
}

"""
on_conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]! = []
  where: user_bool_exp
}

"""Ordering options when selecting data from "user"."""
input user_order_by {
  auth_provider: order_by
  carts_aggregate: cart_aggregate_order_by
  chat_threads_tenant_aggregate: chat_thread_aggregate_order_by
  chat_threads_user_aggregate: chat_thread_aggregate_order_by
  companies_aggregate: company_aggregate_order_by
  created_at: order_by
  email: order_by
  email_verified: order_by
  favorites_aggregate: user_favorite_aggregate_order_by
  firstname: order_by
  id: order_by
  identity_number: order_by
  is_active_user: order_by
  lastname: order_by
  orders_aggregate: order_aggregate_order_by
  password: order_by
  password_reset_token: order_by
  password_reset_token_exp: order_by
  phone: order_by
  phone_verified: order_by
  picture: order_by
  products_aggregate: product_aggregate_order_by
  provider_id: order_by
  questions_aggregate: question_aggregate_order_by
  reference_code: order_by
  reviews_aggregate: review_aggregate_order_by
  role: order_by
  session_id: order_by
  sessions_aggregate: session_aggregate_order_by
  tenants_aggregate: tenant_aggregate_order_by
  tickets_aggregate: ticket_aggregate_order_by
  updated_at: order_by
  user_addresses_aggregate: user_address_aggregate_order_by
  user_coupons_aggregate: user_coupon_aggregate_order_by
  user_role: role_order_by
  verify_token: order_by
  verify_token_exp: order_by
}

"""primary key columns input for table: user"""
input user_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  auth_provider

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  email_verified

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  identity_number

  """column name"""
  is_active_user

  """column name"""
  lastname

  """column name"""
  password

  """column name"""
  password_reset_token

  """column name"""
  password_reset_token_exp

  """column name"""
  phone

  """column name"""
  phone_verified

  """column name"""
  picture

  """column name"""
  provider_id

  """column name"""
  reference_code

  """column name"""
  role

  """column name"""
  session_id

  """column name"""
  updated_at

  """column name"""
  verify_token

  """column name"""
  verify_token_exp
}

"""
select "user_aggregate_bool_exp_bool_and_arguments_columns" columns of table "user"
"""
enum user_select_column_user_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  email_verified

  """column name"""
  is_active_user

  """column name"""
  phone_verified
}

"""
select "user_aggregate_bool_exp_bool_or_arguments_columns" columns of table "user"
"""
enum user_select_column_user_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  email_verified

  """column name"""
  is_active_user

  """column name"""
  phone_verified
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  auth_provider: String
  created_at: timestamptz
  email: String
  email_verified: Boolean
  firstname: String
  id: uuid
  identity_number: String
  is_active_user: Boolean
  lastname: String
  password: String
  password_reset_token: String
  password_reset_token_exp: timestamptz
  phone: String
  phone_verified: Boolean
  picture: String
  provider_id: String
  reference_code: String
  role: role_enum
  session_id: String
  updated_at: timestamptz
  verify_token: String
  verify_token_exp: timestamptz
}

"""
Streaming cursor of the table "user"
"""
input user_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_stream_cursor_value_input {
  auth_provider: String
  created_at: timestamptz
  email: String
  email_verified: Boolean
  firstname: String
  id: uuid
  identity_number: String
  is_active_user: Boolean
  lastname: String
  password: String
  password_reset_token: String
  password_reset_token_exp: timestamptz
  phone: String
  phone_verified: Boolean
  picture: String
  provider_id: String
  reference_code: String
  role: role_enum
  session_id: String
  updated_at: timestamptz
  verify_token: String
  verify_token_exp: timestamptz
}

"""
update columns of table "user"
"""
enum user_update_column {
  """column name"""
  auth_provider

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  email_verified

  """column name"""
  firstname

  """column name"""
  id

  """column name"""
  identity_number

  """column name"""
  is_active_user

  """column name"""
  lastname

  """column name"""
  password

  """column name"""
  password_reset_token

  """column name"""
  password_reset_token_exp

  """column name"""
  phone

  """column name"""
  phone_verified

  """column name"""
  picture

  """column name"""
  provider_id

  """column name"""
  reference_code

  """column name"""
  role

  """column name"""
  session_id

  """column name"""
  updated_at

  """column name"""
  verify_token

  """column name"""
  verify_token_exp
}

input user_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_set_input

  """filter the rows which have to be updated"""
  where: user_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}